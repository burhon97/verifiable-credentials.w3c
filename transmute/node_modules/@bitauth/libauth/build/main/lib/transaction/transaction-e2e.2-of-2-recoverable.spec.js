"use strict";
/* eslint-disable functional/no-expression-statement, camelcase, @typescript-eslint/naming-convention */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = __importDefault(require("ava"));
const lib_1 = require("../lib");
const transaction_e2e_spec_helper_1 = require("./transaction-e2e.spec.helper");
const vmPromise = lib_1.instantiateVirtualMachineBCH();
// eslint-disable-next-line complexity
ava_1.default('transaction e2e tests: 2-of-2 Recoverable Vault', async (t) => {
    const template = lib_1.validateAuthenticationTemplate(transaction_e2e_spec_helper_1.twoOfTwoRecoverableJson);
    if (typeof template === 'string') {
        t.fail(template);
        return;
    }
    /**
     * The HD public keys shared between the entities at wallet creation time
     */
    const hdPublicKeys = {
        signer_1: transaction_e2e_spec_helper_1.hdPublicKey0H,
        signer_2: transaction_e2e_spec_helper_1.hdPublicKey1H,
        trusted_party: transaction_e2e_spec_helper_1.hdPublicKey2H,
    };
    const creationDate = lib_1.dateToLocktime(new Date('2020-01-01T00:00:00.000Z'));
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    const threeMonths = 60 * 60 * 24 * 90;
    const locktimeFourMonthsLater = lib_1.dateToLocktime(new Date('2020-04-01T00:00:00.000Z'));
    const lockingData = {
        bytecode: { delay_seconds: lib_1.compileBtl(`${threeMonths}`) },
        currentBlockTime: creationDate,
        hdKeys: { addressIndex: 0, hdPublicKeys },
    };
    const lockingScript = 'lock';
    const compiler = await lib_1.authenticationTemplateToCompilerBCH(template);
    const lockingBytecode = compiler.generateBytecode(lockingScript, lockingData);
    if (!lockingBytecode.success) {
        t.log('lockingBytecode', lib_1.stringify(lockingBytecode));
        t.fail();
        return;
    }
    const address = lib_1.lockingBytecodeToCashAddress(lockingBytecode.bytecode, lib_1.CashAddressNetworkPrefix.testnet);
    t.deepEqual(address, 'bchtest:pz8p649zg3a492hxy86sh0ccvc7sptrlx5cp3eapah');
    const satoshis = 10000;
    const utxoOutput1 = {
        lockingBytecode: lockingBytecode.bytecode,
        satoshis: lib_1.bigIntToBinUint64LE(BigInt(satoshis)),
    };
    const utxoOutput2 = {
        lockingBytecode: lockingBytecode.bytecode,
        satoshis: lib_1.bigIntToBinUint64LE(BigInt(satoshis)),
    };
    /**
     * Test standard spend:
     */
    const input1 = {
        outpointIndex: 0,
        outpointTransactionHash: lib_1.hexToBin('6168cbf5d24784df4fef46e1e5cfacaee14cda4c29dd8114b9cfc44972aea46a'),
        sequenceNumber: 0,
        unlockingBytecode: {
            compiler,
            satoshis: utxoOutput1.satoshis,
            script: 'spend',
        },
    };
    /**
     * Test delayed recovery (in the same TX to make a useful reference TX):
     */
    const input2 = {
        outpointIndex: 1,
        outpointTransactionHash: lib_1.hexToBin('0ce50e17e71dadd8ba59e89a291cf3082862b32b229c5fbfc8dee3288165d97c'),
        sequenceNumber: 0,
        unlockingBytecode: {
            compiler,
            satoshis: utxoOutput2.satoshis,
            script: 'recover_1',
        },
    };
    const transactionProposal = {
        locktime: locktimeFourMonthsLater,
        outputs: [
            {
                lockingBytecode: lib_1.hexToBin('6a0b68656c6c6f20776f726c64'),
                satoshis: lib_1.bigIntToBinUint64LE(BigInt(0)),
            },
        ],
        version: 2,
    };
    const signer1UnlockingData = Object.assign(Object.assign({}, lockingData), { hdKeys: Object.assign(Object.assign({}, lockingData.hdKeys), { hdPrivateKeys: {
                signer_1: transaction_e2e_spec_helper_1.hdPrivateKey0H,
            } }) });
    const signer1Attempt = lib_1.generateTransaction(Object.assign(Object.assign({}, transactionProposal), { inputs: [
            Object.assign(Object.assign({}, input1), { unlockingBytecode: Object.assign(Object.assign({}, input1.unlockingBytecode), { data: signer1UnlockingData }) }),
            Object.assign(Object.assign({}, input2), { unlockingBytecode: Object.assign(Object.assign({}, input2.unlockingBytecode), { data: signer1UnlockingData }) }),
        ] }));
    if (signer1Attempt.success) {
        t.log('signer1Attempt:', lib_1.stringify(signer1Attempt));
        t.fail();
        return;
    }
    const signer1MissingVariables = lib_1.extractMissingVariables(signer1Attempt);
    t.deepEqual(signer1MissingVariables, {
        'second.signature.all_outputs': 'signer_2',
        'trusted.signature.all_outputs': 'trusted_party',
    });
    t.deepEqual(signer1Attempt.completions, []);
    const expectedSigner1SignatureInput1 = lib_1.hexToBin('304402200a34f3387a8aa3d7ed55506fbddb6957e27cc42063410306ac82e7a77f4d7030022065b08d5a07fac82d1cd6c90ff126f1af965e541525676538eab088b99daa897b41');
    const expectedSigner1SignatureInput2 = lib_1.hexToBin('3044022028141930f622819de84cf1a1b42fc2ea15c56bafd45e768c72fd84b4d0fe5b7e022066f659c79e6d8b6c53561be0b472bbeb355ffa443828fd8fb083148ffd26e8c841');
    /**
     * Signer 2 adds their signature, pulling in missing variables from signer 1
     */
    const signer2UnlockingData = Object.assign(Object.assign({}, lockingData), { hdKeys: Object.assign(Object.assign({}, lockingData.hdKeys), { hdPrivateKeys: {
                signer_2: transaction_e2e_spec_helper_1.hdPrivateKey1H,
            } }) });
    const signer2Attempt = lib_1.generateTransaction(Object.assign(Object.assign({}, transactionProposal), { inputs: [
            Object.assign(Object.assign({}, input1), { unlockingBytecode: Object.assign(Object.assign({}, input1.unlockingBytecode), { data: signer2UnlockingData }) }),
            Object.assign(Object.assign({}, input2), { unlockingBytecode: Object.assign(Object.assign({}, input2.unlockingBytecode), { data: signer2UnlockingData }) }),
        ] }));
    if (signer2Attempt.success) {
        t.log('signer2Attempt:', lib_1.stringify(signer2Attempt));
        t.fail();
        return;
    }
    const signer2Attempt2 = lib_1.generateTransaction(Object.assign(Object.assign({}, transactionProposal), { inputs: [
            Object.assign(Object.assign({}, input1), { unlockingBytecode: Object.assign(Object.assign({}, input1.unlockingBytecode), { data: Object.assign(Object.assign({}, signer2UnlockingData), { bytecode: Object.assign(Object.assign({}, signer2UnlockingData.bytecode), { 'first.signature.all_outputs': expectedSigner1SignatureInput1 }) }) }) }),
            Object.assign(Object.assign({}, input2), { unlockingBytecode: Object.assign(Object.assign({}, input2.unlockingBytecode), { data: Object.assign(Object.assign({}, signer2UnlockingData), { bytecode: Object.assign(Object.assign({}, signer2UnlockingData.bytecode), { 'first.signature.all_outputs': expectedSigner1SignatureInput2 }) }) }) }),
        ] }));
    if (signer2Attempt2.success) {
        t.log('signer2Attempt2:', lib_1.stringify(signer2Attempt2));
        t.fail();
        return;
    }
    const signer2Attempt2MissingVariables = lib_1.extractMissingVariables(signer2Attempt2);
    t.deepEqual(signer2Attempt2MissingVariables, {
        'trusted.signature.all_outputs': 'trusted_party',
    });
    t.deepEqual(signer2Attempt2.completions, [
        {
            index: 0,
            input: Object.assign(Object.assign({}, input1), { unlockingBytecode: lib_1.hexToBin('0047304402200a34f3387a8aa3d7ed55506fbddb6957e27cc42063410306ac82e7a77f4d7030022065b08d5a07fac82d1cd6c90ff126f1af965e541525676538eab088b99daa897b4147304402207d987a4d736fb6abb5f90109da05411e515c212c3b2c8527d15e8d863fe83957022004ad83f50e7b1ae87665c211717caca4b9e9714cd2d27bc4759cf6482394c9f641004c7563040088825eb1752103d9fffac162e9e15aecbe4f937b951815ccb4f940c850fff9ee52fa70805ae7dead51675268210349c17cce8a460f013fdcd286f90f7b0330101d0f3ab4ced44a5a3db764e465882102a438b1662aec9c35f85794600e1d2d3683a43cbb66307cf825fc4486b846954552ae') }),
            type: 'input',
        },
    ], lib_1.stringify(signer2Attempt2.completions));
    const completedInput1 = signer2Attempt2
        .completions[0].input;
    /**
     * Signer 3 adds their signature, pulling in the completed first input
     */
    const signer3UnlockingData = Object.assign(Object.assign({}, lockingData), { hdKeys: Object.assign(Object.assign({}, lockingData.hdKeys), { hdPrivateKeys: {
                trusted_party: transaction_e2e_spec_helper_1.hdPrivateKey2H,
            } }) });
    const signer3Attempt = lib_1.generateTransaction(Object.assign(Object.assign({}, transactionProposal), { inputs: [
            completedInput1,
            Object.assign(Object.assign({}, input2), { unlockingBytecode: Object.assign(Object.assign({}, input2.unlockingBytecode), { data: signer3UnlockingData }) }),
        ] }));
    if (signer3Attempt.success) {
        t.log('signer3Attempt:', lib_1.stringify(signer3Attempt));
        t.fail();
        return;
    }
    const successfulCompilation = lib_1.generateTransaction(Object.assign(Object.assign({}, transactionProposal), { inputs: [
            completedInput1,
            Object.assign(Object.assign({}, input2), { unlockingBytecode: Object.assign(Object.assign({}, input2.unlockingBytecode), { data: Object.assign(Object.assign({}, signer3UnlockingData), { bytecode: Object.assign(Object.assign({}, signer3UnlockingData.bytecode), { 'first.signature.all_outputs': expectedSigner1SignatureInput2 }) }) }) }),
        ] }));
    if (!successfulCompilation.success) {
        t.log('successfulCompilation:', lib_1.stringify(successfulCompilation));
        t.fail();
        return;
    }
    const { transaction } = successfulCompilation;
    const vm = await vmPromise;
    const result = lib_1.verifyTransaction({
        spentOutputs: [utxoOutput1, utxoOutput2],
        transaction,
        vm,
    });
    t.true(result, lib_1.stringify(result));
    t.deepEqual(successfulCompilation, {
        success: true,
        transaction: lib_1.decodeTransaction(
        /**
         * tx: e6c808adcb3cfc06461e962373659554bf6c447ea7b25ac503ff429e21050755
         */
        lib_1.hexToBin('02000000026aa4ae7249c4cfb91481dd294cda4ce1aeaccfe5e146ef4fdf8447d2f5cb686100000000fd09010047304402200a34f3387a8aa3d7ed55506fbddb6957e27cc42063410306ac82e7a77f4d7030022065b08d5a07fac82d1cd6c90ff126f1af965e541525676538eab088b99daa897b4147304402207d987a4d736fb6abb5f90109da05411e515c212c3b2c8527d15e8d863fe83957022004ad83f50e7b1ae87665c211717caca4b9e9714cd2d27bc4759cf6482394c9f641004c7563040088825eb1752103d9fffac162e9e15aecbe4f937b951815ccb4f940c850fff9ee52fa70805ae7dead51675268210349c17cce8a460f013fdcd286f90f7b0330101d0f3ab4ced44a5a3db764e465882102a438b1662aec9c35f85794600e1d2d3683a43cbb66307cf825fc4486b846954552ae000000007cd9658128e3dec8bf5f9c222bb3622808f31c299ae859bad8ad1de7170ee50c01000000fd0a0100473044022028141930f622819de84cf1a1b42fc2ea15c56bafd45e768c72fd84b4d0fe5b7e022066f659c79e6d8b6c53561be0b472bbeb355ffa443828fd8fb083148ffd26e8c841483045022100d62f54380b58b99677467a4016fceffd1cd85adabe6d2ffffab61a7e599dc5d302207a43e7809e5afae5069cef08d5f4960adcb9d245d295bbdf6bb8ab9a9056d11441514c7563040088825eb1752103d9fffac162e9e15aecbe4f937b951815ccb4f940c850fff9ee52fa70805ae7dead51675268210349c17cce8a460f013fdcd286f90f7b0330101d0f3ab4ced44a5a3db764e465882102a438b1662aec9c35f85794600e1d2d3683a43cbb66307cf825fc4486b846954552ae000000000100000000000000000d6a0b68656c6c6f20776f726c6480d9835e')),
    }, `${lib_1.stringify(successfulCompilation)} - ${lib_1.stringify(lib_1.encodeTransaction(successfulCompilation.transaction))}`);
});
//# sourceMappingURL=transaction-e2e.2-of-2-recoverable.spec.js.map