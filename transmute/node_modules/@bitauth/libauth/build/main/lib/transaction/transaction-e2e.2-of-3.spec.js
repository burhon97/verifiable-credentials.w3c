"use strict";
/* eslint-disable functional/no-expression-statement, camelcase, @typescript-eslint/naming-convention */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = __importDefault(require("ava"));
const lib_1 = require("../lib");
const transaction_e2e_spec_helper_1 = require("./transaction-e2e.spec.helper");
const vmPromise = lib_1.instantiateVirtualMachineBCH();
// eslint-disable-next-line complexity
ava_1.default('transaction e2e tests: 2-of-3 multisig', async (t) => {
    const template = lib_1.validateAuthenticationTemplate(transaction_e2e_spec_helper_1.twoOfThreeJson);
    if (typeof template === 'string') {
        t.fail(template);
        return;
    }
    /**
     * The HD public keys shared between the entities at wallet creation time
     */
    const hdPublicKeys = {
        signer_1: transaction_e2e_spec_helper_1.hdPublicKey0H,
        signer_2: transaction_e2e_spec_helper_1.hdPublicKey1H,
        signer_3: transaction_e2e_spec_helper_1.hdPublicKey2H,
    };
    const lockingData = {
        hdKeys: { addressIndex: 0, hdPublicKeys },
    };
    const lockingScript = 'lock';
    const compiler = await lib_1.authenticationTemplateToCompilerBCH(template);
    const lockingBytecode = compiler.generateBytecode(lockingScript, lockingData);
    if (!lockingBytecode.success) {
        t.log('lockingBytecode', lib_1.stringify(lockingBytecode));
        t.fail();
        return;
    }
    const address = lib_1.lockingBytecodeToCashAddress(lockingBytecode.bytecode, lib_1.CashAddressNetworkPrefix.testnet);
    t.deepEqual(address, 'bchtest:pplldqjpjaj0058xma6csnpgxd9ew2vxgv26n639yk');
    const satoshis = 10000;
    const utxoOutput = {
        lockingBytecode: lockingBytecode.bytecode,
        satoshis: lib_1.bigIntToBinUint64LE(BigInt(satoshis)),
    };
    const input1 = {
        outpointIndex: 1,
        outpointTransactionHash: lib_1.hexToBin('3423be78a1976b4ae3516cda594577df004663ff24f1beb9d5bb63056b1b0a60'),
        sequenceNumber: 0,
        unlockingBytecode: {
            compiler,
            satoshis: utxoOutput.satoshis,
            script: '1_and_3',
        },
    };
    const transactionProposal = {
        locktime: 0,
        outputs: [
            {
                lockingBytecode: lib_1.hexToBin('6a0b68656c6c6f20776f726c64'),
                satoshis: lib_1.bigIntToBinUint64LE(BigInt(0)),
            },
        ],
        version: 2,
    };
    const signer1UnlockingData = Object.assign(Object.assign({}, lockingData), { hdKeys: Object.assign(Object.assign({}, lockingData.hdKeys), { hdPrivateKeys: {
                signer_1: transaction_e2e_spec_helper_1.hdPrivateKey0H,
            } }) });
    const signer1Attempt = lib_1.generateTransaction(Object.assign(Object.assign({}, transactionProposal), { inputs: [
            Object.assign(Object.assign({}, input1), { unlockingBytecode: Object.assign(Object.assign({}, input1.unlockingBytecode), { data: signer1UnlockingData }) }),
        ] }));
    if (signer1Attempt.success) {
        t.log('signer1Attempt:', lib_1.stringify(signer1Attempt));
        t.fail();
        return;
    }
    const signer1MissingVariables = lib_1.extractMissingVariables(signer1Attempt);
    t.deepEqual(signer1MissingVariables, {
        'key3.signature.all_outputs': 'signer_3',
    });
    t.deepEqual(signer1Attempt.completions, []);
    const signer1ResolvedVariables = lib_1.extractResolvedVariables(signer1Attempt);
    const expectedSigner1Signature = lib_1.hexToBin('304402205e7d56c4e7854f9c672977d6606dd2f0af5494b8e61108e2a92fc920bf8049fc022065262675b0e1a3850d88bd3c56e0eb5fb463d9cdbe49f2f625da5c0f82c7653041');
    t.deepEqual(signer1ResolvedVariables, {
        'key1.signature.all_outputs': expectedSigner1Signature,
    }, lib_1.stringify(signer1ResolvedVariables));
    const signer3UnlockingData = {
        hdKeys: {
            addressIndex: 0,
            hdPrivateKeys: {
                signer_3: transaction_e2e_spec_helper_1.hdPrivateKey2H,
            },
            hdPublicKeys,
        },
    };
    const signer3Attempt = lib_1.generateTransaction(Object.assign(Object.assign({}, transactionProposal), { inputs: [
            Object.assign(Object.assign({}, input1), { unlockingBytecode: Object.assign(Object.assign({}, input1.unlockingBytecode), { data: signer3UnlockingData }) }),
        ] }));
    if (signer3Attempt.success) {
        t.log('signer3Attempt:', lib_1.stringify(signer1Attempt));
        t.fail();
        return;
    }
    const signer3UnlockingDataWithMissingVariables = lib_1.safelyExtendCompilationData(signer3Attempt, signer3UnlockingData, {
        signer_1: signer1ResolvedVariables,
    });
    t.deepEqual(signer3UnlockingDataWithMissingVariables, Object.assign(Object.assign({}, signer3UnlockingData), { bytecode: {
            'key1.signature.all_outputs': expectedSigner1Signature,
        } }), lib_1.stringify(signer3UnlockingDataWithMissingVariables));
    const successfulCompilation = lib_1.generateTransaction(Object.assign(Object.assign({}, transactionProposal), { inputs: [
            Object.assign(Object.assign({}, input1), { unlockingBytecode: Object.assign(Object.assign({}, input1.unlockingBytecode), { data: signer3UnlockingDataWithMissingVariables }) }),
        ] }));
    if (!successfulCompilation.success) {
        t.log('successfulCompilation:', lib_1.stringify(successfulCompilation));
        t.fail();
        return;
    }
    const { transaction } = successfulCompilation;
    const vm = await vmPromise;
    const result = lib_1.verifyTransaction({
        spentOutputs: [utxoOutput],
        transaction,
        vm,
    });
    t.true(result, lib_1.stringify(result));
    t.deepEqual(successfulCompilation, {
        success: true,
        transaction: lib_1.decodeTransaction(
        /**
         * tx: c903aba46b4069e485b51292fd68eefdc95110fb95461b118c650fb454c34a9c
         */
        lib_1.hexToBin('0200000001600a1b6b0563bbd5b9bef124ff634600df774559da6c51e34a6b97a178be233401000000fc0047304402205e7d56c4e7854f9c672977d6606dd2f0af5494b8e61108e2a92fc920bf8049fc022065262675b0e1a3850d88bd3c56e0eb5fb463d9cdbe49f2f625da5c0f82c765304147304402200d167d5ed77fa169346d295f6fb742e80ae391f0ae086d42b99152bdb23edf4102202c8b85c2583b07b66485b88cacdd14f680bd3aa3f3f12e9f63bc02b4d1cc6d15414c6952210349c17cce8a460f013fdcd286f90f7b0330101d0f3ab4ced44a5a3db764e465882102a438b1662aec9c35f85794600e1d2d3683a43cbb66307cf825fc4486b84695452103d9fffac162e9e15aecbe4f937b951815ccb4f940c850fff9ee52fa70805ae7de53ae000000000100000000000000000d6a0b68656c6c6f20776f726c6400000000')),
    }, `${lib_1.stringify(successfulCompilation)} - ${lib_1.stringify(lib_1.encodeTransaction(successfulCompilation.transaction))}`);
});
//# sourceMappingURL=transaction-e2e.2-of-3.spec.js.map