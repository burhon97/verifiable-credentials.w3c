"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable functional/no-expression-statement, @typescript-eslint/no-magic-numbers */
const ava_1 = __importDefault(require("ava"));
const ava_fast_check_1 = require("ava-fast-check");
const fc = __importStar(require("fast-check"));
const lib_1 = require("../lib");
ava_1.default('regroupBits', (t) => {
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11111111, 0b11111111],
        resultWordLength: 1,
        sourceWordLength: 8,
    }), [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
    t.deepEqual(lib_1.regroupBits({
        bin: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        resultWordLength: 8,
        sourceWordLength: 1,
    }), [0b11111111, 0b11111111]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11111111, 0b11111111],
        resultWordLength: 2,
        sourceWordLength: 8,
    }), [0b11, 0b11, 0b11, 0b11, 0b11, 0b11, 0b11, 0b11]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11, 0b11, 0b11, 0b11, 0b11, 0b11, 0b11, 0b11],
        resultWordLength: 8,
        sourceWordLength: 2,
    }), [0b11111111, 0b11111111]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11111111, 0b11111111],
        resultWordLength: 3,
        sourceWordLength: 8,
    }), [0b111, 0b111, 0b111, 0b111, 0b111, 0b100]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b111, 0b111, 0b111, 0b111, 0b111, 0b100],
        resultWordLength: 8,
        sourceWordLength: 3,
    }), 
    /**
     * The 2 padding bit are now considered significant, so we have to add
     * padding to encode them.
     */
    [0b11111111, 0b11111111, 0b00]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11111111, 0b11111111],
        resultWordLength: 4,
        sourceWordLength: 8,
    }), [0b1111, 0b1111, 0b1111, 0b1111]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b1111, 0b1111, 0b1111, 0b1111],
        resultWordLength: 8,
        sourceWordLength: 4,
    }), [0b11111111, 0b11111111]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11111111, 0b11111111],
        resultWordLength: 5,
        sourceWordLength: 8,
    }), [0b11111, 0b11111, 0b11111, 0b10000]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11111, 0b11111, 0b11111, 0b10000],
        resultWordLength: 8,
        sourceWordLength: 5,
    }), [0b11111111, 0b11111111, 0b0000]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11111111, 0b11111111],
        resultWordLength: 6,
        sourceWordLength: 8,
    }), [0b111111, 0b111111, 0b111100]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b111111, 0b111111, 0b111100],
        resultWordLength: 8,
        sourceWordLength: 6,
    }), [0b11111111, 0b11111111, 0b00]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11111111, 0b11111111],
        resultWordLength: 7,
        sourceWordLength: 8,
    }), [0b1111111, 0b1111111, 0b1100000]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b1111111, 0b1111111, 0b1100000],
        resultWordLength: 8,
        sourceWordLength: 7,
    }), [0b11111111, 0b11111111, 0b00000]);
    t.deepEqual(lib_1.regroupBits({
        bin: [0b11111111, 0b11111111],
        resultWordLength: 8,
        sourceWordLength: 8,
    }), [0b11111111, 0b11111111]);
    t.deepEqual(lib_1.regroupBits({
        bin: Uint8Array.from([0b11111111, 0b11111111]),
        resultWordLength: 8,
        sourceWordLength: 8,
    }), [0b11111111, 0b11111111]);
    t.deepEqual(lib_1.regroupBits({ bin: [256], resultWordLength: 5, sourceWordLength: 8 }), lib_1.BitRegroupingError.integerOutOfRange);
    t.deepEqual(lib_1.regroupBits({
        allowPadding: false,
        bin: [0b11111, 0b11111, 0b11111, 0b10001],
        resultWordLength: 8,
        sourceWordLength: 5,
    }), lib_1.BitRegroupingError.requiresDisallowedPadding);
    t.deepEqual(lib_1.regroupBits({
        allowPadding: false,
        /**
         * `tf`
         */
        bin: [11, 9],
        resultWordLength: 8,
        sourceWordLength: 5,
    }), lib_1.BitRegroupingError.requiresDisallowedPadding);
    t.deepEqual(lib_1.regroupBits({
        allowPadding: false,
        bin: [0b00000],
        resultWordLength: 8,
        sourceWordLength: 5,
    }), lib_1.BitRegroupingError.hasDisallowedPadding);
});
ava_1.default('isBech32CharacterSet', (t) => {
    t.deepEqual(lib_1.isBech32CharacterSet(''), true);
    t.deepEqual(lib_1.isBech32CharacterSet('qq'), true);
    // cspell: disable-next-line
    t.deepEqual(lib_1.isBech32CharacterSet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), true);
    t.deepEqual(lib_1.isBech32CharacterSet('1u'), false);
    // cspell: disable-next-line
    t.deepEqual(lib_1.isBech32CharacterSet(':qqqsyqc'), false);
});
ava_1.default('decodeBech32', (t) => {
    t.deepEqual(lib_1.decodeBech32(''), []);
    t.deepEqual(lib_1.decodeBech32('qq'), [0, 0]);
    t.deepEqual(lib_1.decodeBech32('qqq'), [0, 0, 0]);
    t.deepEqual(lib_1.decodeBech32('qqqq'), [0, 0, 0, 0]);
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeBech32('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), 
    // prettier-ignore
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]);
});
ava_1.default('encodeBech32', (t) => {
    t.deepEqual(lib_1.encodeBech32([]), '');
    t.deepEqual(lib_1.encodeBech32([0, 0]), 'qq');
    t.deepEqual(lib_1.encodeBech32([0, 0, 0]), 'qqq');
    t.deepEqual(lib_1.encodeBech32([0, 0, 0, 0]), 'qqqq');
    t.deepEqual(
    // prettier-ignore
    lib_1.encodeBech32([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]), 
    // cspell: disable-next-line
    'qpzry9x8gf2tvdw0s3jn54khce6mua7l');
});
ava_1.default('binToBech32Padded', (t) => {
    t.deepEqual(lib_1.binToBech32Padded(Uint8Array.of(0)), 'qq');
    t.deepEqual(lib_1.binToBech32Padded(Uint8Array.of(255)), 'lu');
    // cspell: disable-next-line
    t.deepEqual(lib_1.binToBech32Padded(Uint8Array.of(0, 1, 2, 3)), 'qqqsyqc');
});
ava_1.default('bech32PaddedToBin', (t) => {
    t.deepEqual(lib_1.bech32PaddedToBin('qqq'), lib_1.BitRegroupingError.hasDisallowedPadding);
    t.deepEqual(lib_1.bech32PaddedToBin('qq'), Uint8Array.of(0));
    t.deepEqual(lib_1.bech32PaddedToBin('tf'), lib_1.BitRegroupingError.requiresDisallowedPadding);
    t.deepEqual(lib_1.bech32PaddedToBin('lu'), Uint8Array.of(255));
    // cspell: disable-next-line
    t.deepEqual(lib_1.bech32PaddedToBin('qqqsyqc'), Uint8Array.of(0, 1, 2, 3));
    t.deepEqual(lib_1.bech32PaddedToBin('qqq1'), lib_1.Bech32DecodingError.notBech32CharacterSet);
});
const max5BitNumber = 31;
const maxUint8Number = 255;
const fcUint8Array = (minLength, maxLength) => fc
    .array(fc.integer(0, maxUint8Number), minLength, maxLength)
    .map((a) => Uint8Array.from(a));
const maxBinLength = 100;
ava_fast_check_1.testProp('[fast-check] encodeBech32 <-> decodeBech32', [fc.array(fc.integer(0, max5BitNumber), 0, maxBinLength)], (t, input) => {
    t.deepEqual(lib_1.decodeBech32(lib_1.encodeBech32(input)), input);
});
ava_fast_check_1.testProp('[fast-check] bech32PaddedToBin <-> binToBech32Padded', [fcUint8Array(0, maxBinLength)], (t, input) => {
    t.deepEqual(lib_1.binToBech32Padded(lib_1.bech32PaddedToBin(lib_1.binToBech32Padded(input))), lib_1.binToBech32Padded(input));
});
ava_fast_check_1.testProp('[fast-check] binToBech32Padded -> isBech32', [fcUint8Array(0, maxBinLength)], (t, input) => t.true(lib_1.isBech32CharacterSet(lib_1.binToBech32Padded(input))));
ava_fast_check_1.testProp('[fast-check] isBech32: matches round trip results', [fcUint8Array(0, maxBinLength)], (t, input) => {
    const maybeBech32 = lib_1.binToUtf8(input);
    const tryBin = lib_1.bech32PaddedToBin(maybeBech32);
    if (typeof tryBin === 'string') {
        // skip
        t.pass();
        return;
    }
    t.deepEqual(lib_1.binToBech32Padded(tryBin), maybeBech32);
});
//# sourceMappingURL=bech32.spec.js.map