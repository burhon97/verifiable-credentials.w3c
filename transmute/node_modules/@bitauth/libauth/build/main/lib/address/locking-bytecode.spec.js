"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable functional/no-expression-statement */
const ava_1 = __importDefault(require("ava"));
const lib_1 = require("../lib");
const sha256Promise = lib_1.instantiateSha256();
ava_1.default('lockingBytecode <-> AddressContents: P2PK', (t) => {
    const genesisCoinbase = lib_1.hexToBin('4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac');
    const genesisPublicKey = lib_1.hexToBin('04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f');
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(genesisCoinbase), {
        payload: genesisPublicKey,
        type: lib_1.AddressType.p2pk,
    });
    t.deepEqual(lib_1.addressContentsToLockingBytecode({
        payload: genesisPublicKey,
        type: lib_1.AddressType.p2pk,
    }), genesisCoinbase);
    const genesisCoinbaseCompressed = lib_1.hexToBin('2103678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6ac');
    const compressedPublicKey = lib_1.hexToBin('03678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6');
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(genesisCoinbaseCompressed), {
        payload: compressedPublicKey,
        type: lib_1.AddressType.p2pk,
    });
    t.deepEqual(lib_1.addressContentsToLockingBytecode({
        payload: compressedPublicKey,
        type: lib_1.AddressType.p2pk,
    }), genesisCoinbaseCompressed);
});
ava_1.default('lockingBytecode <-> AddressContents: P2PKH', (t) => {
    const p2pkh = lib_1.hexToBin('76a91465a16059864a2fdbc7c99a4723a8395bc6f188eb88ac');
    const expectedPayload = lib_1.hexToBin('65a16059864a2fdbc7c99a4723a8395bc6f188eb');
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(p2pkh), {
        payload: expectedPayload,
        type: lib_1.AddressType.p2pkh,
    });
    t.deepEqual(lib_1.addressContentsToLockingBytecode({
        payload: expectedPayload,
        type: lib_1.AddressType.p2pkh,
    }), p2pkh);
});
ava_1.default('lockingBytecode <-> AddressContents: P2SH', (t) => {
    const p2sh = lib_1.hexToBin('a91474f209f6ea907e2ea48f74fae05782ae8a66525787');
    const expectedPayload = lib_1.hexToBin('74f209f6ea907e2ea48f74fae05782ae8a665257');
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(p2sh), {
        payload: expectedPayload,
        type: lib_1.AddressType.p2sh,
    });
    t.deepEqual(lib_1.addressContentsToLockingBytecode({
        payload: expectedPayload,
        type: lib_1.AddressType.p2sh,
    }), p2sh);
});
ava_1.default('lockingBytecode <-> AddressContents: unknown', (t) => {
    const simpleMath = lib_1.hexToBin('52935387');
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(simpleMath), {
        payload: simpleMath,
        type: lib_1.AddressType.unknown,
    });
    t.deepEqual(lib_1.addressContentsToLockingBytecode({
        payload: simpleMath,
        type: lib_1.AddressType.unknown,
    }), simpleMath);
    const almostP2pk = lib_1.hexToBin('0100ac');
    const almostP2pkh = lib_1.hexToBin('76a9010088ac');
    const almostP2sh = lib_1.hexToBin('a9010087');
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(almostP2pk), {
        payload: almostP2pk,
        type: lib_1.AddressType.unknown,
    });
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(almostP2pkh), {
        payload: almostP2pkh,
        type: lib_1.AddressType.unknown,
    });
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(almostP2sh), {
        payload: almostP2sh,
        type: lib_1.AddressType.unknown,
    });
});
ava_1.default('lockingBytecodeToAddressContents: improperly sized scripts return AddressType.unknown', (t) => {
    const almostP2pk = lib_1.hexToBin('0100ac');
    const almostP2pkh = lib_1.hexToBin('76a9010088ac');
    const almostP2sh = lib_1.hexToBin('a9010087');
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(almostP2pk), {
        payload: almostP2pk,
        type: lib_1.AddressType.unknown,
    });
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(almostP2pkh), {
        payload: almostP2pkh,
        type: lib_1.AddressType.unknown,
    });
    t.deepEqual(lib_1.lockingBytecodeToAddressContents(almostP2sh), {
        payload: almostP2sh,
        type: lib_1.AddressType.unknown,
    });
});
const cashVectors = (t, cashAddress, bytecode) => {
    t.deepEqual(lib_1.cashAddressToLockingBytecode(cashAddress), {
        bytecode: lib_1.hexToBin(bytecode),
        prefix: 'bitcoincash',
    });
    t.deepEqual(lib_1.lockingBytecodeToCashAddress(lib_1.hexToBin(bytecode), 'bitcoincash'), cashAddress);
};
// eslint-disable-next-line functional/immutable-data
cashVectors.title = (_, cashAddress) => `cashAddressToLockingBytecode <-> lockingBytecodeToCashAddress: ${cashAddress}`;
ava_1.default(cashVectors, 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a', '76a91476a04053bda0a88bda5177b86a15c3b29f55987388ac');
ava_1.default(cashVectors, 'bitcoincash:qr95sy3j9xwd2ap32xkykttr4cvcu7as4y0qverfuy', '76a914cb481232299cd5743151ac4b2d63ae198e7bb0a988ac');
ava_1.default(cashVectors, 'bitcoincash:qqq3728yw0y47sqn6l2na30mcw6zm78dzqre909m2r', '76a914011f28e473c95f4013d7d53ec5fbc3b42df8ed1088ac');
ava_1.default(cashVectors, 'bitcoincash:ppm2qsznhks23z7629mms6s4cwef74vcwvn0h829pq', 'a91476a04053bda0a88bda5177b86a15c3b29f55987387');
ava_1.default(cashVectors, 'bitcoincash:pr95sy3j9xwd2ap32xkykttr4cvcu7as4yc93ky28e', 'a914cb481232299cd5743151ac4b2d63ae198e7bb0a987');
ava_1.default(cashVectors, 'bitcoincash:pqq3728yw0y47sqn6l2na30mcw6zm78dzq5ucqzc37', 'a914011f28e473c95f4013d7d53ec5fbc3b42df8ed1087');
ava_1.default('lockingBytecodeToCashAddress: P2PK', (t) => {
    const genesisCoinbase = lib_1.hexToBin('4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac');
    const genesisPublicKey = lib_1.hexToBin('04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f');
    t.deepEqual(lib_1.lockingBytecodeToCashAddress(genesisCoinbase, lib_1.CashAddressNetworkPrefix.mainnet), {
        payload: genesisPublicKey,
        type: lib_1.AddressType.p2pk,
    });
    const genesisCoinbaseCompressed = lib_1.hexToBin('2103678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6ac');
    const compressedPublicKey = lib_1.hexToBin('03678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6');
    t.deepEqual(lib_1.lockingBytecodeToCashAddress(genesisCoinbaseCompressed, lib_1.CashAddressNetworkPrefix.mainnet), {
        payload: compressedPublicKey,
        type: lib_1.AddressType.p2pk,
    });
});
ava_1.default('cashAddressToLockingBytecode <-> lockingBytecodeToCashAddress: P2SH', (t) => {
    const p2sh = lib_1.hexToBin('a91474f209f6ea907e2ea48f74fae05782ae8a66525787');
    const address = 'bitcoincash:pp60yz0ka2g8ut4y3a604czhs2hg5ejj2ugn82jfsr';
    t.deepEqual(lib_1.lockingBytecodeToCashAddress(p2sh, 'bitcoincash'), address);
    t.deepEqual(lib_1.cashAddressToLockingBytecode(address), {
        bytecode: p2sh,
        prefix: 'bitcoincash',
    });
});
ava_1.default('lockingBytecodeToCashAddress: error', (t) => {
    const simpleMath = lib_1.hexToBin('52935387');
    t.deepEqual(lib_1.lockingBytecodeToCashAddress(simpleMath, 'bitcoincash'), {
        payload: simpleMath,
        type: lib_1.AddressType.unknown,
    });
    const genesisCoinbase = lib_1.hexToBin('4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac');
    t.deepEqual(lib_1.lockingBytecodeToCashAddress(genesisCoinbase, 'bitcoincash'), {
        payload: lib_1.hexToBin('04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f'),
        type: lib_1.AddressType.p2pk,
    });
});
ava_1.default('cashAddressToLockingBytecode: error', (t) => {
    t.deepEqual(lib_1.cashAddressToLockingBytecode('bad:address'), lib_1.CashAddressDecodingError.invalidChecksum);
    t.deepEqual(lib_1.cashAddressToLockingBytecode('bitcoincash:dp60yz0ka2g8ut4y3a604czhs2hg5ejj2u6xkulaqj'), lib_1.LockingBytecodeEncodingError.unknownCashAddressType);
});
ava_1.default('lockingBytecodeToBase58Address: P2PK', async (t) => {
    const sha256 = await sha256Promise;
    const genesisCoinbase = lib_1.hexToBin('4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac');
    const genesisPublicKey = lib_1.hexToBin('04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f');
    t.deepEqual(lib_1.lockingBytecodeToBase58Address(sha256, genesisCoinbase, 'mainnet'), {
        payload: genesisPublicKey,
        type: lib_1.AddressType.p2pk,
    });
    const genesisCoinbaseCompressed = lib_1.hexToBin('2103678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6ac');
    const compressedPublicKey = lib_1.hexToBin('03678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6');
    t.deepEqual(lib_1.lockingBytecodeToBase58Address(sha256, genesisCoinbaseCompressed, 'testnet'), {
        payload: compressedPublicKey,
        type: lib_1.AddressType.p2pk,
    });
});
ava_1.default('base58AddressToLockingBytecode <-> lockingBytecodeToBase58Address: P2PKH', async (t) => {
    const sha256 = await sha256Promise;
    const p2pkh = lib_1.hexToBin('76a91476a04053bda0a88bda5177b86a15c3b29f55987388ac');
    // cspell: disable-next-line
    const address = '1BpEi6DfDAUFd7GtittLSdBeYJvcoaVggu';
    // cspell: disable-next-line
    const addressTestnet = 'mrLC19Je2BuWQDkWSTriGYPyQJXKkkBmCx';
    // cspell: disable-next-line
    const addressCopay = 'CTH8H8Zj6DSnXFBKQeDG28ogAS92iS16Bp';
    t.deepEqual(lib_1.lockingBytecodeToBase58Address(sha256, p2pkh, 'mainnet'), address);
    t.deepEqual(lib_1.lockingBytecodeToBase58Address(sha256, p2pkh, 'testnet'), addressTestnet);
    t.deepEqual(lib_1.lockingBytecodeToBase58Address(sha256, p2pkh, 'copay-bch'), addressCopay);
    t.deepEqual(lib_1.base58AddressToLockingBytecode(sha256, address), {
        bytecode: p2pkh,
        version: lib_1.Base58AddressFormatVersion.p2pkh,
    });
    t.deepEqual(lib_1.base58AddressToLockingBytecode(sha256, addressTestnet), {
        bytecode: p2pkh,
        version: lib_1.Base58AddressFormatVersion.p2pkhTestnet,
    });
    t.deepEqual(lib_1.base58AddressToLockingBytecode(sha256, addressCopay), {
        bytecode: p2pkh,
        version: lib_1.Base58AddressFormatVersion.p2pkhCopayBCH,
    });
});
ava_1.default('base58AddressToLockingBytecode <-> lockingBytecodeToBase58Address: P2SH', async (t) => {
    const sha256 = await sha256Promise;
    const p2sh = lib_1.hexToBin('a91476a04053bda0a88bda5177b86a15c3b29f55987387');
    // cspell: disable-next-line
    const address = '3CWFddi6m4ndiGyKqzYvsFYagqDLPVMTzC';
    // cspell: disable-next-line
    const addressTestnet = '2N44ThNe8NXHyv4bsX8AoVCXquBRW94Ls7W';
    // cspell: disable-next-line
    const addressCopay = 'HHLN6S9BcP1JLSrMhgD5qe57iVEMFMLCBT';
    t.deepEqual(lib_1.lockingBytecodeToBase58Address(sha256, p2sh, 'mainnet'), address);
    t.deepEqual(lib_1.lockingBytecodeToBase58Address(sha256, p2sh, 'testnet'), addressTestnet);
    t.deepEqual(lib_1.lockingBytecodeToBase58Address(sha256, p2sh, 'copay-bch'), addressCopay);
    t.deepEqual(lib_1.base58AddressToLockingBytecode(sha256, address), {
        bytecode: p2sh,
        version: lib_1.Base58AddressFormatVersion.p2sh,
    });
    t.deepEqual(lib_1.base58AddressToLockingBytecode(sha256, addressTestnet), {
        bytecode: p2sh,
        version: lib_1.Base58AddressFormatVersion.p2shTestnet,
    });
    t.deepEqual(lib_1.base58AddressToLockingBytecode(sha256, addressCopay), {
        bytecode: p2sh,
        version: lib_1.Base58AddressFormatVersion.p2shCopayBCH,
    });
});
ava_1.default('base58AddressToLockingBytecode: error', async (t) => {
    const sha256 = await sha256Promise;
    t.deepEqual(lib_1.base58AddressToLockingBytecode(sha256, 'bad:address'), lib_1.Base58AddressError.unknownCharacter);
});
//# sourceMappingURL=locking-bytecode.spec.js.map