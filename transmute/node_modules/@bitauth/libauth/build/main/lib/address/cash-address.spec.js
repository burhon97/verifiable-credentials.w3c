"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-magic-numbers, functional/no-expression-statement */
const ava_1 = __importDefault(require("ava"));
const fc = __importStar(require("fast-check"));
const lib_1 = require("../lib");
const cashAddrJson = __importStar(require("./fixtures/cashaddr.json"));
const maxUint8Number = 255;
const fcUint8Array = (length) => fc
    .array(fc.integer(0, maxUint8Number), length, length)
    .map((a) => Uint8Array.from(a));
const lowercaseLetter = () => fc.integer(97, 122).map((i) => String.fromCharCode(i));
const cashAddressTestVectors = Object.values(cashAddrJson).filter((item) => !Array.isArray(item));
ava_1.default('maskCashAddressPrefix', (t) => {
    // prettier-ignore
    const payloadPrefix = [2, 9, 20, 3, 15, 9, 14, 3, 1, 19, 8];
    t.deepEqual(lib_1.maskCashAddressPrefix('bitcoincash'), payloadPrefix);
});
ava_1.default('encodeCashAddressVersionByte', (t) => {
    t.deepEqual(lib_1.encodeCashAddressVersionByte(0, 160), lib_1.CashAddressVersionByte.P2PKH);
    t.deepEqual(lib_1.encodeCashAddressVersionByte(1, 160), lib_1.CashAddressVersionByte.P2SH);
});
ava_1.default('decodeCashAddressVersionByte', (t) => {
    t.deepEqual(lib_1.decodeCashAddressVersionByte(lib_1.CashAddressVersionByte.P2PKH), {
        bitLength: 160,
        type: 0,
    });
    t.deepEqual(lib_1.decodeCashAddressVersionByte(lib_1.CashAddressVersionByte.P2SH), {
        bitLength: 160,
        type: 1,
    });
    t.deepEqual(lib_1.decodeCashAddressVersionByte(0b10000000), lib_1.CashAddressVersionByteDecodingError.reservedBitSet);
    t.deepEqual(lib_1.decodeCashAddressVersionByte(0b01000011), {
        bitLength: 256,
        type: 8,
    });
    t.deepEqual(lib_1.decodeCashAddressVersionByte(0b01111111), {
        bitLength: 512,
        type: 15,
    });
});
ava_1.default('encodeCashAddress: works', (t) => {
    const hash = lib_1.hexToBin('15d16c84669ab46059313bf0747e781f1d13936d');
    t.deepEqual(lib_1.encodeCashAddress(lib_1.CashAddressNetworkPrefix.testnet, lib_1.CashAddressVersionByte.P2PKH, hash), 'bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x');
    t.deepEqual(lib_1.encodeCashAddress('bchtest', 0, hash), 'bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x');
    t.deepEqual(lib_1.encodeCashAddress(lib_1.CashAddressNetworkPrefix.mainnet, lib_1.CashAddressVersionByte.P2PKH, hash), 'bitcoincash:qq2azmyyv6dtgczexyalqar70q036yund54qgw0wg6');
    t.deepEqual(lib_1.encodeCashAddress('bitcoincash', 0, hash), 'bitcoincash:qq2azmyyv6dtgczexyalqar70q036yund54qgw0wg6');
    t.deepEqual(lib_1.encodeCashAddress(lib_1.CashAddressNetworkPrefix.regtest, lib_1.CashAddressVersionByte.P2PKH, hash), 'bchreg:qq2azmyyv6dtgczexyalqar70q036yund5tw6gw2vq');
    t.deepEqual(lib_1.encodeCashAddress('bchreg', 0, hash), 'bchreg:qq2azmyyv6dtgczexyalqar70q036yund5tw6gw2vq');
    t.deepEqual(lib_1.encodeCashAddressFormat('bitauth', lib_1.encodeCashAddressVersionByte(0, 256), lib_1.hexToBin('978306aa4e02fd06e251b38d2e961f78f4af2ea6524a3e4531126776276a6af1')), 'bitauth:qwtcxp42fcp06phz2xec6t5krau0ftew5efy50j9xyfxwa38df40zp58z6t5w');
    t.deepEqual(lib_1.encodeCashAddress('broken', 0, lib_1.hexToBin('97')), lib_1.CashAddressEncodingError.unsupportedHashLength);
});
ava_1.default('decodeCashAddress: works', (t) => {
    const hash = lib_1.hexToBin('15d16c84669ab46059313bf0747e781f1d13936d');
    const result = lib_1.decodeCashAddress('bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x');
    // eslint-disable-next-line functional/no-conditional-statement
    if (typeof result === 'string') {
        t.log(result);
        t.fail();
    }
    t.deepEqual(result, { hash, prefix: 'bchtest', type: 0 });
    t.deepEqual(lib_1.decodeCashAddress('bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x'), {
        hash,
        prefix: lib_1.CashAddressNetworkPrefix.testnet,
        type: lib_1.CashAddressType.P2PKH,
    });
    t.deepEqual(lib_1.decodeCashAddress('bitcoincash:qq2azmyyv6dtgczexyalqar70q036yund54qgw0wg6'), {
        hash,
        prefix: lib_1.CashAddressNetworkPrefix.mainnet,
        type: lib_1.CashAddressType.P2PKH,
    });
    t.deepEqual(lib_1.decodeCashAddress('bitcoincash:qq2azmyyv6dtgczexyalqar70q036yund54qgw0wg6'), { hash, prefix: 'bitcoincash', type: 0 });
    t.deepEqual(lib_1.decodeCashAddress('bchreg:qq2azmyyv6dtgczexyalqar70q036yund5tw6gw2vq'), {
        hash,
        prefix: lib_1.CashAddressNetworkPrefix.regtest,
        type: lib_1.CashAddressType.P2PKH,
    });
    t.deepEqual(lib_1.decodeCashAddress('bchreg:qq2azmyyv6dtgczexyalqar70q036yund5tw6gw2vq'), { hash, prefix: 'bchreg', type: 0 });
    t.deepEqual(lib_1.decodeCashAddressFormat('bitauth:qwtcxp42fcp06phz2xec6t5krau0ftew5efy50j9xyfxwa38df40zp58z6t5w'), {
        hash: lib_1.hexToBin('978306aa4e02fd06e251b38d2e961f78f4af2ea6524a3e4531126776276a6af1'),
        prefix: 'bitauth',
        version: lib_1.encodeCashAddressVersionByte(0, 256),
    });
    t.deepEqual(lib_1.decodeCashAddressFormat(':qwtcxp42fcp06phz2xec6t5krau0ftew5efy50j9xyfxwa38df40zp58z6t5w'), lib_1.CashAddressDecodingError.invalidFormat);
    t.deepEqual(lib_1.decodeCashAddress('prefix:broken'), lib_1.CashAddressDecodingError.invalidCharacters);
    t.deepEqual(lib_1.decodeCashAddressFormat('prefix:broken'), lib_1.CashAddressDecodingError.invalidCharacters);
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeCashAddressFormat('verybroken:lll30n6j98m5'), lib_1.CashAddressDecodingError.improperPadding);
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeCashAddressFormat('bchtest:testnetaddress4d6njnut'), lib_1.CashAddressDecodingError.improperPadding);
    t.deepEqual(lib_1.decodeCashAddress('bchreg:555555555555555555555555555555555555555555555udxmlmrz'), lib_1.CashAddressDecodingError.reservedByte);
    t.deepEqual(lib_1.decodeCashAddress('bitcoincash:qu2azmyyv6dtgczexyalqar70q036yund53an46hf6'), lib_1.CashAddressDecodingError.mismatchedHashLength);
});
ava_1.default('CashAddress test vectors', (t) => {
    cashAddressTestVectors.forEach((vector) => {
        const { cashaddr } = vector;
        const [prefix] = cashaddr.split(':');
        const payload = lib_1.hexToBin(vector.payload);
        const type = vector.type;
        const encodeResult = lib_1.encodeCashAddress(prefix, type, payload);
        // eslint-disable-next-line functional/no-conditional-statement
        if (cashaddr !== encodeResult) {
            t.log('expected vector', vector.cashaddr);
            t.log('type', type);
            t.log('prefix', prefix);
            t.log('payload', payload);
            t.log('encodeResult', encodeResult);
        }
        t.deepEqual(vector.cashaddr, encodeResult);
        const decodeResult = lib_1.decodeCashAddress(cashaddr);
        // eslint-disable-next-line functional/no-conditional-statement
        if (typeof decodeResult === 'string') {
            t.log(decodeResult);
            t.fail();
        }
        t.deepEqual(decodeResult, { hash: payload, prefix, type });
    });
});
ava_1.default('decodeCashAddressWithoutPrefix', (t) => {
    const hash = lib_1.hexToBin('15d16c84669ab46059313bf0747e781f1d13936d');
    t.deepEqual(lib_1.decodeCashAddressFormatWithoutPrefix('qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x'), { hash, prefix: 'bchtest', version: 0 });
    t.deepEqual(lib_1.decodeCashAddressFormatWithoutPrefix('qq2azmyyv6dtgczexyalqar70q036yund54qgw0wg6'), { hash, prefix: 'bitcoincash', version: 0 });
    t.deepEqual(lib_1.decodeCashAddressFormatWithoutPrefix('qq2azmyyv6dtgczexyalqar70q036yund5tw6gw2vq'), { hash, prefix: 'bchreg', version: 0 });
    t.deepEqual(lib_1.decodeCashAddressFormatWithoutPrefix('qwtcxp42fcp06phz2xec6t5krau0ftew5efy50j9xyfxwa38df40zp58z6t5w', ['bitauth']), {
        hash: lib_1.hexToBin('978306aa4e02fd06e251b38d2e961f78f4af2ea6524a3e4531126776276a6af1'),
        prefix: 'bitauth',
        version: lib_1.encodeCashAddressVersionByte(0, 256),
    });
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeCashAddressFormatWithoutPrefix('qwtcxp42fcp06phz', ['bitauth']), lib_1.CashAddressDecodingError.invalidChecksum);
});
ava_1.default('[fast-check] encodeCashAddress <-> decodeCashAddress', (t) => {
    const roundTripWithHashLength = (hashLength) => fc.property(fc.array(lowercaseLetter(), 1, 50).map((arr) => arr.join('')), fc.nat(15), fcUint8Array(hashLength / 8), (prefix, type, hash) => {
        // t.log(decodeCashAddressVersionByte(version));
        t.deepEqual(lib_1.decodeCashAddress(lib_1.encodeCashAddress(prefix, type, hash)), { hash, prefix, type });
    });
    t.notThrows(() => {
        fc.assert(roundTripWithHashLength(160));
        fc.assert(roundTripWithHashLength(192));
        fc.assert(roundTripWithHashLength(224));
        fc.assert(roundTripWithHashLength(256));
        fc.assert(roundTripWithHashLength(320));
        fc.assert(roundTripWithHashLength(384));
        fc.assert(roundTripWithHashLength(448));
        fc.assert(roundTripWithHashLength(512));
    });
});
ava_1.default('attemptCashAddressErrorCorrection', (t) => {
    t.deepEqual(lib_1.attemptCashAddressFormatErrorCorrection(
    // cspell: disable-next-line
    ':qq2azmyyv6dtgczexyalqar70q036yund53jvfde0c'), lib_1.CashAddressDecodingError.invalidFormat);
    t.deepEqual(lib_1.attemptCashAddressFormatErrorCorrection(
    // cspell: disable-next-line
    'broken:broken'), lib_1.CashAddressDecodingError.invalidCharacters);
    t.deepEqual(lib_1.attemptCashAddressFormatErrorCorrection(
    // cspell: disable-next-line
    'achtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0c'), {
        address: 'bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x',
        corrections: [0, 49],
    });
    t.deepEqual(lib_1.attemptCashAddressFormatErrorCorrection(
    // cspell: disable-next-line
    'btcbest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x'), lib_1.CashAddressCorrectionError.tooManyErrors);
});
ava_1.default('[fast-check] attemptCashAddressErrorCorrection', (t) => {
    const correctsUpToTwoErrors = (hashLength) => fc.property(fc.array(lowercaseLetter(), 1, 50).map((arr) => arr.join('')), fc.nat(15), fcUint8Array(hashLength / 8), fc.array(fc.nat(hashLength / 8), 0, 2), 
    // eslint-disable-next-line max-params
    (prefix, type, hash, randomErrors) => {
        const address = lib_1.encodeCashAddress(prefix, type, hash);
        const addressChars = lib_1.splitEvery(address, 1);
        const errors = [
            ...new Set(randomErrors
                .filter((i) => i !== prefix.length)
                .sort((a, b) => a - b)),
        ];
        const broken = addressChars
            .map((char, i) => errors.includes(i) ? (char === 'q' ? 'p' : 'q') : char)
            .join('');
        t.deepEqual(lib_1.attemptCashAddressFormatErrorCorrection(broken), {
            address,
            corrections: errors,
        });
    });
    t.notThrows(() => {
        fc.assert(correctsUpToTwoErrors(160));
        fc.assert(correctsUpToTwoErrors(192));
        fc.assert(correctsUpToTwoErrors(224));
        fc.assert(correctsUpToTwoErrors(256));
        fc.assert(correctsUpToTwoErrors(320));
        fc.assert(correctsUpToTwoErrors(384));
        fc.assert(correctsUpToTwoErrors(448));
        fc.assert(correctsUpToTwoErrors(512));
    });
});
const sha256Promise = lib_1.instantiateSha256();
const legacyVectors = async (t, base58Address, cashAddress) => {
    const sha256 = await sha256Promise;
    const decodedBase58Address = lib_1.decodeBase58AddressFormat(sha256, base58Address);
    const decodedCashAddress = lib_1.decodeCashAddress(cashAddress);
    if (typeof decodedCashAddress === 'string' ||
        typeof decodedBase58Address === 'string') {
        t.fail();
        return undefined;
    }
    t.deepEqual(decodedBase58Address.payload, decodedCashAddress.hash);
    return undefined;
};
// eslint-disable-next-line functional/immutable-data
legacyVectors.title = (_, base58Address) => `CashAddress <-> Legacy Base58 Vectors: ${base58Address}`;
ava_1.default(legacyVectors, 
// cspell: disable-next-line
'1BpEi6DfDAUFd7GtittLSdBeYJvcoaVggu', 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a');
ava_1.default(legacyVectors, 
// cspell: disable-next-line
'1KXrWXciRDZUpQwQmuM1DbwsKDLYAYsVLR', 'bitcoincash:qr95sy3j9xwd2ap32xkykttr4cvcu7as4y0qverfuy');
ava_1.default(legacyVectors, 
// cspell: disable-next-line
'16w1D5WRVKJuZUsSRzdLp9w3YGcgoxDXb', 'bitcoincash:qqq3728yw0y47sqn6l2na30mcw6zm78dzqre909m2r');
ava_1.default(legacyVectors, 
// cspell: disable-next-line
'3CWFddi6m4ndiGyKqzYvsFYagqDLPVMTzC', 'bitcoincash:ppm2qsznhks23z7629mms6s4cwef74vcwvn0h829pq');
ava_1.default(legacyVectors, 
// cspell: disable-next-line
'3LDsS579y7sruadqu11beEJoTjdFiFCdX4', 'bitcoincash:pr95sy3j9xwd2ap32xkykttr4cvcu7as4yc93ky28e');
ava_1.default(legacyVectors, 
// cspell: disable-next-line
'31nwvkZwyPdgzjBJZXfDmSWsC4ZLKpYyUw', 'bitcoincash:pqq3728yw0y47sqn6l2na30mcw6zm78dzq5ucqzc37');
//# sourceMappingURL=cash-address.spec.js.map