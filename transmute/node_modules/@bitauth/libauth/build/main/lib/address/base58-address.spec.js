"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable functional/no-expression-statement */
const ava_1 = __importDefault(require("ava"));
const ava_fast_check_1 = require("ava-fast-check");
const lib_1 = require("../lib");
const keyIoInvalid = __importStar(require("./fixtures/key_io_invalid.json"));
const keyIoValid = __importStar(require("./fixtures/key_io_valid.json"));
const sha256Promise = lib_1.instantiateSha256();
const invalidVectors = Object.values(keyIoInvalid).filter((item) => Array.isArray(item) && item.every((x) => typeof x === 'string'));
const validVectors = Object.values(keyIoValid).filter((item) => item.every((x) => !Array.isArray(x)));
ava_1.default('encodeBase58AddressFormat', async (t) => {
    const sha256 = await sha256Promise;
    const payload = lib_1.hexToBin('65a16059864a2fdbc7c99a4723a8395bc6f188eb');
    t.deepEqual(lib_1.encodeBase58AddressFormat(sha256, lib_1.Base58AddressFormatVersion.p2pkh, payload), 
    // cspell: disable-next-line
    '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i');
});
ava_1.default('encodeBase58Address', async (t) => {
    const sha256 = await sha256Promise;
    const payload = lib_1.hexToBin('76a04053bda0a88bda5177b86a15c3b29f559873');
    t.deepEqual(lib_1.encodeBase58Address(sha256, 'p2pkh', payload), 
    // cspell: disable-next-line
    '1BpEi6DfDAUFd7GtittLSdBeYJvcoaVggu');
    t.deepEqual(lib_1.encodeBase58Address(sha256, 'p2pkh-testnet', payload), 
    // cspell: disable-next-line
    'mrLC19Je2BuWQDkWSTriGYPyQJXKkkBmCx');
    t.deepEqual(lib_1.encodeBase58Address(sha256, 'p2pkh-copay-bch', payload), 
    // cspell: disable-next-line
    'CTH8H8Zj6DSnXFBKQeDG28ogAS92iS16Bp');
    t.deepEqual(lib_1.encodeBase58Address(sha256, 'p2sh', payload), 
    // cspell: disable-next-line
    '3CWFddi6m4ndiGyKqzYvsFYagqDLPVMTzC');
    t.deepEqual(lib_1.encodeBase58Address(sha256, 'p2sh-testnet', payload), 
    // cspell: disable-next-line
    '2N44ThNe8NXHyv4bsX8AoVCXquBRW94Ls7W');
    t.deepEqual(lib_1.encodeBase58Address(sha256, 'p2sh-copay-bch', payload), 
    // cspell: disable-next-line
    'HHLN6S9BcP1JLSrMhgD5qe57iVEMFMLCBT');
});
ava_1.default('decodeBase58AddressFormat', async (t) => {
    const sha256 = await sha256Promise;
    const payload = lib_1.hexToBin('65a16059864a2fdbc7c99a4723a8395bc6f188eb');
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeBase58AddressFormat(sha256, '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i'), {
        payload,
        version: lib_1.Base58AddressFormatVersion.p2pkh,
    });
});
ava_1.default('decodeBase58Address', async (t) => {
    const sha256 = await sha256Promise;
    const payload = lib_1.hexToBin('65a16059864a2fdbc7c99a4723a8395bc6f188eb');
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeBase58Address(sha256, '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i'), {
        payload,
        version: lib_1.Base58AddressFormatVersion.p2pkh,
    });
});
const maxUint8Number = 255;
const fcUint8Array = (minLength, maxLength) => ava_fast_check_1.fc
    .array(ava_fast_check_1.fc.integer(0, maxUint8Number), minLength, maxLength)
    .map((a) => Uint8Array.from(a));
const maxBinLength = 100;
ava_fast_check_1.testProp('[fast-check] encodeBase58Address <-> decodeBase58Address', [ava_fast_check_1.fc.integer(0, maxUint8Number), fcUint8Array(0, maxBinLength)], async (t, version, payload) => {
    const sha256 = await sha256Promise;
    const address = lib_1.encodeBase58AddressFormat(sha256, version, payload);
    const decoded = lib_1.decodeBase58AddressFormat(sha256, address);
    if (typeof decoded === 'string') {
        t.fail(decoded);
        return;
    }
    t.deepEqual(decoded, {
        payload,
        version,
    });
});
ava_1.default('decodeBase58AddressFormat: errors', async (t) => {
    const sha256 = await sha256Promise;
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeBase58AddressFormat(sha256, '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62a'), lib_1.Base58AddressError.invalidChecksum);
    t.deepEqual(lib_1.decodeBase58AddressFormat(sha256, '1234'), lib_1.Base58AddressError.tooShort);
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeBase58AddressFormat(sha256, '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62I'), lib_1.Base58AddressError.unknownCharacter);
});
ava_1.default('decodeBase58Address: errors', async (t) => {
    const sha256 = await sha256Promise;
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeBase58Address(sha256, '6PfDNQxJdsBx7K4r9kMrRBZSa2NZKVNUZn'), lib_1.Base58AddressError.unknownAddressVersion);
    t.deepEqual(
    // cspell: disable-next-line
    lib_1.decodeBase58Address(sha256, '2DqXtydYdu9pq6uXcy3Tbw3pUscCiPC6F'), 
    // Base58AddressError.incorrectLength
    lib_1.Base58AddressError.unknownAddressVersion);
});
ava_1.default('Base58Address Invalid Vectors', async (t) => {
    const sha256 = await sha256Promise;
    invalidVectors.forEach(([invalid]) => {
        const result = lib_1.decodeBase58Address(sha256, invalid);
        const hasError = typeof result === 'string';
        if (!hasError) {
            /*
             * cspell: disable-next-line
             * HPhFUhUAh8ZQQisH8QQWafAxtQYju3SFTX
             */
            t.deepEqual(result, {
                payload: lib_1.hexToBin('bc6437e3089918c9cb7e3d3ddd7ca83969b1e0bc'),
                version: lib_1.Base58AddressFormatVersion.p2shCopayBCH,
            });
            return;
        }
        t.true(hasError);
    });
});
ava_1.default('Base58Address Valid Vectors (from C++ implementation â€“ includes WIF vectors)', async (t) => {
    const sha256 = await sha256Promise;
    // eslint-disable-next-line complexity
    validVectors.forEach((vectors) => {
        const [base58Address, data, meta] = vectors;
        const testnet = meta.chain !== 'main';
        // eslint-disable-next-line functional/no-conditional-statement
        if (meta.isPrivkey) {
            const wifKey = base58Address;
            const compressed = Boolean(meta.isCompressed);
            const privateKey = lib_1.hexToBin(data);
            const type = testnet
                ? compressed
                    ? 'testnet'
                    : 'testnet-uncompressed'
                : compressed
                    ? 'mainnet'
                    : 'mainnet-uncompressed';
            t.deepEqual(lib_1.decodePrivateKeyWif(sha256, wifKey), { privateKey, type });
            // eslint-disable-next-line functional/no-conditional-statement
        }
        else {
            const lockingBytecode = data;
            t.deepEqual(lib_1.lockingBytecodeToBase58Address(sha256, lib_1.hexToBin(lockingBytecode), testnet ? 'testnet' : 'mainnet'), base58Address);
        }
        // t.deepEqual(typeof decodeBase58Address(sha256, invalid), 'string');
    });
});
//# sourceMappingURL=base58-address.spec.js.map