"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base58AddressToLockingBytecode = exports.lockingBytecodeToBase58Address = exports.cashAddressToLockingBytecode = exports.LockingBytecodeEncodingError = exports.lockingBytecodeToCashAddress = exports.addressContentsToLockingBytecode = exports.lockingBytecodeToAddressContents = exports.AddressType = void 0;
const opcodes_1 = require("../vm/instruction-sets/common/opcodes");
const base58_address_1 = require("./base58-address");
const cash_address_1 = require("./cash-address");
/**
 * The most common address types used on bitcoin and bitcoin-like networks. Each
 * address type represents a commonly used locking bytecode pattern.
 *
 * @remarks
 * Addresses are strings which encode information about the network and
 * `lockingBytecode` to which a transaction output can pay.
 *
 * Several address formats exist â€“ `Base58Address` was the format used by the
 * original satoshi client, and is still in use on several active chains (see
 * `encodeBase58Address`). On Bitcoin Cash, the `CashAddress` standard is most
 * common (See `encodeCashAddress`).
 */
var AddressType;
(function (AddressType) {
    /**
     * Pay to Public Key (P2PK). This address type is uncommon, and primarily
     * occurs in early blocks because the original satoshi implementation mined
     * rewards to P2PK addresses.
     *
     * There are no standardized address formats for representing a P2PK address.
     * Instead, most applications use the `AddressType.p2pkh` format.
     */
    AddressType["p2pk"] = "P2PK";
    /**
     * Pay to Public Key Hash (P2PKH). The most common address type. P2PKH
     * addresses lock funds using a single private key.
     */
    AddressType["p2pkh"] = "P2PKH";
    /**
     * Pay to Script Hash (P2SH). An address type which locks funds to the hash of
     * a script provided in the spending transaction. See BIP13 for details.
     */
    AddressType["p2sh"] = "P2SH";
    /**
     * This `AddressType` represents an address using an unknown or uncommon
     * locking bytecode pattern for which no standardized address formats exist.
     */
    AddressType["unknown"] = "unknown";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
/**
 * Attempt to match a lockingBytecode to a standard address type for use in
 * address encoding. (See `AddressType` for details.)
 *
 * For a locking bytecode matching the Pay to Public Key Hash (P2PKH) pattern,
 * the returned `type` is `AddressType.p2pkh` and `payload` is the `HASH160` of
 * the public key.
 *
 * For a locking bytecode matching the Pay to Script Hash (P2SH) pattern, the
 * returned `type` is `AddressType.p2sh` and `payload` is the `HASH160` of the
 * redeeming bytecode, A.K.A. "redeem script hash".
 *
 * For a locking bytecode matching the Pay to Public Key (P2PK) pattern, the
 * returned `type` is `AddressType.p2pk` and `payload` is the full public key.
 *
 * Any other locking bytecode will return a `type` of `AddressType.unknown` and
 * a payload of the unmodified `bytecode`.
 *
 * @param bytecode - the locking bytecode to match
 */
// eslint-disable-next-line complexity
exports.lockingBytecodeToAddressContents = (bytecode) => {
    const p2pkhLength = 25;
    if (bytecode.length === p2pkhLength &&
        bytecode[0] === opcodes_1.OpcodesCommon.OP_DUP &&
        bytecode[1] === opcodes_1.OpcodesCommon.OP_HASH160 &&
        bytecode[2] === opcodes_1.OpcodesCommon.OP_PUSHBYTES_20 &&
        bytecode[23] === opcodes_1.OpcodesCommon.OP_EQUALVERIFY &&
        bytecode[24] === opcodes_1.OpcodesCommon.OP_CHECKSIG) {
        const start = 3;
        const end = 23;
        return { payload: bytecode.slice(start, end), type: AddressType.p2pkh };
    }
    const p2shLength = 23;
    if (bytecode.length === p2shLength &&
        bytecode[0] === opcodes_1.OpcodesCommon.OP_HASH160 &&
        bytecode[1] === opcodes_1.OpcodesCommon.OP_PUSHBYTES_20 &&
        bytecode[22] === opcodes_1.OpcodesCommon.OP_EQUAL) {
        const start = 2;
        const end = 22;
        return { payload: bytecode.slice(start, end), type: AddressType.p2sh };
    }
    const p2pkUncompressedLength = 67;
    if (bytecode.length === p2pkUncompressedLength &&
        bytecode[0] === opcodes_1.OpcodesCommon.OP_PUSHBYTES_65 &&
        bytecode[66] === opcodes_1.OpcodesCommon.OP_CHECKSIG) {
        const start = 1;
        const end = 66;
        return { payload: bytecode.slice(start, end), type: AddressType.p2pk };
    }
    const p2pkCompressedLength = 35;
    if (bytecode.length === p2pkCompressedLength &&
        bytecode[0] === opcodes_1.OpcodesCommon.OP_PUSHBYTES_33 &&
        bytecode[34] === opcodes_1.OpcodesCommon.OP_CHECKSIG) {
        const start = 1;
        const end = 34;
        return { payload: bytecode.slice(start, end), type: AddressType.p2pk };
    }
    return {
        payload: bytecode.slice(),
        type: AddressType.unknown,
    };
};
/**
 * Get the locking bytecode for a valid `AddressContents` object. See
 * `lockingBytecodeToAddressContents` for details.
 *
 * For `AddressContents` of `type` `AddressType.unknown`, this method returns
 * the `payload` without modification.
 *
 * @param addressContents - the `AddressContents` to encode
 */
exports.addressContentsToLockingBytecode = (addressContents) => {
    if (addressContents.type === AddressType.p2pkh) {
        return Uint8Array.from([
            opcodes_1.OpcodesCommon.OP_DUP,
            opcodes_1.OpcodesCommon.OP_HASH160,
            opcodes_1.OpcodesCommon.OP_PUSHBYTES_20,
            ...addressContents.payload,
            opcodes_1.OpcodesCommon.OP_EQUALVERIFY,
            opcodes_1.OpcodesCommon.OP_CHECKSIG,
        ]);
    }
    if (addressContents.type === AddressType.p2sh) {
        return Uint8Array.from([
            opcodes_1.OpcodesCommon.OP_HASH160,
            opcodes_1.OpcodesCommon.OP_PUSHBYTES_20,
            ...addressContents.payload,
            opcodes_1.OpcodesCommon.OP_EQUAL,
        ]);
    }
    if (addressContents.type === AddressType.p2pk) {
        const compressedPublicKeyLength = 33;
        return addressContents.payload.length === compressedPublicKeyLength
            ? Uint8Array.from([
                opcodes_1.OpcodesCommon.OP_PUSHBYTES_33,
                ...addressContents.payload,
                opcodes_1.OpcodesCommon.OP_CHECKSIG,
            ])
            : Uint8Array.from([
                opcodes_1.OpcodesCommon.OP_PUSHBYTES_65,
                ...addressContents.payload,
                opcodes_1.OpcodesCommon.OP_CHECKSIG,
            ]);
    }
    return addressContents.payload;
};
/**
 * Encode a locking bytecode as a CashAddress given a network prefix.
 *
 * If `bytecode` matches either the P2PKH or P2SH pattern, it is encoded using
 * the proper address type and returned as a valid CashAddress (string).
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), the resulting `AddressContents` is returned.
 *
 * @param bytecode - the locking bytecode to encode
 * @param prefix - the network prefix to use, e.g. `bitcoincash`, `bchtest`, or
 * `bchreg`
 */
exports.lockingBytecodeToCashAddress = (bytecode, prefix) => {
    const contents = exports.lockingBytecodeToAddressContents(bytecode);
    if (contents.type === AddressType.p2pkh) {
        return cash_address_1.encodeCashAddress(prefix, cash_address_1.CashAddressType.P2PKH, contents.payload);
    }
    if (contents.type === AddressType.p2sh) {
        return cash_address_1.encodeCashAddress(prefix, cash_address_1.CashAddressType.P2SH, contents.payload);
    }
    return contents;
};
var LockingBytecodeEncodingError;
(function (LockingBytecodeEncodingError) {
    LockingBytecodeEncodingError["unknownCashAddressType"] = "This CashAddress uses an unknown address type.";
})(LockingBytecodeEncodingError = exports.LockingBytecodeEncodingError || (exports.LockingBytecodeEncodingError = {}));
/**
 * Convert a CashAddress to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network prefix. If an error
 * occurs, an error message is returned as a string.
 *
 * @param address - the CashAddress to convert
 */
exports.cashAddressToLockingBytecode = (address) => {
    const decoded = cash_address_1.decodeCashAddress(address);
    if (typeof decoded === 'string')
        return decoded;
    if (decoded.type === cash_address_1.CashAddressType.P2PKH) {
        return {
            bytecode: exports.addressContentsToLockingBytecode({
                payload: decoded.hash,
                type: AddressType.p2pkh,
            }),
            prefix: decoded.prefix,
        };
    }
    if (decoded.type === cash_address_1.CashAddressType.P2SH) {
        return {
            bytecode: exports.addressContentsToLockingBytecode({
                payload: decoded.hash,
                type: AddressType.p2sh,
            }),
            prefix: decoded.prefix,
        };
    }
    return LockingBytecodeEncodingError.unknownCashAddressType;
};
/**
 * Encode a locking bytecode as a Base58Address for a given network.
 *
 * If `bytecode` matches either the P2PKH or P2SH pattern, it is encoded using
 * the proper address type and returned as a valid Base58Address (string).
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), the resulting `AddressContents` is returned.
 *
 * @param sha256 - an implementation of sha256 (a universal implementation is
 * available via `instantiateSha256`)
 * @param bytecode - the locking bytecode to encode
 * @param network - the network for which to encode the address (`mainnet` or
 * `testnet`)
 */
exports.lockingBytecodeToBase58Address = (sha256, bytecode, network) => {
    const contents = exports.lockingBytecodeToAddressContents(bytecode);
    if (contents.type === AddressType.p2pkh) {
        return base58_address_1.encodeBase58AddressFormat(sha256, {
            'copay-bch': base58_address_1.Base58AddressFormatVersion.p2pkhCopayBCH,
            mainnet: base58_address_1.Base58AddressFormatVersion.p2pkh,
            testnet: base58_address_1.Base58AddressFormatVersion.p2pkhTestnet,
        }[network], contents.payload);
    }
    if (contents.type === AddressType.p2sh) {
        return base58_address_1.encodeBase58AddressFormat(sha256, {
            'copay-bch': base58_address_1.Base58AddressFormatVersion.p2shCopayBCH,
            mainnet: base58_address_1.Base58AddressFormatVersion.p2sh,
            testnet: base58_address_1.Base58AddressFormatVersion.p2shTestnet,
        }[network], contents.payload);
    }
    return contents;
};
/**
 * Convert a Base58Address to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network version. If an error
 * occurs, an error message is returned as a string.
 *
 * @param address - the CashAddress to convert
 */
exports.base58AddressToLockingBytecode = (sha256, address) => {
    const decoded = base58_address_1.decodeBase58Address(sha256, address);
    if (typeof decoded === 'string')
        return decoded;
    return {
        bytecode: exports.addressContentsToLockingBytecode({
            payload: decoded.payload,
            type: [
                base58_address_1.Base58AddressFormatVersion.p2pkh,
                base58_address_1.Base58AddressFormatVersion.p2pkhCopayBCH,
                base58_address_1.Base58AddressFormatVersion.p2pkhTestnet,
            ].includes(decoded.version)
                ? AddressType.p2pkh
                : AddressType.p2sh,
        }),
        version: decoded.version,
    };
};
//# sourceMappingURL=locking-bytecode.js.map