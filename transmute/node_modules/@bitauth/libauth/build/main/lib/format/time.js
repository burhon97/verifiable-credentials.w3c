"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLocktimeBin = exports.dateToLocktimeBin = exports.locktimeToDate = exports.dateToLocktime = exports.LocktimeError = exports.maximumLocktimeDate = exports.minimumLocktimeDate = exports.maximumLocktimeTimestamp = exports.minimumLocktimeTimestamp = void 0;
const numbers_1 = require("./numbers");
const msPerLocktimeSecond = 1000;
/**
 * The minimum Unix timestamp (inclusive) which can be encoded by a
 * transaction's `locktime`.
 */
exports.minimumLocktimeTimestamp = 500000000;
/**
 * The maximum Unix timestamp (inclusive) which can be encoded by a
 * transaction's `locktime`.
 */
exports.maximumLocktimeTimestamp = 0xffffffff;
/**
 * The minimum Date (inclusive) which can be encoded by a transaction's
 * `locktime`.
 */
exports.minimumLocktimeDate = new Date(exports.minimumLocktimeTimestamp * msPerLocktimeSecond);
/**
 * The maximum Date (inclusive) which can be encoded by a transaction's
 * `locktime`.
 */
exports.maximumLocktimeDate = new Date(exports.maximumLocktimeTimestamp * msPerLocktimeSecond);
var LocktimeError;
(function (LocktimeError) {
    LocktimeError["dateOutOfRange"] = "The provided Date is outside of the range which can be encoded in locktime.";
    LocktimeError["locktimeOutOfRange"] = "The provided locktime is outside of the range which can be encoded as a Date (greater than or equal to 500000000 and less than or equal to 4294967295).";
    LocktimeError["incorrectLength"] = "The provided locktime is not the correct length (4 bytes).";
})(LocktimeError = exports.LocktimeError || (exports.LocktimeError = {}));
/**
 * Convert a JavaScript `Date` object to its equivalent transaction `locktime`
 * representation. The `date` is rounded to the nearest second (the precision of
 * `locktime` Dates).
 *
 * Note, a locktime values greater than or equal to `500000000`
 * See `Transaction.locktime` for details.
 *
 * @param date - the Date to convert to a locktime number
 */
exports.dateToLocktime = (date) => date < exports.minimumLocktimeDate || date > exports.maximumLocktimeDate
    ? LocktimeError.dateOutOfRange
    : Math.round(date.getTime() / msPerLocktimeSecond);
/**
 * Convert a transaction `locktime` to its equivalent JavaScript `Date` object.
 * If locktime is outside the possible range (greater than or equal to
 * `500000000` and less than or equal to `4294967295`), an error message is
 * returned.
 *
 * @param locktime - a positive integer between `500000000` and `4294967295`,
 * inclusive
 */
exports.locktimeToDate = (locktime) => locktime < exports.minimumLocktimeTimestamp || locktime > exports.maximumLocktimeTimestamp
    ? LocktimeError.locktimeOutOfRange
    : new Date(locktime * msPerLocktimeSecond);
/**
 * Convert a JavaScript `Date` object to its equivalent transaction `locktime`
 * bytecode representation. The `date` is rounded to the nearest second (the
 * precision of `locktime` Dates).
 *
 * Note: a block-based locktime can simply be encoded with `numberToBinUint32LE`
 * (provided it is no larger than the maximum, `499999999`).
 *
 * @param date - the Date to convert to a locktime Uint8Array
 */
exports.dateToLocktimeBin = (date) => {
    const result = exports.dateToLocktime(date);
    return typeof result === 'string' ? result : numbers_1.numberToBinUint32LE(result);
};
const locktimeByteLength = 4;
/**
 * Parse a locktime, returning a `number` for block heights, a `Date` for block
 * times, or a string for parsing errors.
 *
 * @param bin - the 4-byte Uint8Array locktime to parse
 */
exports.parseLocktimeBin = (bin) => {
    if (bin.length !== locktimeByteLength)
        return LocktimeError.incorrectLength;
    const parsed = numbers_1.binToNumberUint32LE(bin);
    return parsed >= exports.minimumLocktimeTimestamp
        ? new Date(parsed * msPerLocktimeSecond)
        : parsed;
};
//# sourceMappingURL=time.js.map