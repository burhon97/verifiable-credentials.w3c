"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable functional/no-expression-statement, @typescript-eslint/no-magic-numbers */
const ava_1 = __importDefault(require("ava"));
const ava_fast_check_1 = require("ava-fast-check");
const lib_1 = require("../lib");
ava_1.default('numberToBinUint16LE', (t) => {
    t.deepEqual(lib_1.numberToBinUint16LE(0), Uint8Array.from([0, 0]));
    t.deepEqual(lib_1.numberToBinUint16LE(1), Uint8Array.from([1, 0]));
    t.deepEqual(lib_1.numberToBinUint16LE(0x1234), Uint8Array.from([0x34, 0x12]));
});
ava_1.default('numberToBinUint16BE', (t) => {
    t.deepEqual(lib_1.numberToBinUint16BE(0), Uint8Array.from([0, 0]));
    t.deepEqual(lib_1.numberToBinUint16BE(1), Uint8Array.from([0, 1]));
    t.deepEqual(lib_1.numberToBinUint16BE(0x1234), Uint8Array.from([0x12, 0x34]));
});
ava_1.default('numberToBinUint16LE vs. numberToBinUint16LEClamped: behavior on overflow', (t) => {
    t.deepEqual(lib_1.numberToBinUint16LE(65536), lib_1.numberToBinUint16LE(65536 % (0xffff + 1)));
    t.deepEqual(lib_1.numberToBinUint16LEClamped(65536), Uint8Array.from([0xff, 0xff]));
});
ava_1.default('numberToBinUint16LE vs. numberToBinUint16LEClamped: behavior on negative numbers', (t) => {
    t.deepEqual(lib_1.numberToBinUint16LE(-2), lib_1.numberToBinUint16LE(0xffff - 1));
    t.deepEqual(lib_1.numberToBinUint16LEClamped(-2), Uint8Array.from([0, 0]));
});
ava_1.default('numberToBinUint32LE', (t) => {
    t.deepEqual(lib_1.numberToBinUint32LE(0), Uint8Array.from([0, 0, 0, 0]));
    t.deepEqual(lib_1.numberToBinUint32LE(1), Uint8Array.from([1, 0, 0, 0]));
    t.deepEqual(lib_1.numberToBinUint32LE(0x1234), Uint8Array.from([0x34, 0x12, 0, 0]));
    t.deepEqual(lib_1.numberToBinUint32LE(0x12345678), Uint8Array.from([0x78, 0x56, 0x34, 0x12]));
});
ava_1.default('numberToBinUint32BE', (t) => {
    t.deepEqual(lib_1.numberToBinUint32BE(0), Uint8Array.from([0, 0, 0, 0]));
    t.deepEqual(lib_1.numberToBinUint32BE(1), Uint8Array.from([0, 0, 0, 1]));
    t.deepEqual(lib_1.numberToBinUint32BE(0x1234), Uint8Array.from([0, 0, 0x12, 0x34]));
    t.deepEqual(lib_1.numberToBinUint32BE(0x12345678), Uint8Array.from([0x12, 0x34, 0x56, 0x78]));
});
ava_1.default('numberToBinUint32LE vs. numberToBinUint32LEClamped: behavior on overflow', (t) => {
    t.deepEqual(lib_1.numberToBinUint32LE(4294967296), lib_1.numberToBinUint32LE(4294967296 % (0xffffffff + 1)));
    t.deepEqual(lib_1.numberToBinUint32LEClamped(4294967296), Uint8Array.from([0xff, 0xff, 0xff, 0xff]));
});
ava_1.default('numberToBinUint32LE: behavior on negative numbers', (t) => {
    t.deepEqual(lib_1.numberToBinUint32LE(-2), lib_1.numberToBinUint32LE(0xffffffff - 1));
    t.deepEqual(lib_1.numberToBinUint32LEClamped(-2), Uint8Array.from([0, 0, 0, 0]));
});
ava_1.default('numberToBinUintLE', (t) => {
    t.deepEqual(lib_1.numberToBinUintLE(Number.MAX_SAFE_INTEGER), Uint8Array.from([255, 255, 255, 255, 255, 255, 31]));
});
ava_1.default('numberToBinInt16LE', (t) => {
    t.deepEqual(lib_1.numberToBinInt16LE(0), Uint8Array.from([0, 0]));
    t.deepEqual(lib_1.numberToBinInt16LE(1), Uint8Array.from([1, 0]));
    t.deepEqual(lib_1.numberToBinInt16LE(0x1234), Uint8Array.from([0x34, 0x12]));
    t.deepEqual(lib_1.numberToBinInt16LE(-0x1234), Uint8Array.from([0xcc, 0xed]));
});
ava_1.default('numberToBinInt32LE', (t) => {
    t.deepEqual(lib_1.numberToBinInt32LE(0), Uint8Array.from([0, 0, 0, 0]));
    t.deepEqual(lib_1.numberToBinInt32LE(1), Uint8Array.from([1, 0, 0, 0]));
    t.deepEqual(lib_1.numberToBinInt32LE(0x1234), Uint8Array.from([0x34, 0x12, 0, 0]));
    t.deepEqual(lib_1.numberToBinInt32LE(-0x1234), Uint8Array.from([0xcc, 0xed, 0xff, 0xff]));
    t.deepEqual(lib_1.numberToBinUint32LE(0x12345678), Uint8Array.from([0x78, 0x56, 0x34, 0x12]));
    t.deepEqual(lib_1.numberToBinInt32LE(-0x12345678), Uint8Array.from([0x88, 0xa9, 0xcb, 0xed]));
});
ava_1.default('numberToBinInt32TwosCompliment', (t) => {
    t.deepEqual(lib_1.numberToBinInt32TwosCompliment(0), Uint8Array.from([0, 0, 0, 0]));
    t.deepEqual(lib_1.numberToBinInt32TwosCompliment(1), Uint8Array.from([1, 0, 0, 0]));
    t.deepEqual(lib_1.numberToBinInt32TwosCompliment(-0xffffffff), Uint8Array.from([1, 0, 0, 0]));
    t.deepEqual(lib_1.numberToBinInt32TwosCompliment(0xffffffff), Uint8Array.from([255, 255, 255, 255]));
    t.deepEqual(lib_1.numberToBinInt32TwosCompliment(-1), Uint8Array.from([255, 255, 255, 255]));
    t.deepEqual(lib_1.numberToBinInt32TwosCompliment(0xffff), Uint8Array.from([255, 255, 0, 0]));
    t.deepEqual(lib_1.numberToBinInt32TwosCompliment(-0xffff), Uint8Array.from([1, 0, 255, 255]));
    t.deepEqual(lib_1.numberToBinInt32TwosCompliment(1234567890), Uint8Array.from([210, 2, 150, 73]));
    t.deepEqual(lib_1.numberToBinInt32TwosCompliment(-1234567890), Uint8Array.from([46, 253, 105, 182]));
});
ava_1.default('bigIntToBinUint64LE', (t) => {
    t.deepEqual(lib_1.bigIntToBinUint64LE(BigInt(0)), Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0]));
    t.deepEqual(lib_1.bigIntToBinUint64LE(BigInt(0x01)), Uint8Array.from([0x01, 0, 0, 0, 0, 0, 0, 0]));
    t.deepEqual(lib_1.bigIntToBinUint64LE(BigInt(0x12345678)), Uint8Array.from([0x78, 0x56, 0x34, 0x12, 0, 0, 0, 0]));
    t.deepEqual(lib_1.bigIntToBinUint64LE(BigInt(Number.MAX_SAFE_INTEGER)), Uint8Array.from([255, 255, 255, 255, 255, 255, 31, 0]));
    t.deepEqual(lib_1.bigIntToBinUint64LE(BigInt('0xffffffffffffffff')), Uint8Array.from([255, 255, 255, 255, 255, 255, 255, 255]));
});
ava_1.default('bigIntToBinUint64LE vs. bigIntToBinUint64LEClamped: behavior on overflow', (t) => {
    t.deepEqual(lib_1.bigIntToBinUint64LE(BigInt('0x010000000000000000')), lib_1.bigIntToBinUint64LE(BigInt('0x010000000000000000') %
        (BigInt('0xffffffffffffffff') + BigInt(1))));
    t.deepEqual(lib_1.bigIntToBinUint64LEClamped(BigInt('0x010000000000000000')), Uint8Array.from([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]));
});
ava_1.default('bigIntToBinUint64LE vs. bigIntToBinUint64LEClamped: behavior on negative numbers', (t) => {
    t.deepEqual(lib_1.bigIntToBinUint64LE(BigInt(-1)), Uint8Array.from([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]));
    t.deepEqual(lib_1.bigIntToBinUint64LEClamped(BigInt(-1)), Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0]));
});
ava_1.default('bigIntToBitcoinVarInt: larger values return modulo result after opcode', (t) => {
    t.deepEqual(lib_1.bigIntToBitcoinVarInt(BigInt('0x010000000000000001')), Uint8Array.from([0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]));
});
ava_1.default('binToNumberUintLE', (t) => {
    t.deepEqual(lib_1.binToNumberUintLE(Uint8Array.from([0x12])), 0x12);
    t.deepEqual(lib_1.binToNumberUintLE(Uint8Array.from([0x34, 0x12])), 0x1234);
    t.deepEqual(lib_1.binToNumberUintLE(Uint8Array.from([0x78, 0x56, 0x34, 0x12])), 0x12345678);
    t.deepEqual(lib_1.binToNumberUintLE(Uint8Array.from([0x90, 0x78, 0x56, 0x34, 0x12])), 0x1234567890);
    t.deepEqual(lib_1.binToNumberUintLE(Uint8Array.from([255, 255, 255, 255, 255, 255, 31])), Number.MAX_SAFE_INTEGER);
    t.deepEqual(lib_1.binToNumberUintLE(Uint8Array.from([0x56, 0x34, 0x12])), 0x123456);
    const data = Uint8Array.from([0x90, 0x78, 0x56, 0x34, 0x12]);
    const view = data.subarray(2);
    t.deepEqual(lib_1.binToNumberUintLE(view), 0x123456);
    t.throws(() => {
        lib_1.binToNumberUintLE(Uint8Array.of(0x12), 2);
    });
});
ava_fast_check_1.testProp('[fast-check] numberToBinUintLE <-> binToNumberUintLE', [ava_fast_check_1.fc.integer(0, Number.MAX_SAFE_INTEGER)], (t, maxSafeInt) => t.deepEqual(lib_1.binToNumberUintLE(lib_1.numberToBinUintLE(maxSafeInt)), maxSafeInt));
ava_1.default('binToNumberUint16LE', (t) => {
    t.deepEqual(lib_1.binToNumberUint16LE(Uint8Array.from([0x34, 0x12])), 0x1234);
    const data = Uint8Array.from([0x90, 0x78, 0x56, 0x34, 0x12, 0x00]);
    const view = data.subarray(2, 4);
    t.deepEqual(lib_1.binToNumberUint16LE(view), 0x3456);
});
ava_1.default('binToNumberInt16LE', (t) => {
    t.deepEqual(lib_1.binToNumberInt16LE(Uint8Array.from([0x34, 0x12])), 0x1234);
    t.deepEqual(lib_1.binToNumberInt16LE(Uint8Array.from([0xcc, 0xed])), -0x1234);
});
ava_1.default('binToNumberInt32LE', (t) => {
    t.deepEqual(lib_1.binToNumberInt32LE(Uint8Array.from([0x78, 0x56, 0x34, 0x12])), 0x12345678);
    t.deepEqual(lib_1.binToNumberInt32LE(Uint8Array.from([0x88, 0xa9, 0xcb, 0xed])), -0x12345678);
});
ava_1.default('binToNumberUint16LE: ignores bytes after the 2nd', (t) => {
    t.deepEqual(lib_1.binToNumberUint16LE(Uint8Array.from([0x78, 0x56, 0x34, 0x12, 0xff])), 0x5678);
});
ava_1.default('binToNumberUint32LE', (t) => {
    t.deepEqual(lib_1.binToNumberUint32LE(Uint8Array.from([0x78, 0x56, 0x34, 0x12])), 0x12345678);
    const data = Uint8Array.from([0x90, 0x78, 0x56, 0x34, 0x12, 0x00]);
    const view = data.subarray(2);
    t.deepEqual(lib_1.binToNumberUint32LE(view), 0x123456);
});
ava_1.default('binToNumberUint32LE: ignores bytes after the 4th', (t) => {
    t.deepEqual(lib_1.binToNumberUint32LE(Uint8Array.from([0x78, 0x56, 0x34, 0x12, 0xff])), 0x12345678);
});
ava_1.default('binToBigIntUintBE', (t) => {
    t.deepEqual(lib_1.binToBigIntUintBE(Uint8Array.from([0x12])), BigInt(0x12));
    t.deepEqual(lib_1.binToBigIntUintBE(Uint8Array.from([0x12, 0x34])), BigInt(0x1234));
    t.deepEqual(lib_1.binToBigIntUintBE(Uint8Array.from([0x12, 0x34, 0x56])), BigInt(0x123456));
    t.deepEqual(lib_1.binToBigIntUintBE(Uint8Array.from([0x12, 0x34, 0x56, 0x78])), BigInt(0x12345678));
    t.deepEqual(lib_1.binToBigIntUintBE(Uint8Array.from([0x12, 0x34, 0x56, 0x78, 0x90])), BigInt(0x1234567890));
    t.deepEqual(lib_1.binToBigIntUintBE(Uint8Array.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef])), BigInt('0x1234567890abcdef'));
    t.deepEqual(lib_1.binToBigIntUintBE(Uint8Array.from([0x56, 0x78, 0x90, 0xab, 0xcd, 0xef])), BigInt('0x567890abcdef'));
    const d = Uint8Array.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef]);
    const view = d.subarray(2);
    t.deepEqual(lib_1.binToBigIntUintBE(view), BigInt('0x567890abcdef'));
    t.throws(() => {
        lib_1.binToBigIntUintBE(Uint8Array.of(0x12), 2);
    });
});
ava_1.default('binToBigIntUint256BE and bigIntToBinUint256BEClamped', (t) => {
    t.deepEqual(lib_1.binToBigIntUint256BE(new Uint8Array(32)), BigInt(0));
    t.deepEqual(lib_1.bigIntToBinUint256BEClamped(BigInt(0)), new Uint8Array(32));
    t.deepEqual(lib_1.bigIntToBinUint256BEClamped(BigInt(-1)), new Uint8Array(32));
    const secp256k1OrderNHex = 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141';
    const secp256k1OrderNBin = lib_1.hexToBin(secp256k1OrderNHex);
    const secp256k1OrderN = BigInt(`0x${secp256k1OrderNHex}`);
    t.deepEqual(lib_1.binToBigIntUint256BE(secp256k1OrderNBin), secp256k1OrderN);
    t.deepEqual(lib_1.bigIntToBinUint256BEClamped(secp256k1OrderN), secp256k1OrderNBin);
    const max = new Uint8Array(32);
    max.fill(255);
    const overMax = new Uint8Array(33);
    // eslint-disable-next-line functional/immutable-data
    overMax[0] = 255;
    t.deepEqual(lib_1.bigIntToBinUint256BEClamped(BigInt(`0x${lib_1.binToHex(overMax)}`)), max);
});
ava_fast_check_1.testProp('[fast-check] binToBigIntUint256BE <-> bigIntToBinUint256BEClamped', [ava_fast_check_1.fc.bigUintN(256)], (t, uint256) => t.deepEqual(lib_1.binToBigIntUint256BE(lib_1.bigIntToBinUint256BEClamped(uint256)), uint256));
ava_1.default('binToBigIntUintLE', (t) => {
    t.deepEqual(lib_1.binToBigIntUintLE(Uint8Array.from([0x12])), BigInt(0x12));
    t.deepEqual(lib_1.binToBigIntUintLE(Uint8Array.from([0x34, 0x12])), BigInt(0x1234));
    t.deepEqual(lib_1.binToBigIntUintLE(Uint8Array.from([0x56, 0x34, 0x12])), BigInt(0x123456));
    t.deepEqual(lib_1.binToBigIntUintLE(Uint8Array.from([0x78, 0x56, 0x34, 0x12])), BigInt(0x12345678));
    t.deepEqual(lib_1.binToBigIntUintLE(Uint8Array.from([0x90, 0x78, 0x56, 0x34, 0x12])), BigInt(0x1234567890));
    t.deepEqual(lib_1.binToBigIntUintLE(Uint8Array.from([0xef, 0xcd, 0xab, 0x90, 0x78, 0x56, 0x34, 0x12])), BigInt('0x1234567890abcdef'));
    t.deepEqual(lib_1.binToBigIntUintLE(Uint8Array.from([0xab, 0x90, 0x78, 0x56, 0x34, 0x12])), BigInt('0x1234567890ab'));
    const d = Uint8Array.from([0xef, 0xcd, 0xab, 0x90, 0x78, 0x56, 0x34, 0x12]);
    const view = d.subarray(2);
    t.deepEqual(lib_1.binToBigIntUintLE(view), BigInt('0x1234567890ab'));
    t.throws(() => {
        lib_1.binToBigIntUintLE(Uint8Array.of(0x12), 2);
    });
});
ava_fast_check_1.testProp('[fast-check] bigIntToBinUintLE <-> binToBigIntUintBE -> reverse', [ava_fast_check_1.fc.bigUintN(256)], (t, uint256) => {
    const bin = lib_1.bigIntToBinUintLE(uint256);
    const binReverse = bin.slice().reverse();
    t.deepEqual(lib_1.binToBigIntUintBE(binReverse), lib_1.binToBigIntUintLE(bin));
});
ava_fast_check_1.testProp('[fast-check] bigIntToBinUintLE <-> binToBigIntUintLE', [ava_fast_check_1.fc.bigUintN(65)], (t, uint65) => t.deepEqual(lib_1.binToBigIntUintLE(lib_1.bigIntToBinUintLE(uint65)), uint65));
ava_1.default('binToBigIntUint64LE', (t) => {
    t.deepEqual(lib_1.binToBigIntUint64LE(Uint8Array.from([0x78, 0x56, 0x34, 0x12, 0, 0, 0, 0])), BigInt(0x12345678));
    t.deepEqual(lib_1.binToBigIntUint64LE(Uint8Array.from([0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01])), BigInt('0x0123456789abcdef'));
    t.deepEqual(lib_1.binToBigIntUint64LE(Uint8Array.from([
        0xef,
        0xcd,
        0xab,
        0x89,
        0x67,
        0x45,
        0x23,
        0x01,
        0x00,
        0x00,
    ])), BigInt('0x0123456789abcdef'));
    const data = Uint8Array.from([0x90, 0x78, 0x56, 0x34, 0x12, 0, 0, 0, 0, 0]);
    const view = data.subarray(2);
    t.deepEqual(lib_1.binToBigIntUint64LE(view), BigInt(0x123456));
    t.throws(() => lib_1.binToBigIntUint64LE(Uint8Array.from([0x78, 0x56, 0x34, 0x12])));
});
ava_1.default('readBitcoinVarInt: offset is optional', (t) => {
    t.deepEqual(lib_1.readBitcoinVarInt(lib_1.hexToBin('00')), {
        nextOffset: 1,
        value: BigInt(0x00),
    });
});
const varIntVector = (t, hex, value, nextOffset, start = 0, expected = hex
// eslint-disable-next-line max-params
) => {
    t.deepEqual(lib_1.readBitcoinVarInt(lib_1.hexToBin(hex), start), {
        nextOffset,
        value,
    });
    t.deepEqual(lib_1.bigIntToBitcoinVarInt(value), lib_1.hexToBin(expected));
};
// eslint-disable-next-line functional/immutable-data
varIntVector.title = (_, string) => `readBitcoinVarInt/bigIntToBitcoinVarInt: ${string}`;
ava_1.default(varIntVector, '00', BigInt(0x00), 1);
ava_1.default(varIntVector, '01', BigInt(0x01), 1);
ava_1.default(varIntVector, '12', BigInt(0x12), 1);
ava_1.default(varIntVector, '6a', BigInt(0x6a), 1);
ava_1.default(varIntVector, '00006a', BigInt(0x6a), 3, 2, '6a');
ava_1.default(varIntVector, 'fc', BigInt(0xfc), 1);
ava_1.default(varIntVector, 'fdfd00', BigInt(0x00fd), 3);
ava_1.default(varIntVector, '000000fdfd00', BigInt(0xfd), 6, 3, 'fdfd00');
ava_1.default(varIntVector, 'fdfe00', BigInt(0x00fe), 3);
ava_1.default(varIntVector, 'fdff00', BigInt(0x00ff), 3);
ava_1.default(varIntVector, 'fd1111', BigInt(0x1111), 3);
ava_1.default(varIntVector, 'fd1234', BigInt(0x3412), 3);
ava_1.default(varIntVector, 'fdfeff', BigInt(0xfffe), 3);
ava_1.default(varIntVector, 'fdffff', BigInt(0xffff), 3);
ava_1.default(varIntVector, 'fe00000100', BigInt(0x010000), 5);
ava_1.default(varIntVector, '00fe00000100', BigInt(0x010000), 6, 1, 'fe00000100');
ava_1.default(varIntVector, 'fe01000100', BigInt(0x010001), 5);
ava_1.default(varIntVector, 'fe11111111', BigInt(0x11111111), 5);
ava_1.default(varIntVector, 'fe12345678', BigInt(0x78563412), 5);
ava_1.default(varIntVector, 'feffffffff', BigInt(0xffffffff), 5);
ava_1.default(varIntVector, 'ff0000000001000000', BigInt(0x0100000000), 9);
ava_1.default(varIntVector, '0000ff0000000001000000', BigInt(0x0100000000), 11, 2, 'ff0000000001000000');
ava_1.default(varIntVector, 'ff0100000001000000', BigInt(0x0100000001), 9);
ava_1.default(varIntVector, 'ff1111111111111111', BigInt('0x1111111111111111'), 9);
ava_1.default(varIntVector, 'ff1234567890abcdef', BigInt('0xefcdab9078563412'), 9);
ava_fast_check_1.testProp('[fast-check] bigIntToBitcoinVarInt <-> readBitcoinVarInt', [ava_fast_check_1.fc.bigUintN(64)], (t, uint64) => {
    const varInt = lib_1.bigIntToBitcoinVarInt(uint64);
    const expectedOffset = lib_1.varIntPrefixToSize(varInt[0]);
    const result = lib_1.readBitcoinVarInt(varInt);
    t.deepEqual(result, { nextOffset: expectedOffset, value: uint64 });
});
//# sourceMappingURL=numbers.spec.js.map