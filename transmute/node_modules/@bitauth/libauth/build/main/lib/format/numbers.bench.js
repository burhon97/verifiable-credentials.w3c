"use strict";
/* eslint-disable functional/no-let, @typescript-eslint/init-declarations, functional/no-expression-statement */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const ava_1 = __importDefault(require("ava"));
const chuhai_1 = __importDefault(require("chuhai"));
const lib_1 = require("../lib");
ava_1.default(`node: binToBigIntUintBE vs. binToHex -> BigInt()`, async (t) => {
    await chuhai_1.default(t.title, (s) => {
        let sourceBin;
        let num;
        let result;
        const nextCycle = () => {
            const uint256Length = 32;
            sourceBin = Uint8Array.from(crypto_1.randomBytes(uint256Length));
            num = lib_1.binToBigIntUintBE(sourceBin);
        };
        nextCycle();
        s.bench('binToBigIntUintBE', () => {
            result = lib_1.binToBigIntUintBE(sourceBin);
        });
        s.bench('binToHex -> BigInt()', () => {
            result = BigInt(`0x${lib_1.binToHex(sourceBin)}`);
        });
        s.cycle(() => {
            t.deepEqual(result, num);
            nextCycle();
        });
    });
});
ava_1.default(`node: numberToBinUint16LE vs. numberToBinUint16LEClamped`, async (t) => {
    await chuhai_1.default(t.title, (s) => {
        let expectedBin;
        let num;
        let resultBin;
        const nextCycle = () => {
            const uint16Length = 2;
            expectedBin = Uint8Array.from(crypto_1.randomBytes(uint16Length));
            num = lib_1.binToNumberUint16LE(expectedBin);
        };
        nextCycle();
        s.bench('numberToBinUint16LE', () => {
            resultBin = lib_1.numberToBinUint16LE(num);
        });
        s.bench('numberToBinUint16LEClamped', () => {
            resultBin = lib_1.numberToBinUint16LEClamped(num);
        });
        s.cycle(() => {
            t.deepEqual(resultBin, expectedBin);
            nextCycle();
        });
    });
});
ava_1.default(`node: numberToBinUint32LE vs. numberToBinUint32LEClamped`, async (t) => {
    await chuhai_1.default(t.title, (s) => {
        let expectedBin;
        let num;
        let resultBin;
        const nextCycle = () => {
            const uint32Length = 4;
            expectedBin = Uint8Array.from(crypto_1.randomBytes(uint32Length));
            num = lib_1.binToNumberUint32LE(expectedBin);
        };
        nextCycle();
        s.bench('numberToBinUint32LE', () => {
            resultBin = lib_1.numberToBinUint32LE(num);
        });
        s.bench('numberToBinUint32LEClamped', () => {
            resultBin = lib_1.numberToBinUint32LEClamped(num);
        });
        s.cycle(() => {
            t.deepEqual(resultBin, expectedBin);
            nextCycle();
        });
    });
});
ava_1.default(`node: bigIntToBinUint64LE vs. bigIntToBinUint64LEClamped`, async (t) => {
    await chuhai_1.default(t.title, (s) => {
        let expectedBin;
        let num;
        let resultBin;
        const nextCycle = () => {
            const uint64Length = 8;
            expectedBin = Uint8Array.from(crypto_1.randomBytes(uint64Length));
            num = lib_1.binToBigIntUint64LE(expectedBin);
        };
        nextCycle();
        s.bench('bigIntToBinUint64LE', () => {
            resultBin = lib_1.bigIntToBinUint64LE(num);
        });
        s.bench('bigIntToBinUint64LEClamped', () => {
            resultBin = lib_1.bigIntToBinUint64LEClamped(num);
        });
        s.cycle(() => {
            t.deepEqual(resultBin, expectedBin);
            nextCycle();
        });
    });
});
//# sourceMappingURL=numbers.bench.js.map