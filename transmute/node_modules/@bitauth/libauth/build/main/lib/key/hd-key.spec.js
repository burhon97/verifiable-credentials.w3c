"use strict";
/* eslint-disable functional/no-expression-statement */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = __importDefault(require("ava"));
const ava_fast_check_1 = require("ava-fast-check");
const bitcoreLibCash = __importStar(require("bitcore-lib-cash"));
const lib_1 = require("../lib");
const seed = Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
const xprv = 'xprv9s21ZrQH143K2JbpEjGU94NcdKSASB7LuXvJCTsxuENcGN1nVG7QjMnBZ6zZNcJaiJogsRaLaYFFjs48qt4Fg7y1GnmrchQt1zFNu6QVnta';
const tprv = 'tprv8ZgxMBicQKsPd7qLuJ7yJhzbwSrNfh9MF5qR4tJRPCs63xksUdTAF79dUHADNygu5kLTsXC6jtq4Cibsy6QCVBEboRzAH48vw5zoLkJTuso';
const xpub = 'xpub661MyMwAqRbcEngHLkoUWCKMBMGeqdqCGkqtzrHaTZub9ALw2oRfHA6fQP5n5X9VHStaNTBYomkSb8BFhUGavwD3RG1qvMkEKceTavTp2Tm';
const tpub = 'tpubD6NzVbkrYhZ4Was8nwnZi7eiWUNJq2LFpPSCMQLioUfUtT1e72GkRbmVeRAZc26j5MRUz2hRLsaVHJfs6L7ppNfLUrm9btQTuaEsLrT7D87';
const maxUint8Number = 255;
const fcUint8Array = (minLength, maxLength) => ava_fast_check_1.fc
    .array(ava_fast_check_1.fc.integer(0, maxUint8Number), minLength, maxLength)
    .map((a) => Uint8Array.from(a));
const maximumDepth = 255;
const maximumChildIndex = 0xffffffff;
const fingerprintLength = 4;
const chainCodeLength = 32;
const privateKeyLength = 32;
const publicKeyLength = 33;
const hardenedIndexOffset = 0x80000000;
const maximumNonHardenedIndex = hardenedIndexOffset - 1;
ava_1.default('[crypto] deriveHdPrivateNodeFromSeed', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const valid = {
        chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
        childIndex: 0,
        depth: 0,
        parentFingerprint: lib_1.hexToBin('00000000'),
        privateKey: lib_1.hexToBin('330fd355e141910d33bbe84c369b87a209dd18b81095912be766b2b5a9d72bc4'),
        valid: true,
    };
    const invalid = {
        chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
        childIndex: 0,
        depth: 0,
        invalidPrivateKey: lib_1.hexToBin('330fd355e141910d33bbe84c369b87a209dd18b81095912be766b2b5a9d72bc4'),
        parentFingerprint: lib_1.hexToBin('00000000'),
        valid: false,
    };
    const either = lib_1.deriveHdPrivateNodeFromSeed(crypto, seed);
    const validNode = lib_1.deriveHdPrivateNodeFromSeed(crypto, seed, true);
    const invalidNode = lib_1.deriveHdPrivateNodeFromSeed(crypto, seed, false);
    t.deepEqual(either, valid);
    t.deepEqual(validNode, valid);
    t.deepEqual(invalidNode, invalid);
});
ava_1.default('[crypto] deriveHdPrivateNodeIdentifier', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const { node } = lib_1.decodeHdPrivateKey(crypto, xprv);
    t.deepEqual(lib_1.deriveHdPrivateNodeIdentifier(crypto, node), lib_1.hexToBin('15c918d389673c6cd0660050f268a843361e1111'));
});
ava_1.default('[crypto] deriveHdPublicNodeIdentifier', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const { node } = lib_1.decodeHdPublicKey(crypto, xpub);
    t.deepEqual(lib_1.deriveHdPublicNodeIdentifier(crypto, node), lib_1.hexToBin('15c918d389673c6cd0660050f268a843361e1111'));
});
ava_1.default('[crypto] decodeHdKey', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    t.deepEqual(lib_1.decodeHdKey(crypto, xprv), {
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            privateKey: lib_1.hexToBin('330fd355e141910d33bbe84c369b87a209dd18b81095912be766b2b5a9d72bc4'),
            valid: true,
        },
        version: lib_1.HdKeyVersion.mainnetPrivateKey,
    });
    t.deepEqual(lib_1.decodeHdKey(crypto, xpub), {
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            publicKey: lib_1.hexToBin('02be99138b48b430a8ee40bf8b56c8ebc584c363774010a9bfe549a87126e61746'),
        },
        version: lib_1.HdKeyVersion.mainnetPublicKey,
    });
});
ava_1.default('[crypto] decodeHdKey: errors', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    t.deepEqual(lib_1.decodeHdKey(crypto, '#badKey'), lib_1.HdKeyDecodingError.unknownCharacter);
    t.deepEqual(lib_1.decodeHdKey(crypto, 'xprv1234'), lib_1.HdKeyDecodingError.incorrectLength);
    t.deepEqual(lib_1.decodeHdKey(crypto, 'xpub661MyMwAqRbcEngHLkoUWCKMBMGeqdqCGkqtzrHaTZub9ALw2oRfHA6fQP5n5X9VHStaNTBYomkSb8BFhUGavwD3RG1qvMkEKceTavTp2Ta'), lib_1.HdKeyDecodingError.invalidChecksum);
});
ava_1.default('[crypto] decodeHdPrivateKey', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    t.deepEqual(lib_1.decodeHdPrivateKey(crypto, xprv), {
        network: 'mainnet',
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            privateKey: lib_1.hexToBin('330fd355e141910d33bbe84c369b87a209dd18b81095912be766b2b5a9d72bc4'),
            valid: true,
        },
    });
    t.deepEqual(lib_1.decodeHdPrivateKey(crypto, tprv), {
        network: 'testnet',
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            privateKey: lib_1.hexToBin('330fd355e141910d33bbe84c369b87a209dd18b81095912be766b2b5a9d72bc4'),
            valid: true,
        },
    });
});
ava_1.default('[crypto] decodeHdPrivateKey: errors', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    t.deepEqual(lib_1.decodeHdPrivateKey(crypto, xpub), lib_1.HdKeyDecodingError.privateKeyExpected);
    t.deepEqual(lib_1.decodeHdPrivateKey(crypto, '1111111111111FF9QeH94hg7KAjgjUqkHUqbrw5wWQLoRNfRhB4cHUDCJxx2HfNb5qDiAjpbKjXeLJSknuzDmja42174H9Es1XbY24sZts9'), lib_1.HdKeyDecodingError.unknownVersion);
    const xprvWith0FilledKey = 'xprv9s21ZrQH143K2JbpEjGU94NcdKSASB7LuXvJCTsxuENcGN1nVG7QjMnBZ6c54tCKNErugtr5mi7oyGaDVrYe4SE5u1GnzYHmjDKuKg4vuNm';
    t.deepEqual(lib_1.decodeHdPrivateKey(crypto, xprvWith0FilledKey), lib_1.HdKeyDecodingError.invalidPrivateNode);
    const xprvWith255FilledKey = 'xprv9s21ZrQH143K2JbpEjGU94NcdKSASB7LuXvJCTsxuENcGN1nVG7QjMnBZ8YpF7eMDfY8piRngHjovbAzQyAMi94xgeLuEgyfisLHpC7G5ST';
    t.deepEqual(lib_1.decodeHdPrivateKey(crypto, xprvWith255FilledKey), lib_1.HdKeyDecodingError.invalidPrivateNode);
    t.deepEqual(lib_1.decodeHdPrivateKey(crypto, 'xprv9s21ZrQH143K2JbpEjGU94NcdKSASB7LuXvJCTsxuENcGN1nVG7QjMnBhegPMjkj1oGSFcmBkMX3xdwcMy6NSgrHvmqJptpUW5xGjg7kifZ'), lib_1.HdKeyDecodingError.missingPrivateKeyPaddingByte);
});
ava_1.default('[crypto] decodeHdPublicKey', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    t.deepEqual(lib_1.decodeHdPublicKey(crypto, xpub), {
        network: 'mainnet',
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            publicKey: lib_1.hexToBin('02be99138b48b430a8ee40bf8b56c8ebc584c363774010a9bfe549a87126e61746'),
        },
    });
    t.deepEqual(lib_1.decodeHdPublicKey(crypto, tpub), {
        network: 'testnet',
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            publicKey: lib_1.hexToBin('02be99138b48b430a8ee40bf8b56c8ebc584c363774010a9bfe549a87126e61746'),
        },
    });
});
ava_1.default('[crypto] decodeHdPublicKey: errors', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    t.deepEqual(lib_1.decodeHdPublicKey(crypto, xprv), lib_1.HdKeyDecodingError.publicKeyExpected);
    t.deepEqual(lib_1.decodeHdPublicKey(crypto, '1111111111111FF9QeH94hg7KAjgjUqkHUqbrw5wWQLoRNfRhB4cHUDCJxx2HfNb5qDiAjpbKjXeLJSknuzDmja42174H9Es1XbY24sZts9'), lib_1.HdKeyDecodingError.unknownVersion);
});
ava_1.default('[crypto] encodeHdPrivateKey', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    t.deepEqual(lib_1.encodeHdPrivateKey(crypto, {
        network: 'mainnet',
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            privateKey: lib_1.hexToBin('330fd355e141910d33bbe84c369b87a209dd18b81095912be766b2b5a9d72bc4'),
            valid: true,
        },
    }), xprv);
    t.deepEqual(lib_1.encodeHdPrivateKey(crypto, {
        network: 'testnet',
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            privateKey: lib_1.hexToBin('330fd355e141910d33bbe84c369b87a209dd18b81095912be766b2b5a9d72bc4'),
            valid: true,
        },
    }), tprv);
});
ava_1.default('[crypto] encodeHdPublicKey', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    t.deepEqual(lib_1.encodeHdPublicKey(crypto, {
        network: 'mainnet',
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            publicKey: lib_1.hexToBin('02be99138b48b430a8ee40bf8b56c8ebc584c363774010a9bfe549a87126e61746'),
        },
    }), xpub);
    t.deepEqual(lib_1.encodeHdPublicKey(crypto, {
        network: 'testnet',
        node: {
            chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
            childIndex: 0,
            depth: 0,
            parentFingerprint: lib_1.hexToBin('00000000'),
            publicKey: lib_1.hexToBin('02be99138b48b430a8ee40bf8b56c8ebc584c363774010a9bfe549a87126e61746'),
        },
    }), tpub);
});
ava_1.default('[crypto] deriveHdPublicNode', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const privateParams = lib_1.decodeHdPrivateKey(crypto, xprv);
    if (typeof privateParams === 'string') {
        t.fail(privateParams);
        return;
    }
    t.deepEqual(lib_1.deriveHdPublicNode(crypto, privateParams.node), {
        chainCode: lib_1.hexToBin('18aab7e9ef169f3029d93651d0c85303cbcc2ac559ccd04c324a2e678ef26dc9'),
        childIndex: 0,
        depth: 0,
        parentFingerprint: lib_1.hexToBin('00000000'),
        publicKey: lib_1.hexToBin('02be99138b48b430a8ee40bf8b56c8ebc584c363774010a9bfe549a87126e61746'),
    });
});
ava_1.default('[crypto] deriveHdPrivateNodeChild', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const master = lib_1.decodeHdPrivateKey(crypto, xprv);
    const hardenedIndex0Child = lib_1.decodeHdPrivateKey(crypto, 'xprv9u4S6TaiPQaF7FS24QFpRP6hjff4jXNwwYTkVNC6f6YzHj2a6G28aRN1D6Az82SxMeBivpVS3gDDXyQiu3RANTqWy34Zxi9JN76zSwkjqPF');
    const index1GrandChild = lib_1.decodeHdPrivateKey(crypto, 'xprv9w8PdihBAeR4xgGYWWqBnmDTrpWEW1QjuYAUkR7A6X48q1iQVgN433aSFxQGgtureVz7cCyi5zfuMTtBF3AkanjtvNs9m8u2JobxNfphSi3');
    if (typeof master === 'string' ||
        typeof hardenedIndex0Child === 'string' ||
        typeof index1GrandChild === 'string') {
        t.fail();
        return;
    }
    const hardenedIndex0 = 0x80000000;
    const result0 = lib_1.deriveHdPrivateNodeChild(crypto, master.node, hardenedIndex0);
    const result1 = lib_1.deriveHdPrivateNodeChild(crypto, result0, 1);
    t.deepEqual(result0, Object.assign(Object.assign({}, hardenedIndex0Child.node), { parentIdentifier: lib_1.hexToBin('15c918d389673c6cd0660050f268a843361e1111') }));
    t.deepEqual(result1, Object.assign(Object.assign({}, index1GrandChild.node), { parentIdentifier: lib_1.hexToBin('2f2bc501c943dd7f17904b612c090dd88270cc59') }));
});
ava_1.default('[crypto] deriveHdPrivateNodeChild: errors', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const { node } = lib_1.decodeHdPrivateKey(crypto, xprv);
    const max = 0xffffffff;
    t.deepEqual(lib_1.deriveHdPrivateNodeChild(crypto, node, max + 1), lib_1.HdNodeDerivationError.childIndexExceedsMaximum);
});
ava_1.default('[crypto] deriveHdPublicNodeChild', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const { node } = lib_1.decodeHdPrivateKey(crypto, xprv);
    const parentPublic = lib_1.deriveHdPublicNode(crypto, node);
    const derivationIndex = 0;
    const child = lib_1.deriveHdPrivateNodeChild(crypto, node, derivationIndex);
    const expectedPublic = lib_1.deriveHdPublicNode(crypto, child);
    t.deepEqual(lib_1.deriveHdPublicNodeChild(crypto, parentPublic, derivationIndex), expectedPublic);
});
ava_1.default('[crypto] deriveHdPublicNodeChild: errors', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const { node } = lib_1.decodeHdPublicKey(crypto, xpub);
    const hardened0 = 0x80000000;
    t.deepEqual(lib_1.deriveHdPublicNodeChild(crypto, node, hardened0), lib_1.HdNodeDerivationError.hardenedDerivationRequiresPrivateNode);
});
ava_1.default('[crypto] deriveHdPath', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const { node: privateNode } = lib_1.decodeHdPrivateKey(crypto, xprv);
    const publicNode = lib_1.deriveHdPublicNode(crypto, privateNode);
    t.deepEqual(lib_1.deriveHdPath(crypto, privateNode, 'm'), privateNode);
    t.deepEqual(lib_1.deriveHdPath(crypto, publicNode, 'M'), publicNode);
    t.deepEqual(lib_1.deriveHdPath(crypto, privateNode, "m/0'/1"), Object.assign(Object.assign({}, lib_1.decodeHdPrivateKey(crypto, 'xprv9w8PdihBAeR4xgGYWWqBnmDTrpWEW1QjuYAUkR7A6X48q1iQVgN433aSFxQGgtureVz7cCyi5zfuMTtBF3AkanjtvNs9m8u2JobxNfphSi3').node), { parentIdentifier: lib_1.hexToBin('2f2bc501c943dd7f17904b612c090dd88270cc59') }));
    t.deepEqual(lib_1.deriveHdPath(crypto, publicNode, 'M/0/1/2/3'), lib_1.deriveHdPublicNode(crypto, lib_1.deriveHdPath(crypto, privateNode, 'm/0/1/2/3')));
    t.deepEqual(lib_1.deriveHdPath(crypto, privateNode, "m/0'/1'/2'/3'"), lib_1.deriveHdPath(crypto, privateNode, 'm/2147483648/2147483649/2147483650/2147483651'));
});
ava_1.default('[crypto] deriveHdPath: errors', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const { node: privateNode } = lib_1.decodeHdPrivateKey(crypto, xprv);
    const publicNode = lib_1.deriveHdPublicNode(crypto, privateNode);
    t.deepEqual(lib_1.deriveHdPath(crypto, privateNode, 'm/bad/1'), lib_1.HdNodeDerivationError.invalidDerivationPath);
    t.deepEqual(lib_1.deriveHdPath(crypto, privateNode, 'M'), lib_1.HdNodeDerivationError.invalidPrivateDerivationPrefix);
    t.deepEqual(lib_1.deriveHdPath(crypto, publicNode, 'm'), lib_1.HdNodeDerivationError.invalidPublicDerivationPrefix);
    t.deepEqual(lib_1.deriveHdPath(crypto, privateNode, 'm/0/4294967296/0'), lib_1.HdNodeDerivationError.childIndexExceedsMaximum);
    t.deepEqual(lib_1.deriveHdPath(crypto, publicNode, "M/0/0'/0"), lib_1.HdNodeDerivationError.hardenedDerivationRequiresPrivateNode);
    t.deepEqual(lib_1.deriveHdPath(crypto, publicNode, 'M/0/2147483648/0'), lib_1.HdNodeDerivationError.hardenedDerivationRequiresPrivateNode);
});
ava_1.default('[crypto] crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode', async (t) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const { node: parentPrivateNode } = lib_1.decodeHdPrivateKey(crypto, xprv);
    const parentPublicNode = lib_1.deriveHdPublicNode(crypto, parentPrivateNode);
    const nonHardenedChildNode = lib_1.deriveHdPath(crypto, parentPrivateNode, 'm/1234');
    const hardenedChildNode = lib_1.deriveHdPath(crypto, parentPrivateNode, "m/1234'");
    const hardenedChildPublicNode = lib_1.deriveHdPublicNode(crypto, hardenedChildNode);
    const nonHardenedGrandchildNode = lib_1.deriveHdPath(crypto, hardenedChildNode, 'm/1234');
    t.deepEqual(lib_1.crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode(crypto, parentPublicNode, nonHardenedChildNode), parentPrivateNode);
    t.deepEqual(lib_1.crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode(crypto, hardenedChildPublicNode, nonHardenedGrandchildNode), hardenedChildNode);
    t.deepEqual(lib_1.crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode(crypto, parentPublicNode, hardenedChildNode), lib_1.HdNodeCrackingError.cannotCrackHardenedDerivation);
});
// eslint-disable-next-line complexity
const bip32Vector = async (t, seedHex, path, hdPrivateKey, hdPublicKey
// eslint-disable-next-line max-params
) => {
    var _a, _b;
    const crypto = await lib_1.instantiateBIP32Crypto();
    const master = lib_1.deriveHdPrivateNodeFromSeed(crypto, lib_1.hexToBin(seedHex));
    if (!master.valid) {
        t.log(seedHex, master.invalidPrivateKey);
        t.fail('Astronomically rare hash found!');
        return;
    }
    const childNode = lib_1.deriveHdPath(crypto, master, path);
    if (typeof childNode === 'string') {
        t.fail(childNode);
        return;
    }
    const vectorXprv = lib_1.encodeHdPrivateKey(crypto, {
        network: 'mainnet',
        node: childNode,
    });
    t.deepEqual(vectorXprv, hdPrivateKey);
    const decodedPrivate = lib_1.decodeHdPrivateKey(crypto, hdPrivateKey);
    if (typeof decodedPrivate === 'string') {
        t.fail(decodedPrivate);
        return;
    }
    t.deepEqual((_a = childNode.parentIdentifier) === null || _a === void 0 ? void 0 : _a.slice(0, fingerprintLength), path === 'm' ? undefined : decodedPrivate.node.parentFingerprint);
    t.deepEqual(childNode, Object.assign(Object.assign({}, decodedPrivate.node), (path === 'm' ? {} : { parentIdentifier: childNode.parentIdentifier })));
    const decodedPublic = lib_1.decodeHdPublicKey(crypto, hdPublicKey);
    if (typeof decodedPublic === 'string') {
        t.fail(decodedPublic);
        return;
    }
    const publicNode = lib_1.deriveHdPublicNode(crypto, childNode);
    t.deepEqual((_b = publicNode.parentIdentifier) === null || _b === void 0 ? void 0 : _b.slice(0, fingerprintLength), path === 'm' ? undefined : decodedPublic.node.parentFingerprint);
    t.deepEqual(publicNode, Object.assign(Object.assign({}, decodedPublic.node), (path === 'm' ? {} : { parentIdentifier: publicNode.parentIdentifier })));
    const vectorXpub = lib_1.encodeHdPublicKey(crypto, {
        network: 'mainnet',
        node: publicNode,
    });
    t.deepEqual(vectorXpub, hdPublicKey);
};
// eslint-disable-next-line functional/immutable-data
bip32Vector.title = (title, _, path) => `[crypto] BIP32 Vector – ${title !== null && title !== void 0 ? title : ''}: ${path}`;
ava_1.default('#1.1', bip32Vector, '000102030405060708090a0b0c0d0e0f', 'm', 'xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi', 'xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8');
ava_1.default('#1.2', bip32Vector, '000102030405060708090a0b0c0d0e0f', "m/0'", 'xprv9uHRZZhk6KAJC1avXpDAp4MDc3sQKNxDiPvvkX8Br5ngLNv1TxvUxt4cV1rGL5hj6KCesnDYUhd7oWgT11eZG7XnxHrnYeSvkzY7d2bhkJ7', 'xpub68Gmy5EdvgibQVfPdqkBBCHxA5htiqg55crXYuXoQRKfDBFA1WEjWgP6LHhwBZeNK1VTsfTFUHCdrfp1bgwQ9xv5ski8PX9rL2dZXvgGDnw');
ava_1.default('#1.3', bip32Vector, '000102030405060708090a0b0c0d0e0f', "m/0'/1", 'xprv9wTYmMFdV23N2TdNG573QoEsfRrWKQgWeibmLntzniatZvR9BmLnvSxqu53Kw1UmYPxLgboyZQaXwTCg8MSY3H2EU4pWcQDnRnrVA1xe8fs', 'xpub6ASuArnXKPbfEwhqN6e3mwBcDTgzisQN1wXN9BJcM47sSikHjJf3UFHKkNAWbWMiGj7Wf5uMash7SyYq527Hqck2AxYysAA7xmALppuCkwQ');
ava_1.default('#1.4', bip32Vector, '000102030405060708090a0b0c0d0e0f', "m/0'/1/2'", 'xprv9z4pot5VBttmtdRTWfWQmoH1taj2axGVzFqSb8C9xaxKymcFzXBDptWmT7FwuEzG3ryjH4ktypQSAewRiNMjANTtpgP4mLTj34bhnZX7UiM', 'xpub6D4BDPcP2GT577Vvch3R8wDkScZWzQzMMUm3PWbmWvVJrZwQY4VUNgqFJPMM3No2dFDFGTsxxpG5uJh7n7epu4trkrX7x7DogT5Uv6fcLW5');
ava_1.default('#1.5', bip32Vector, '000102030405060708090a0b0c0d0e0f', "m/0'/1/2'/2", 'xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334', 'xpub6FHa3pjLCk84BayeJxFW2SP4XRrFd1JYnxeLeU8EqN3vDfZmbqBqaGJAyiLjTAwm6ZLRQUMv1ZACTj37sR62cfN7fe5JnJ7dh8zL4fiyLHV');
ava_1.default('#1.6', bip32Vector, '000102030405060708090a0b0c0d0e0f', "m/0'/1/2'/2/1000000000", 'xprvA41z7zogVVwxVSgdKUHDy1SKmdb533PjDz7J6N6mV6uS3ze1ai8FHa8kmHScGpWmj4WggLyQjgPie1rFSruoUihUZREPSL39UNdE3BBDu76', 'xpub6H1LXWLaKsWFhvm6RVpEL9P4KfRZSW7abD2ttkWP3SSQvnyA8FSVqNTEcYFgJS2UaFcxupHiYkro49S8yGasTvXEYBVPamhGW6cFJodrTHy');
ava_1.default('#2.1', bip32Vector, 'fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542', 'm', 'xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U', 'xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB');
ava_1.default('#2.2', bip32Vector, 'fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542', 'm/0', 'xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt', 'xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH');
ava_1.default('#2.3', bip32Vector, 'fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542', "m/0/2147483647'", 'xprv9wSp6B7kry3Vj9m1zSnLvN3xH8RdsPP1Mh7fAaR7aRLcQMKTR2vidYEeEg2mUCTAwCd6vnxVrcjfy2kRgVsFawNzmjuHc2YmYRmagcEPdU9', 'xpub6ASAVgeehLbnwdqV6UKMHVzgqAG8Gr6riv3Fxxpj8ksbH9ebxaEyBLZ85ySDhKiLDBrQSARLq1uNRts8RuJiHjaDMBU4Zn9h8LZNnBC5y4a');
ava_1.default('#2.4', bip32Vector, 'fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542', "m/0/2147483647'/1", 'xprv9zFnWC6h2cLgpmSA46vutJzBcfJ8yaJGg8cX1e5StJh45BBciYTRXSd25UEPVuesF9yog62tGAQtHjXajPPdbRCHuWS6T8XA2ECKADdw4Ef', 'xpub6DF8uhdarytz3FWdA8TvFSvvAh8dP3283MY7p2V4SeE2wyWmG5mg5EwVvmdMVCQcoNJxGoWaU9DCWh89LojfZ537wTfunKau47EL2dhHKon');
ava_1.default('#2.5', bip32Vector, 'fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542', "m/0/2147483647'/1/2147483646'", 'xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc', 'xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL');
ava_1.default('#2.6', bip32Vector, 'fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542', "m/0/2147483647'/1/2147483646'/2", 'xprvA2nrNbFZABcdryreWet9Ea4LvTJcGsqrMzxHx98MMrotbir7yrKCEXw7nadnHM8Dq38EGfSh6dqA9QWTyefMLEcBYJUuekgW4BYPJcr9E7j', 'xpub6FnCn6nSzZAw5Tw7cgR9bi15UV96gLZhjDstkXXxvCLsUXBGXPdSnLFbdpq8p9HmGsApME5hQTZ3emM2rnY5agb9rXpVGyy3bdW6EEgAtqt');
ava_1.default('#3.1', bip32Vector, '4b381541583be4423346c643850da4b320e46a87ae3d2a4e6da11eba819cd4acba45d239319ac14f863b8d5ab5a0d0c64d2e8a1e7d1457df2e5a3c51c73235be', 'm', 'xprv9s21ZrQH143K25QhxbucbDDuQ4naNntJRi4KUfWT7xo4EKsHt2QJDu7KXp1A3u7Bi1j8ph3EGsZ9Xvz9dGuVrtHHs7pXeTzjuxBrCmmhgC6', 'xpub661MyMwAqRbcEZVB4dScxMAdx6d4nFc9nvyvH3v4gJL378CSRZiYmhRoP7mBy6gSPSCYk6SzXPTf3ND1cZAceL7SfJ1Z3GC8vBgp2epUt13');
ava_1.default('#3.2', bip32Vector, '4b381541583be4423346c643850da4b320e46a87ae3d2a4e6da11eba819cd4acba45d239319ac14f863b8d5ab5a0d0c64d2e8a1e7d1457df2e5a3c51c73235be', "m/0'", 'xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L', 'xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y');
const fcBip32Path = () => ava_fast_check_1.fc
    .array(ava_fast_check_1.fc.integer(0, maximumChildIndex), 1, maximumDepth)
    .map((array) => `m/${array
    .map((i) => i > hardenedIndexOffset ? `${i - hardenedIndexOffset}'` : `${i}`)
    .join('/')}`);
ava_fast_check_1.testProp('[fast-check] [crypto] HD key derivation is equivalent to bitcore-lib-cash', [fcBip32Path()], async (t, path) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const privateNode = lib_1.decodeHdPrivateKey(crypto, xprv).node;
    const node = lib_1.deriveHdPath(crypto, privateNode, path);
    const publicNode = lib_1.deriveHdPublicNode(crypto, node);
    const resultPrv = lib_1.encodeHdPrivateKey(crypto, { network: 'mainnet', node });
    const resultPub = lib_1.encodeHdPublicKey(crypto, {
        network: 'mainnet',
        node: publicNode,
    });
    // eslint-disable-next-line new-cap, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
    const bitcoreResult = bitcoreLibCash.HDPrivateKey(xprv).deriveChild(path);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    const bitcorePrv = bitcoreResult.xprivkey;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    const bitcorePub = bitcoreResult.xpubkey;
    t.deepEqual(resultPrv, bitcorePrv);
    t.deepEqual(resultPub, bitcorePub);
}, { numRuns: 10 });
ava_fast_check_1.testProp('[fast-check] [crypto] encodeHdPublicKey <-> decodeHdPublicKey', [
    ava_fast_check_1.fc.boolean(),
    ava_fast_check_1.fc.integer(0, maximumDepth),
    ava_fast_check_1.fc.integer(0, maximumChildIndex),
    fcUint8Array(fingerprintLength, fingerprintLength),
    fcUint8Array(chainCodeLength, chainCodeLength),
    fcUint8Array(publicKeyLength, publicKeyLength),
], async (t, mainnet, depth, childIndex, parentFingerprint, chainCode, publicKey
// eslint-disable-next-line max-params
) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    const encoded = lib_1.encodeHdPublicKey(crypto, {
        network: mainnet ? 'mainnet' : 'testnet',
        node: {
            chainCode,
            childIndex,
            depth,
            parentFingerprint,
            publicKey,
        },
    });
    t.deepEqual(encoded, lib_1.encodeHdPublicKey(crypto, lib_1.decodeHdPublicKey(crypto, encoded)));
});
ava_fast_check_1.testProp('[fast-check] [crypto] encodeHdPrivateKey <-> decodeHdPrivateKey', [
    ava_fast_check_1.fc.boolean(),
    ava_fast_check_1.fc.integer(0, maximumDepth),
    ava_fast_check_1.fc.integer(0, maximumChildIndex),
    fcUint8Array(fingerprintLength, fingerprintLength),
    fcUint8Array(chainCodeLength, chainCodeLength),
    fcUint8Array(privateKeyLength, privateKeyLength),
], async (t, mainnet, depth, childIndex, parentFingerprint, chainCode, privateKey
// eslint-disable-next-line max-params
) => {
    if (!lib_1.validateSecp256k1PrivateKey(privateKey)) {
        t.pass();
        return;
    }
    const crypto = await lib_1.instantiateBIP32Crypto();
    const encoded = lib_1.encodeHdPrivateKey(crypto, {
        network: mainnet ? 'mainnet' : 'testnet',
        node: {
            chainCode,
            childIndex,
            depth,
            parentFingerprint,
            privateKey,
            valid: true,
        },
    });
    t.deepEqual(encoded, lib_1.encodeHdPrivateKey(crypto, lib_1.decodeHdPrivateKey(crypto, encoded)));
});
ava_fast_check_1.testProp('[fast-check] [crypto] derive non-hardened HD node <-> crack HD node', [
    ava_fast_check_1.fc.integer(0, maximumDepth),
    ava_fast_check_1.fc.integer(0, maximumNonHardenedIndex),
    fcUint8Array(fingerprintLength, fingerprintLength),
    fcUint8Array(chainCodeLength, chainCodeLength),
    fcUint8Array(privateKeyLength, privateKeyLength),
], async (t, depth, childIndexes, parentFingerprint, chainCode, privateKey
// eslint-disable-next-line max-params
) => {
    const crypto = await lib_1.instantiateBIP32Crypto();
    if (!lib_1.validateSecp256k1PrivateKey(privateKey)) {
        t.pass();
        return;
    }
    const parentXprv = lib_1.encodeHdPrivateKey(crypto, {
        network: 'mainnet',
        node: {
            chainCode,
            childIndex: childIndexes,
            depth,
            parentFingerprint,
            privateKey,
            valid: true,
        },
    });
    const { node: parentPrivateNode } = lib_1.decodeHdPrivateKey(crypto, parentXprv);
    const parentPublicNode = lib_1.deriveHdPublicNode(crypto, parentPrivateNode);
    const nonHardenedChildNode = lib_1.deriveHdPrivateNodeChild(crypto, parentPrivateNode, childIndexes);
    const crackedParentNode = lib_1.crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode(crypto, parentPublicNode, nonHardenedChildNode);
    const crackedXprv = lib_1.encodeHdPrivateKey(crypto, {
        network: 'mainnet',
        node: crackedParentNode,
    });
    t.deepEqual(parentXprv, crackedXprv);
});
//# sourceMappingURL=hd-key.spec.js.map