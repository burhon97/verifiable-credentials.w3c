"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAuthenticationProgramStateCommonEmpty = exports.createTransactionContextCommonTesting = exports.createTransactionContextCommonEmpty = exports.cloneAuthenticationProgramStateCommon = exports.createAuthenticationProgramStateCommon = exports.createTransactionContextCommon = exports.createAuthenticationProgramInternalStateCommon = exports.cloneStack = exports.commonOperations = exports.checkLimitsCommon = exports.undefinedOperation = exports.ConsensusCommon = void 0;
const transaction_serialization_1 = require("../../../transaction/transaction-serialization");
const arithmetic_1 = require("./arithmetic");
const bitwise_1 = require("./bitwise");
const combinators_1 = require("./combinators");
const crypto_1 = require("./crypto");
const errors_1 = require("./errors");
const flow_control_1 = require("./flow-control");
const nop_1 = require("./nop");
const opcodes_1 = require("./opcodes");
const push_1 = require("./push");
const splice_1 = require("./splice");
const stack_1 = require("./stack");
const time_1 = require("./time");
__exportStar(require("./arithmetic"), exports);
__exportStar(require("./bitwise"), exports);
__exportStar(require("./combinators"), exports);
__exportStar(require("./crypto"), exports);
__exportStar(require("./descriptions"), exports);
__exportStar(require("./encoding"), exports);
__exportStar(require("./errors"), exports);
__exportStar(require("./flow-control"), exports);
__exportStar(require("./nop"), exports);
__exportStar(require("./opcodes"), exports);
__exportStar(require("./push"), exports);
__exportStar(require("./signing-serialization"), exports);
__exportStar(require("./splice"), exports);
__exportStar(require("./stack"), exports);
__exportStar(require("./time"), exports);
__exportStar(require("./types"), exports);
var ConsensusCommon;
(function (ConsensusCommon) {
    /**
     * A.K.A. `MAX_SCRIPT_ELEMENT_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumStackItemLength"] = 520] = "maximumStackItemLength";
    ConsensusCommon[ConsensusCommon["maximumScriptNumberLength"] = 4] = "maximumScriptNumberLength";
    /**
     * A.K.A. `MAX_OPS_PER_SCRIPT`
     */
    ConsensusCommon[ConsensusCommon["maximumOperationCount"] = 201] = "maximumOperationCount";
    /**
     * A.K.A. `MAX_SCRIPT_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumBytecodeLength"] = 10000] = "maximumBytecodeLength";
    /**
     * A.K.A. `MAX_STACK_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumStackDepth"] = 1000] = "maximumStackDepth";
})(ConsensusCommon = exports.ConsensusCommon || (exports.ConsensusCommon = {}));
exports.undefinedOperation = () => ({
    undefined: combinators_1.conditionallyEvaluate((state) => errors_1.applyError(errors_1.AuthenticationErrorCommon.unknownOpcode, state)),
});
exports.checkLimitsCommon = (operation) => (state) => {
    const nextState = operation(state);
    return nextState.stack.length + nextState.alternateStack.length >
        ConsensusCommon.maximumStackDepth
        ? errors_1.applyError(errors_1.AuthenticationErrorCommon.exceededMaximumStackDepth, nextState)
        : nextState.operationCount > ConsensusCommon.maximumOperationCount
            ? errors_1.applyError(errors_1.AuthenticationErrorCommon.exceededMaximumOperationCount, nextState)
            : nextState;
};
exports.commonOperations = ({ flags, ripemd160, secp256k1, sha1, sha256, }) => {
    const unconditionalOperations = Object.assign(Object.assign(Object.assign({}, nop_1.disabledOperations()), push_1.pushOperations(flags)), combinators_1.mapOverOperations(flow_control_1.unconditionalFlowControlOperations(flags), combinators_1.incrementOperationCount));
    const conditionalOperations = combinators_1.mapOverOperations(Object.assign(Object.assign({}, push_1.pushNumberOperations()), { [opcodes_1.OpcodesCommon.OP_RESERVED]: flow_control_1.reservedOperation() }), combinators_1.conditionallyEvaluate);
    const incrementingOperations = combinators_1.mapOverOperations(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, arithmetic_1.arithmeticOperations(flags)), bitwise_1.bitwiseOperations()), crypto_1.cryptoOperations({
        flags,
        ripemd160,
        secp256k1,
        sha1,
        sha256,
    })), flow_control_1.conditionalFlowControlOperations()), stack_1.stackOperations(flags)), splice_1.spliceOperations()), time_1.timeOperations(flags)), nop_1.nonOperations(flags)), combinators_1.conditionallyEvaluate, combinators_1.incrementOperationCount);
    return combinators_1.mapOverOperations(Object.assign(Object.assign(Object.assign({}, unconditionalOperations), incrementingOperations), conditionalOperations), exports.checkLimitsCommon);
};
exports.cloneStack = (stack) => stack.reduce((newStack, element) => {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    newStack.push(element.slice());
    return newStack;
}, []);
exports.createAuthenticationProgramInternalStateCommon = ({ instructions, stack = [], }) => ({
    alternateStack: [],
    executionStack: [],
    instructions,
    ip: 0,
    lastCodeSeparator: -1,
    operationCount: 0,
    signatureOperationsCount: 0,
    signedMessages: [],
    stack,
});
exports.createTransactionContextCommon = (program) => ({
    correspondingOutput: program.inputIndex < program.spendingTransaction.outputs.length
        ? transaction_serialization_1.encodeOutput(program.spendingTransaction.outputs[program.inputIndex])
        : undefined,
    locktime: program.spendingTransaction.locktime,
    outpointIndex: program.spendingTransaction.inputs[program.inputIndex].outpointIndex,
    outpointTransactionHash: program.spendingTransaction.inputs[program.inputIndex]
        .outpointTransactionHash,
    outputValue: program.sourceOutput.satoshis,
    sequenceNumber: program.spendingTransaction.inputs[program.inputIndex].sequenceNumber,
    transactionOutpoints: transaction_serialization_1.encodeOutpoints(program.spendingTransaction.inputs),
    transactionOutputs: transaction_serialization_1.encodeOutputsForSigning(program.spendingTransaction.outputs),
    transactionSequenceNumbers: transaction_serialization_1.encodeSequenceNumbersForSigning(program.spendingTransaction.inputs),
    version: program.spendingTransaction.version,
});
exports.createAuthenticationProgramStateCommon = ({ transactionContext, instructions, stack, }) => (Object.assign(Object.assign({}, exports.createAuthenticationProgramInternalStateCommon({
    instructions,
    stack,
})), transactionContext));
/**
 * Note: this implementation does not safely clone elements within array
 * properties. Mutating values within arrays will mutate those values in cloned
 * program states.
 */
exports.cloneAuthenticationProgramStateCommon = (state) => (Object.assign(Object.assign({}, (state.error === undefined ? {} : { error: state.error })), { alternateStack: state.alternateStack.slice(), correspondingOutput: state.correspondingOutput, executionStack: state.executionStack.slice(), instructions: state.instructions.slice(), ip: state.ip, lastCodeSeparator: state.lastCodeSeparator, locktime: state.locktime, operationCount: state.operationCount, outpointIndex: state.outpointIndex, outpointTransactionHash: state.outpointTransactionHash.slice(), outputValue: state.outputValue, sequenceNumber: state.sequenceNumber, signatureOperationsCount: state.signatureOperationsCount, signedMessages: state.signedMessages.slice(), stack: state.stack.slice(), transactionOutpoints: state.transactionOutpoints, transactionOutputs: state.transactionOutputs, transactionSequenceNumbers: state.transactionSequenceNumbers, version: state.version }));
const sha256HashLength = 32;
const outputValueLength = 8;
/**
 * This is a meaningless but complete `TransactionContextCommon` which uses `0`
 * values for each property.
 */
exports.createTransactionContextCommonEmpty = () => ({
    correspondingOutput: Uint8Array.of(0),
    locktime: 0,
    outpointIndex: 0,
    outpointTransactionHash: new Uint8Array(sha256HashLength),
    outputValue: new Uint8Array(outputValueLength),
    sequenceNumber: 0,
    transactionOutpoints: Uint8Array.of(0),
    transactionOutputs: Uint8Array.of(0),
    transactionSequenceNumbers: Uint8Array.of(0),
    version: 0,
});
const correspondingOutput = 1;
const transactionOutpoints = 2;
const transactionOutputs = 3;
const transactionSequenceNumbers = 4;
const outpointTransactionHashFill = 5;
/**
 * This is a meaningless but complete `TransactionContextCommon` which uses a
 * different value for each property. This is useful for testing and debugging.
 */
exports.createTransactionContextCommonTesting = () => ({
    correspondingOutput: Uint8Array.of(correspondingOutput),
    locktime: 0,
    outpointIndex: 0,
    outpointTransactionHash: new Uint8Array(sha256HashLength).fill(outpointTransactionHashFill),
    outputValue: new Uint8Array(outputValueLength),
    sequenceNumber: 0,
    transactionOutpoints: Uint8Array.of(transactionOutpoints),
    transactionOutputs: Uint8Array.of(transactionOutputs),
    transactionSequenceNumbers: Uint8Array.of(transactionSequenceNumbers),
    version: 0,
});
/**
 * Create an "empty" common authentication program state, suitable for testing a
 * VM/compiler.
 */
exports.createAuthenticationProgramStateCommonEmpty = ({ instructions, stack = [], }) => (Object.assign(Object.assign({}, exports.createAuthenticationProgramInternalStateCommon({ instructions, stack })), exports.createTransactionContextCommonEmpty()));
//# sourceMappingURL=common.js.map