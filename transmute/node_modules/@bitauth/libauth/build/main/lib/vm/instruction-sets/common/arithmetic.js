"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arithmeticOperations = exports.opWithin = exports.opMax = exports.opMin = exports.opGreaterThanOrEqual = exports.opGreaterThan = exports.opLessThanOrEqual = exports.opLessThan = exports.opNumNotEqual = exports.opNumEqualVerify = exports.opNumEqual = exports.opBoolOr = exports.opBoolAnd = exports.opSub = exports.opAdd = exports.op0NotEqual = exports.opNot = exports.opAbs = exports.opNegate = exports.op1Sub = exports.op1Add = void 0;
const combinators_1 = require("./combinators");
const flow_control_1 = require("./flow-control");
const opcodes_1 = require("./opcodes");
const types_1 = require("./types");
exports.op1Add = ({ requireMinimalEncoding, }) => (state) => combinators_1.useOneScriptNumber(state, (nextState, [value]) => combinators_1.pushToStack(nextState, types_1.bigIntToScriptNumber(value + BigInt(1))), { requireMinimalEncoding });
exports.op1Sub = ({ requireMinimalEncoding, }) => (state) => combinators_1.useOneScriptNumber(state, (nextState, [value]) => combinators_1.pushToStack(nextState, types_1.bigIntToScriptNumber(value - BigInt(1))), { requireMinimalEncoding });
exports.opNegate = ({ requireMinimalEncoding, }) => (state) => combinators_1.useOneScriptNumber(state, (nextState, [value]) => combinators_1.pushToStack(nextState, types_1.bigIntToScriptNumber(-value)), { requireMinimalEncoding });
exports.opAbs = ({ requireMinimalEncoding, }) => (state) => combinators_1.useOneScriptNumber(state, (nextState, [value]) => combinators_1.pushToStack(nextState, types_1.bigIntToScriptNumber(value < 0 ? -value : value)), { requireMinimalEncoding });
exports.opNot = ({ requireMinimalEncoding, }) => (state) => combinators_1.useOneScriptNumber(state, (nextState, [value]) => combinators_1.pushToStack(nextState, value === BigInt(0)
    ? types_1.bigIntToScriptNumber(BigInt(1))
    : types_1.bigIntToScriptNumber(BigInt(0))), { requireMinimalEncoding });
exports.op0NotEqual = ({ requireMinimalEncoding, }) => (state) => combinators_1.useOneScriptNumber(state, (nextState, [value]) => combinators_1.pushToStack(nextState, value === BigInt(0)
    ? types_1.bigIntToScriptNumber(BigInt(0))
    : types_1.bigIntToScriptNumber(BigInt(1))), { requireMinimalEncoding });
exports.opAdd = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.bigIntToScriptNumber(firstValue + secondValue)), { requireMinimalEncoding });
exports.opSub = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.bigIntToScriptNumber(firstValue - secondValue)), { requireMinimalEncoding });
exports.opBoolAnd = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.booleanToScriptNumber(firstValue !== BigInt(0) && secondValue !== BigInt(0))), { requireMinimalEncoding });
exports.opBoolOr = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.booleanToScriptNumber(firstValue !== BigInt(0) || secondValue !== BigInt(0))), { requireMinimalEncoding });
exports.opNumEqual = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.booleanToScriptNumber(firstValue === secondValue)), { requireMinimalEncoding });
exports.opNumEqualVerify = (flags) => combinators_1.combineOperations(exports.opNumEqual(flags), flow_control_1.opVerify());
exports.opNumNotEqual = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.booleanToScriptNumber(firstValue !== secondValue)), { requireMinimalEncoding });
exports.opLessThan = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.booleanToScriptNumber(firstValue < secondValue)), { requireMinimalEncoding });
exports.opLessThanOrEqual = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.booleanToScriptNumber(firstValue <= secondValue)), { requireMinimalEncoding });
exports.opGreaterThan = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.booleanToScriptNumber(firstValue > secondValue)), { requireMinimalEncoding });
exports.opGreaterThanOrEqual = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.booleanToScriptNumber(firstValue >= secondValue)), { requireMinimalEncoding });
exports.opMin = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.bigIntToScriptNumber(firstValue < secondValue ? firstValue : secondValue)), { requireMinimalEncoding });
exports.opMax = ({ requireMinimalEncoding, }) => (state) => combinators_1.useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => combinators_1.pushToStack(nextState, types_1.bigIntToScriptNumber(firstValue > secondValue ? firstValue : secondValue)), { requireMinimalEncoding });
exports.opWithin = ({ requireMinimalEncoding, }) => (state) => combinators_1.useThreeScriptNumbers(state, (nextState, [firstValue, secondValue, thirdValue]) => combinators_1.pushToStack(nextState, types_1.booleanToScriptNumber(secondValue <= firstValue && firstValue < thirdValue)), { requireMinimalEncoding });
exports.arithmeticOperations = (flags) => ({
    [opcodes_1.OpcodesCommon.OP_1ADD]: exports.op1Add(flags),
    [opcodes_1.OpcodesCommon.OP_1SUB]: exports.op1Sub(flags),
    [opcodes_1.OpcodesCommon.OP_NEGATE]: exports.opNegate(flags),
    [opcodes_1.OpcodesCommon.OP_ABS]: exports.opAbs(flags),
    [opcodes_1.OpcodesCommon.OP_NOT]: exports.opNot(flags),
    [opcodes_1.OpcodesCommon.OP_0NOTEQUAL]: exports.op0NotEqual(flags),
    [opcodes_1.OpcodesCommon.OP_ADD]: exports.opAdd(flags),
    [opcodes_1.OpcodesCommon.OP_SUB]: exports.opSub(flags),
    [opcodes_1.OpcodesCommon.OP_BOOLAND]: exports.opBoolAnd(flags),
    [opcodes_1.OpcodesCommon.OP_BOOLOR]: exports.opBoolOr(flags),
    [opcodes_1.OpcodesCommon.OP_NUMEQUAL]: exports.opNumEqual(flags),
    [opcodes_1.OpcodesCommon.OP_NUMEQUALVERIFY]: exports.opNumEqualVerify(flags),
    [opcodes_1.OpcodesCommon.OP_NUMNOTEQUAL]: exports.opNumNotEqual(flags),
    [opcodes_1.OpcodesCommon.OP_LESSTHAN]: exports.opLessThan(flags),
    [opcodes_1.OpcodesCommon.OP_LESSTHANOREQUAL]: exports.opLessThanOrEqual(flags),
    [opcodes_1.OpcodesCommon.OP_GREATERTHAN]: exports.opGreaterThan(flags),
    [opcodes_1.OpcodesCommon.OP_GREATERTHANOREQUAL]: exports.opGreaterThanOrEqual(flags),
    [opcodes_1.OpcodesCommon.OP_MIN]: exports.opMin(flags),
    [opcodes_1.OpcodesCommon.OP_MAX]: exports.opMax(flags),
    [opcodes_1.OpcodesCommon.OP_WITHIN]: exports.opWithin(flags),
});
//# sourceMappingURL=arithmetic.js.map