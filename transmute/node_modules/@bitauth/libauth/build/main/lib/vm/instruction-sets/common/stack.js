"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stackOperations = exports.opTuck = exports.opSwap = exports.opRot = exports.opRoll = exports.opPick = exports.opOver = exports.opNip = exports.opDup = exports.opDrop = exports.opDepth = exports.opIfDup = exports.op2Swap = exports.op2Rot = exports.op2Over = exports.op3Dup = exports.op2Dup = exports.op2Drop = exports.opFromAltStack = exports.opToAltStack = void 0;
const combinators_1 = require("./combinators");
const errors_1 = require("./errors");
const opcodes_1 = require("./opcodes");
const types_1 = require("./types");
exports.opToAltStack = () => (state) => combinators_1.useOneStackItem(state, (nextState, [item]) => {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    nextState.alternateStack.push(item);
    return nextState;
});
exports.opFromAltStack = () => (state) => {
    // eslint-disable-next-line functional/immutable-data
    const item = state.alternateStack.pop();
    if (item === undefined) {
        return errors_1.applyError(errors_1.AuthenticationErrorCommon.emptyAlternateStack, state);
    }
    return combinators_1.pushToStack(state, item);
};
exports.op2Drop = () => (state) => combinators_1.useTwoStackItems(state, (nextState) => nextState);
exports.op2Dup = () => (state) => combinators_1.useTwoStackItems(state, (nextState, [a, b]) => combinators_1.pushToStack(nextState, a, b, a.slice(), b.slice()));
exports.op3Dup = () => (state) => combinators_1.useThreeStackItems(state, (nextState, [a, b, c]) => combinators_1.pushToStack(nextState, a, b, c, a.slice(), b.slice(), c.slice()));
exports.op2Over = () => (state) => combinators_1.useFourStackItems(state, (nextState, [a, b, c, d]) => combinators_1.pushToStack(nextState, a, b, c, d, a.slice(), b.slice()));
exports.op2Rot = () => (state) => combinators_1.useSixStackItems(state, (nextState, [a, b, c, d, e, f]) => combinators_1.pushToStack(nextState, c, d, e, f, a, b));
exports.op2Swap = () => (state) => combinators_1.useFourStackItems(state, (nextState, [a, b, c, d]) => combinators_1.pushToStack(nextState, c, d, a, b));
exports.opIfDup = () => (state) => combinators_1.useOneStackItem(state, (nextState, [item]) => combinators_1.pushToStack(nextState, ...(types_1.stackItemIsTruthy(item) ? [item, item.slice()] : [item])));
exports.opDepth = () => (state) => combinators_1.pushToStack(state, types_1.bigIntToScriptNumber(BigInt(state.stack.length)));
exports.opDrop = () => (state) => combinators_1.useOneStackItem(state, (nextState) => nextState);
exports.opDup = () => (state) => combinators_1.useOneStackItem(state, (nextState, [item]) => combinators_1.pushToStack(nextState, item, item.slice()));
exports.opNip = () => (state) => combinators_1.useTwoStackItems(state, (nextState, [, b]) => combinators_1.pushToStack(nextState, b));
exports.opOver = () => (state) => combinators_1.useTwoStackItems(state, (nextState, [a, b]) => combinators_1.pushToStack(nextState, a, b, a.slice()));
exports.opPick = ({ requireMinimalEncoding, }) => (state) => combinators_1.useOneScriptNumber(state, (nextState, depth) => {
    const item = nextState.stack[nextState.stack.length - 1 - Number(depth)];
    if (item === undefined) {
        return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidStackIndex, state);
    }
    return combinators_1.pushToStack(nextState, item.slice());
}, { requireMinimalEncoding });
exports.opRoll = ({ requireMinimalEncoding, }) => (state) => combinators_1.useOneScriptNumber(state, (nextState, depth) => {
    const index = nextState.stack.length - 1 - Number(depth);
    if (index < 0 || index > nextState.stack.length - 1) {
        return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidStackIndex, state);
    }
    // eslint-disable-next-line functional/immutable-data
    return combinators_1.pushToStack(nextState, nextState.stack.splice(index, 1)[0]);
}, { requireMinimalEncoding });
exports.opRot = () => (state) => combinators_1.useThreeStackItems(state, (nextState, [a, b, c]) => combinators_1.pushToStack(nextState, b, c, a));
exports.opSwap = () => (state) => combinators_1.useTwoStackItems(state, (nextState, [a, b]) => combinators_1.pushToStack(nextState, b, a));
exports.opTuck = () => (state) => combinators_1.useTwoStackItems(state, (nextState, [a, b]) => combinators_1.pushToStack(nextState, b.slice(), a, b));
exports.stackOperations = (flags) => ({
    [opcodes_1.OpcodesCommon.OP_TOALTSTACK]: exports.opToAltStack(),
    [opcodes_1.OpcodesCommon.OP_FROMALTSTACK]: exports.opFromAltStack(),
    [opcodes_1.OpcodesCommon.OP_2DROP]: exports.op2Drop(),
    [opcodes_1.OpcodesCommon.OP_2DUP]: exports.op2Dup(),
    [opcodes_1.OpcodesCommon.OP_3DUP]: exports.op3Dup(),
    [opcodes_1.OpcodesCommon.OP_2OVER]: exports.op2Over(),
    [opcodes_1.OpcodesCommon.OP_2ROT]: exports.op2Rot(),
    [opcodes_1.OpcodesCommon.OP_2SWAP]: exports.op2Swap(),
    [opcodes_1.OpcodesCommon.OP_IFDUP]: exports.opIfDup(),
    [opcodes_1.OpcodesCommon.OP_DEPTH]: exports.opDepth(),
    [opcodes_1.OpcodesCommon.OP_DROP]: exports.opDrop(),
    [opcodes_1.OpcodesCommon.OP_DUP]: exports.opDup(),
    [opcodes_1.OpcodesCommon.OP_NIP]: exports.opNip(),
    [opcodes_1.OpcodesCommon.OP_OVER]: exports.opOver(),
    [opcodes_1.OpcodesCommon.OP_PICK]: exports.opPick(flags),
    [opcodes_1.OpcodesCommon.OP_ROLL]: exports.opRoll(flags),
    [opcodes_1.OpcodesCommon.OP_ROT]: exports.opRot(),
    [opcodes_1.OpcodesCommon.OP_SWAP]: exports.opSwap(),
    [opcodes_1.OpcodesCommon.OP_TUCK]: exports.opTuck(),
});
//# sourceMappingURL=stack.js.map