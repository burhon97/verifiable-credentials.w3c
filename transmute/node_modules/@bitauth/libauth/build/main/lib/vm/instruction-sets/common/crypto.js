"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cryptoOperations = exports.opCheckMultiSigVerify = exports.opCheckSigVerify = exports.opCheckMultiSig = exports.opCheckSig = exports.opCodeSeparator = exports.opHash256 = exports.opHash160 = exports.opSha256 = exports.opSha1 = exports.opRipemd160 = void 0;
const bch_types_1 = require("../bch/bch-types");
const instruction_sets_utils_1 = require("../instruction-sets-utils");
const combinators_1 = require("./combinators");
const common_1 = require("./common");
const encoding_1 = require("./encoding");
const errors_1 = require("./errors");
const flow_control_1 = require("./flow-control");
const opcodes_1 = require("./opcodes");
const signing_serialization_1 = require("./signing-serialization");
exports.opRipemd160 = ({ ripemd160, }) => (state) => combinators_1.useOneStackItem(state, (nextState, [value]) => combinators_1.pushToStack(nextState, ripemd160.hash(value)));
exports.opSha1 = ({ sha1, }) => (state) => combinators_1.useOneStackItem(state, (nextState, [value]) => combinators_1.pushToStack(nextState, sha1.hash(value)));
exports.opSha256 = ({ sha256, }) => (state) => combinators_1.useOneStackItem(state, (nextState, [value]) => combinators_1.pushToStack(nextState, sha256.hash(value)));
exports.opHash160 = ({ ripemd160, sha256, }) => (state) => combinators_1.useOneStackItem(state, (nextState, [value]) => combinators_1.pushToStack(nextState, ripemd160.hash(sha256.hash(value))));
exports.opHash256 = ({ sha256, }) => (state) => combinators_1.useOneStackItem(state, (nextState, [value]) => combinators_1.pushToStack(nextState, sha256.hash(sha256.hash(value))));
exports.opCodeSeparator = () => (state) => {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    state.lastCodeSeparator = state.ip;
    return state;
};
exports.opCheckSig = ({ flags, secp256k1, sha256, }) => (s) => 
// eslint-disable-next-line complexity
combinators_1.useTwoStackItems(s, (state, [bitcoinEncodedSignature, publicKey]) => {
    if (!encoding_1.isValidPublicKeyEncoding(publicKey)) {
        return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidPublicKeyEncoding, state);
    }
    if (!encoding_1.isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature)) {
        return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidSignatureEncoding, state);
    }
    const coveredBytecode = instruction_sets_utils_1.serializeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
    const { signingSerializationType, signature } = encoding_1.decodeBitcoinSignature(bitcoinEncodedSignature);
    const serialization = signing_serialization_1.generateSigningSerializationBCH({
        correspondingOutput: state.correspondingOutput,
        coveredBytecode,
        locktime: state.locktime,
        outpointIndex: state.outpointIndex,
        outpointTransactionHash: state.outpointTransactionHash,
        outputValue: state.outputValue,
        sequenceNumber: state.sequenceNumber,
        sha256,
        signingSerializationType,
        transactionOutpoints: state.transactionOutpoints,
        transactionOutputs: state.transactionOutputs,
        transactionSequenceNumbers: state.transactionSequenceNumbers,
        version: state.version,
    });
    const digest = sha256.hash(sha256.hash(serialization));
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    state.signedMessages.push(serialization);
    const useSchnorr = signature.length === bch_types_1.ConsensusBCH.schnorrSignatureLength;
    const success = useSchnorr
        ? secp256k1.verifySignatureSchnorr(signature, publicKey, digest)
        : secp256k1.verifySignatureDERLowS(signature, publicKey, digest);
    return !success &&
        flags.requireNullSignatureFailures &&
        signature.length !== 0
        ? errors_1.applyError(errors_1.AuthenticationErrorCommon.nonNullSignatureFailure, state)
        : combinators_1.pushToStack(state, common_1.booleanToScriptNumber(success));
});
exports.opCheckMultiSig = ({ flags: { requireMinimalEncoding, requireBugValueZero, requireNullSignatureFailures, }, secp256k1, sha256, }) => (s) => combinators_1.useOneScriptNumber(s, (state, publicKeysValue) => {
    const potentialPublicKeys = Number(publicKeysValue);
    if (potentialPublicKeys < 0) {
        return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidNaturalNumber, state);
    }
    if (potentialPublicKeys > 20 /* maximumPublicKeys */) {
        return errors_1.applyError(errors_1.AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount, state);
    }
    const publicKeys = 
    // eslint-disable-next-line functional/immutable-data
    potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : [];
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    state.operationCount += potentialPublicKeys;
    return state.operationCount > common_1.ConsensusCommon.maximumOperationCount
        ? errors_1.applyError(errors_1.AuthenticationErrorCommon.exceededMaximumOperationCount, state)
        : combinators_1.useOneScriptNumber(state, (nextState, approvingKeys) => {
            const requiredApprovingPublicKeys = Number(approvingKeys);
            if (requiredApprovingPublicKeys < 0) {
                return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidNaturalNumber, nextState);
            }
            if (requiredApprovingPublicKeys > potentialPublicKeys) {
                return errors_1.applyError(errors_1.AuthenticationErrorCommon.insufficientPublicKeys, nextState);
            }
            const signatures = requiredApprovingPublicKeys > 0
                ? // eslint-disable-next-line functional/immutable-data
                    nextState.stack.splice(-requiredApprovingPublicKeys)
                : [];
            return combinators_1.useOneStackItem(nextState, 
            // eslint-disable-next-line complexity
            (finalState, [protocolBugValue]) => {
                if (requireBugValueZero && protocolBugValue.length !== 0) {
                    return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidProtocolBugValue, finalState);
                }
                const coveredBytecode = instruction_sets_utils_1.serializeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
                let approvingPublicKeys = 0; // eslint-disable-line functional/no-let
                let remainingSignatures = signatures.length; // eslint-disable-line functional/no-let
                let remainingPublicKeys = publicKeys.length; // eslint-disable-line functional/no-let
                // eslint-disable-next-line functional/no-loop-statement
                while (remainingSignatures > 0 &&
                    remainingPublicKeys > 0 &&
                    approvingPublicKeys + remainingPublicKeys >=
                        remainingSignatures &&
                    approvingPublicKeys !== requiredApprovingPublicKeys) {
                    const publicKey = publicKeys[remainingPublicKeys - 1];
                    const bitcoinEncodedSignature = signatures[remainingSignatures - 1];
                    if (!encoding_1.isValidPublicKeyEncoding(publicKey)) {
                        return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidPublicKeyEncoding, finalState);
                    }
                    if (!encoding_1.isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature)) {
                        return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidSignatureEncoding, finalState);
                    }
                    const { signingSerializationType, signature, } = encoding_1.decodeBitcoinSignature(bitcoinEncodedSignature);
                    const serialization = signing_serialization_1.generateSigningSerializationBCH({
                        correspondingOutput: state.correspondingOutput,
                        coveredBytecode,
                        locktime: state.locktime,
                        outpointIndex: state.outpointIndex,
                        outpointTransactionHash: state.outpointTransactionHash,
                        outputValue: state.outputValue,
                        sequenceNumber: state.sequenceNumber,
                        sha256,
                        signingSerializationType,
                        transactionOutpoints: state.transactionOutpoints,
                        transactionOutputs: state.transactionOutputs,
                        transactionSequenceNumbers: state.transactionSequenceNumbers,
                        version: state.version,
                    });
                    const digest = sha256.hash(sha256.hash(serialization));
                    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
                    finalState.signedMessages.push(serialization);
                    if (signature.length === bch_types_1.ConsensusBCH.schnorrSignatureLength) {
                        return errors_1.applyError(errors_1.AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig, finalState);
                    }
                    const signed = secp256k1.verifySignatureDERLowS(signature, publicKey, digest);
                    // eslint-disable-next-line functional/no-conditional-statement
                    if (signed) {
                        approvingPublicKeys += 1; // eslint-disable-line functional/no-expression-statement
                        remainingSignatures -= 1; // eslint-disable-line functional/no-expression-statement
                    }
                    remainingPublicKeys -= 1; // eslint-disable-line functional/no-expression-statement
                }
                const success = approvingPublicKeys === requiredApprovingPublicKeys;
                if (!success &&
                    requireNullSignatureFailures &&
                    !signatures.every((signature) => signature.length === 0)) {
                    return errors_1.applyError(errors_1.AuthenticationErrorCommon.nonNullSignatureFailure, finalState);
                }
                return combinators_1.pushToStack(finalState, common_1.booleanToScriptNumber(success));
            });
        }, { requireMinimalEncoding });
}, { requireMinimalEncoding });
exports.opCheckSigVerify = ({ flags, secp256k1, sha256, }) => combinators_1.combineOperations(exports.opCheckSig({ flags, secp256k1, sha256 }), flow_control_1.opVerify());
exports.opCheckMultiSigVerify = ({ flags, secp256k1, sha256, }) => combinators_1.combineOperations(exports.opCheckMultiSig({ flags, secp256k1, sha256 }), flow_control_1.opVerify());
exports.cryptoOperations = ({ flags, ripemd160, secp256k1, sha1, sha256, }) => ({
    [opcodes_1.OpcodesCommon.OP_RIPEMD160]: exports.opRipemd160({
        ripemd160,
    }),
    [opcodes_1.OpcodesCommon.OP_SHA1]: exports.opSha1({ sha1 }),
    [opcodes_1.OpcodesCommon.OP_SHA256]: exports.opSha256({ sha256 }),
    [opcodes_1.OpcodesCommon.OP_HASH160]: exports.opHash160({
        ripemd160,
        sha256,
    }),
    [opcodes_1.OpcodesCommon.OP_HASH256]: exports.opHash256({ sha256 }),
    [opcodes_1.OpcodesCommon.OP_CODESEPARATOR]: exports.opCodeSeparator(),
    [opcodes_1.OpcodesCommon.OP_CHECKSIG]: exports.opCheckSig({
        flags,
        secp256k1,
        sha256,
    }),
    [opcodes_1.OpcodesCommon.OP_CHECKSIGVERIFY]: exports.opCheckSigVerify({
        flags,
        secp256k1,
        sha256,
    }),
    [opcodes_1.OpcodesCommon.OP_CHECKMULTISIG]: exports.opCheckMultiSig({
        flags,
        secp256k1,
        sha256,
    }),
    [opcodes_1.OpcodesCommon.OP_CHECKMULTISIGVERIFY]: exports.opCheckMultiSigVerify({ flags, secp256k1, sha256 }),
});
//# sourceMappingURL=crypto.js.map