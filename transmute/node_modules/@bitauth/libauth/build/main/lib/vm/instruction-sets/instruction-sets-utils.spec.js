"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable functional/no-expression-statement, @typescript-eslint/no-magic-numbers, functional/immutable-data */
const ava_1 = __importDefault(require("ava"));
const ava_fast_check_1 = require("ava-fast-check");
const lib_1 = require("../../lib");
ava_1.default('Each Opcodes enum contains a single instruction for 0-255', (t) => {
    const expected = lib_1.range(256);
    const names = (keys) => keys.filter((k) => isNaN(parseInt(k, 10)));
    const numbers = (keys) => keys.map((k) => parseInt(k, 10)).filter((k) => !isNaN(k));
    const bch = Object.keys(lib_1.OpcodesBCH);
    t.deepEqual(numbers(bch), expected);
    t.deepEqual(names(bch).length, expected.length);
    const btc = Object.keys(lib_1.OpcodesBTC);
    t.deepEqual(numbers(btc), expected);
    t.deepEqual(names(btc).length, expected.length);
});
const defToFixtures = (tests) => Object.entries(tests).map((entry) => {
    const [fullHex, { asm }] = entry;
    const [, hex] = fullHex.split('0x');
    const script = lib_1.hexToBin(hex);
    // eslint-disable-next-line complexity
    const object = entry[1].parse.map((set) => (Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ opcode: set[0] }, (set.length > 2 ? { malformed: true } : undefined)), (set[1] === undefined ? undefined : { data: lib_1.hexToBin(set[1]) })), (set[2] === undefined ? undefined : { expectedDataBytes: set[2] })), (set[3] === undefined ? undefined : { length: lib_1.hexToBin(set[3]) })), (set[4] === undefined ? undefined : { expectedLengthBytes: set[4] }))));
    return { asm, hex, object, script };
});
const wellFormedScripts = {
    '0x00': {
        asm: 'OP_0',
        parse: [[0, '']],
    },
    '0x0001010202020303030376': {
        asm: 'OP_0 OP_PUSHBYTES_1 0x01 OP_PUSHBYTES_2 0x0202 OP_PUSHBYTES_3 0x030303 OP_DUP',
        parse: [[0, ''], [1, '01'], [2, '0202'], [3, '030303'], [118]],
    },
    '0x410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3ac': {
        asm: 'OP_PUSHBYTES_65 0x0411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3 OP_CHECKSIG',
        parse: [
            [
                0x41,
                '0411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3',
            ],
            [0xac],
        ],
    },
    '0x4c020304': {
        asm: 'OP_PUSHDATA_1 2 0x0304',
        parse: [[0x4c, '0304']],
    },
    '0x76a91411b366edfc0a8b66feebae5c2e25a7b6a5d1cf3188ac': {
        asm: 'OP_DUP OP_HASH160 OP_PUSHBYTES_20 0x11b366edfc0a8b66feebae5c2e25a7b6a5d1cf31 OP_EQUALVERIFY OP_CHECKSIG',
        parse: [
            [0x76],
            [0xa9],
            [0x14, '11b366edfc0a8b66feebae5c2e25a7b6a5d1cf31'],
            [0x88],
            [0xac],
        ],
    },
};
const malFormedPushes = {
    '0x01': {
        asm: 'OP_PUSHBYTES_1 [missing 1 byte]',
        parse: [[0x01, '', 1]],
    },
    '0x0201': {
        asm: 'OP_PUSHBYTES_2 0x01[missing 1 byte]',
        parse: [[0x02, '01', 2]],
    },
    '0x4b': {
        asm: 'OP_PUSHBYTES_75 [missing 75 bytes]',
        parse: [[0x4b, '', 75]],
    },
    '0x4c': {
        asm: 'OP_PUSHDATA_1 [missing 1 byte]',
        parse: [[0x4c, undefined, undefined, '', 1]],
    },
    '0x4c02': {
        asm: 'OP_PUSHDATA_1 2 [missing 2 bytes]',
        parse: [[0x4c, '', 2]],
    },
    '0x4d': {
        asm: 'OP_PUSHDATA_2 [missing 2 bytes]',
        parse: [[0x4d, undefined, undefined, '', 2]],
    },
    '0x4d01': {
        asm: 'OP_PUSHDATA_2 0x01[missing 1 byte]',
        parse: [[0x4d, undefined, undefined, '01', 2]],
    },
    '0x4d0101': {
        asm: 'OP_PUSHDATA_2 257 [missing 257 bytes]',
        parse: [[0x4d, '', 257]],
    },
    '0x4d010101': {
        asm: 'OP_PUSHDATA_2 257 0x01[missing 256 bytes]',
        parse: [[0x4d, '01', 257]],
    },
    '0x4e': {
        asm: 'OP_PUSHDATA_4 [missing 4 bytes]',
        parse: [[0x4e, undefined, undefined, '', 4]],
    },
    '0x4e01': {
        asm: 'OP_PUSHDATA_4 0x01[missing 3 bytes]',
        parse: [[0x4e, undefined, undefined, '01', 4]],
    },
    '0x4e01000001': {
        asm: 'OP_PUSHDATA_4 16777217 [missing 16777217 bytes]',
        parse: [[0x4e, '', 16777217]],
    },
    '0x4e0100000101': {
        asm: 'OP_PUSHDATA_4 16777217 0x01[missing 16777216 bytes]',
        parse: [[0x4e, '01', 16777217]],
    },
};
const parse = (t, input, expected) => {
    t.deepEqual(lib_1.parseBytecode(input), expected);
};
parse.title = (title) => `parse script: ${title !== null && title !== void 0 ? title : ''}`.trim();
const disassemble = (t, input, expected) => {
    t.deepEqual(lib_1.disassembleParsedAuthenticationInstructions(lib_1.OpcodesBCH, input), expected);
};
disassemble.title = (title) => `disassemble script: ${title !== null && title !== void 0 ? title : ''}`.trim();
const serialize = (t, input, expected) => {
    t.deepEqual(lib_1.serializeAuthenticationInstructions(input), expected);
};
serialize.title = (title) => `serialize script: ${title !== null && title !== void 0 ? title : ''}`.trim();
const reSerialize = (t, input, expected) => {
    t.deepEqual(lib_1.serializeParsedAuthenticationInstructions(input), expected);
};
reSerialize.title = (title) => `re-serialize parsed script: ${title !== null && title !== void 0 ? title : ''}`.trim();
defToFixtures(wellFormedScripts).map(({ asm, hex, script, object }) => {
    ava_1.default(`0x${hex}`, parse, script, object);
    ava_1.default(`0x${hex}`, disassemble, object, asm);
    ava_1.default(`0x${hex}`, serialize, object, script);
    ava_1.default(`0x${hex}`, reSerialize, object, script);
    return undefined;
});
defToFixtures(malFormedPushes).map(({ asm, hex, script, object }) => {
    ava_1.default(`0x${hex}`, parse, script, object);
    ava_1.default(`0x${hex}`, disassemble, object, asm);
    ava_1.default(`0x${hex}`, reSerialize, object, script);
    return undefined;
});
ava_1.default('generateBytecodeMap', (t) => {
    let TestOpcodes;
    (function (TestOpcodes) {
        TestOpcodes[TestOpcodes["OP_A"] = 1] = "OP_A";
        TestOpcodes[TestOpcodes["OP_B"] = 2] = "OP_B";
        TestOpcodes[TestOpcodes["OP_C"] = 3] = "OP_C";
    })(TestOpcodes || (TestOpcodes = {}));
    t.deepEqual(lib_1.generateBytecodeMap(TestOpcodes), {
        OP_A: Uint8Array.of(1),
        OP_B: Uint8Array.of(2),
        OP_C: Uint8Array.of(3),
    });
});
ava_1.default('serializeAuthenticationInstruction', (t) => {
    const OP_PUSHDATA_1 = 0x4c;
    const pushData1Expected = new Uint8Array(102);
    pushData1Expected.set([OP_PUSHDATA_1, 100]);
    const pushData1Serialized = lib_1.serializeAuthenticationInstruction({
        data: new Uint8Array(100),
        opcode: OP_PUSHDATA_1,
    });
    t.deepEqual(pushData1Serialized, pushData1Expected);
    const OP_PUSHDATA_2 = 0x4d;
    const pushData2Expected = new Uint8Array(259);
    pushData2Expected.set([OP_PUSHDATA_2, 0, 1]);
    const pushData2Serialized = lib_1.serializeAuthenticationInstruction({
        data: new Uint8Array(256),
        opcode: OP_PUSHDATA_2,
    });
    t.deepEqual(pushData2Serialized, pushData2Expected);
    const OP_PUSHDATA_4 = 0x4e;
    const pushData4Expected = new Uint8Array(65541);
    pushData4Expected.set([OP_PUSHDATA_4, 0, 0, 1, 0]);
    const pushData4Serialized = lib_1.serializeAuthenticationInstruction({
        data: new Uint8Array(65536),
        opcode: OP_PUSHDATA_4,
    });
    t.deepEqual(pushData4Serialized, pushData4Expected);
});
var TestOpcodes;
(function (TestOpcodes) {
    TestOpcodes[TestOpcodes["OP_PUSH_EMPTY"] = 0] = "OP_PUSH_EMPTY";
    TestOpcodes[TestOpcodes["OP_A"] = 81] = "OP_A";
    TestOpcodes[TestOpcodes["OP_B"] = 82] = "OP_B";
    TestOpcodes[TestOpcodes["OP_C"] = 83] = "OP_C";
})(TestOpcodes || (TestOpcodes = {}));
ava_1.default('disassembleBytecode', (t) => {
    t.deepEqual(lib_1.disassembleBytecode(TestOpcodes, Uint8Array.from([0, 81, 82, 83, 81, 82, 83])), 'OP_PUSH_EMPTY OP_A OP_B OP_C OP_A OP_B OP_C');
});
ava_1.default('assembleBytecode', (t) => {
    t.deepEqual(lib_1.assembleBytecode(lib_1.generateBytecodeMap(TestOpcodes), 'OP_PUSH_EMPTY OP_A OP_B OP_C OP_A OP_B OP_C'), { bytecode: Uint8Array.from([0, 81, 82, 83, 81, 82, 83]), success: true });
});
const zcfHex = '76a9148b139a5274cc85e2d36d4f97922a15ae5d7f68af8763ac6776a914f127e6b53e2005930718681d245fe5a2b22f2b9f8763785479879169766bbb6cba676a6868';
ava_1.default('disassembleBytecodeBCH & assembleBytecodeBCH', (t) => {
    const zcfAsm = 'OP_DUP OP_HASH160 OP_PUSHBYTES_20 0x8b139a5274cc85e2d36d4f97922a15ae5d7f68af OP_EQUAL OP_IF OP_CHECKSIG OP_ELSE OP_DUP OP_HASH160 OP_PUSHBYTES_20 0xf127e6b53e2005930718681d245fe5a2b22f2b9f OP_EQUAL OP_IF OP_OVER OP_4 OP_PICK OP_EQUAL OP_NOT OP_VERIFY OP_DUP OP_TOALTSTACK OP_CHECKDATASIGVERIFY OP_FROMALTSTACK OP_CHECKDATASIG OP_ELSE OP_RETURN OP_ENDIF OP_ENDIF';
    t.deepEqual(lib_1.disassembleBytecodeBCH(lib_1.hexToBin(zcfHex)), zcfAsm);
    t.deepEqual(lib_1.assembleBytecodeBCH(zcfAsm), {
        bytecode: lib_1.hexToBin(zcfHex),
        success: true,
    });
});
ava_1.default('disassembleBytecodeBTC & assembleBytecodeBTC', (t) => {
    const zcfAsm = 'OP_DUP OP_HASH160 OP_PUSHBYTES_20 0x8b139a5274cc85e2d36d4f97922a15ae5d7f68af OP_EQUAL OP_IF OP_CHECKSIG OP_ELSE OP_DUP OP_HASH160 OP_PUSHBYTES_20 0xf127e6b53e2005930718681d245fe5a2b22f2b9f OP_EQUAL OP_IF OP_OVER OP_4 OP_PICK OP_EQUAL OP_NOT OP_VERIFY OP_DUP OP_TOALTSTACK OP_UNKNOWN187 OP_FROMALTSTACK OP_UNKNOWN186 OP_ELSE OP_RETURN OP_ENDIF OP_ENDIF';
    t.deepEqual(lib_1.disassembleBytecodeBTC(lib_1.hexToBin(zcfHex)), zcfAsm);
    t.deepEqual(lib_1.assembleBytecodeBTC(zcfAsm), {
        bytecode: lib_1.hexToBin(zcfHex),
        success: true,
    });
});
const maxUint8Number = 255;
const fcUint8Array = (minLength, maxLength) => ava_fast_check_1.fc
    .array(ava_fast_check_1.fc.integer(0, maxUint8Number), minLength, maxLength)
    .map((a) => Uint8Array.from(a));
const maxBinLength = 100;
ava_fast_check_1.testProp('[fast-check] disassembleBytecodeBCH <-> assembleBytecodeBCH', [fcUint8Array(0, maxBinLength)], (t, randomBytecode) => {
    const parsed = lib_1.parseBytecode(randomBytecode);
    const instructions = (lib_1.authenticationInstructionsAreMalformed(parsed)
        ? parsed.slice(0, -1)
        : parsed);
    const minimalPush = instructions.map((instruction) => [lib_1.OpcodesBCH.OP_PUSHDATA_2, lib_1.OpcodesBCH.OP_PUSHDATA_4].includes(instruction.opcode)
        ? { opcode: lib_1.OpcodesBCH.OP_1 }
        : instruction.opcode === lib_1.OpcodesBCH.OP_PUSHDATA_1 &&
            instruction.data.length < 76
            ? {
                data: new Uint8Array(76),
                opcode: lib_1.OpcodesBCH.OP_PUSHDATA_1,
            }
            : instruction);
    const serialized = lib_1.serializeAuthenticationInstructions(minimalPush);
    const disassembled = lib_1.disassembleBytecodeBCH(serialized);
    const reassembled = lib_1.assembleBytecodeBCH(disassembled);
    if (!reassembled.success) {
        t.fail();
        return;
    }
    t.deepEqual(serialized, reassembled.bytecode);
});
ava_fast_check_1.testProp('[fast-check] disassembleBytecodeBTC <-> assembleBytecodeBTC', [fcUint8Array(0, maxBinLength)], (t, randomBytecode) => {
    const parsed = lib_1.parseBytecode(randomBytecode);
    const instructions = (lib_1.authenticationInstructionsAreMalformed(parsed)
        ? parsed.slice(0, -1)
        : parsed);
    const minimalPush = instructions.map((instruction) => [lib_1.OpcodesBTC.OP_PUSHDATA_2, lib_1.OpcodesBTC.OP_PUSHDATA_4].includes(instruction.opcode)
        ? { opcode: lib_1.OpcodesBTC.OP_1 }
        : instruction.opcode === lib_1.OpcodesBTC.OP_PUSHDATA_1 &&
            instruction.data.length < 76
            ? {
                data: new Uint8Array(76),
                opcode: lib_1.OpcodesBTC.OP_PUSHDATA_1,
            }
            : instruction);
    const serialized = lib_1.serializeAuthenticationInstructions(minimalPush);
    const disassembled = lib_1.disassembleBytecodeBTC(serialized);
    const reassembled = lib_1.assembleBytecodeBTC(disassembled);
    if (!reassembled.success) {
        t.fail();
        return;
    }
    t.deepEqual(serialized, reassembled.bytecode);
});
//# sourceMappingURL=instruction-sets-utils.spec.js.map