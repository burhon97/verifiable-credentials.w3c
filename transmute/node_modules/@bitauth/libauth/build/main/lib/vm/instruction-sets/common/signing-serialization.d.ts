/**
 * A.K.A. `sighash` flags
 */
export declare enum SigningSerializationFlag {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    allOutputs = 1,
    /**
     * A.K.A `SIGHASH_NONE`
     */
    noOutputs = 2,
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    correspondingOutput = 3,
    forkId = 64,
    /**
     * A.K.A `ANYONE_CAN_PAY`
     */
    singleInput = 128
}
export declare const isDefinedSigningSerializationType: (byte: number) => boolean;
/**
 * Return the proper `hashPrevouts` value for a given a signing serialization
 * type.
 * @param signingSerializationType - the signing serialization type to test
 * @param transactionOutpoints - see `generateSigningSerializationBCH`
 */
export declare const hashPrevouts: ({ sha256, signingSerializationType, transactionOutpoints, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    signingSerializationType: Uint8Array;
    transactionOutpoints: Uint8Array;
}) => Uint8Array;
/**
 * Return the proper `hashSequence` value for a given a signing serialization
 * type.
 * @param signingSerializationType - the signing serialization type to test
 * @param transactionSequenceNumbers - see
 * `generateSigningSerializationBCH`
 */
export declare const hashSequence: ({ sha256, signingSerializationType, transactionSequenceNumbers, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    signingSerializationType: Uint8Array;
    transactionSequenceNumbers: Uint8Array;
}) => Uint8Array;
/**
 * Return the proper `hashOutputs` value for a given a signing serialization
 * type.
 * @param signingSerializationType - the signing serialization type to test
 * @param transactionOutputs - see `generateSigningSerializationBCH`
 * @param correspondingOutput - see `generateSigningSerializationBCH`
 */
export declare const hashOutputs: ({ correspondingOutput, sha256, signingSerializationType, transactionOutputs, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    signingSerializationType: Uint8Array;
    transactionOutputs: Uint8Array;
    correspondingOutput: Uint8Array | undefined;
}) => Uint8Array;
/**
 * Serialize the signature-protected properties of a transaction following the
 * algorithm required by the `signingSerializationType` of a signature.
 *
 * Note: this implementation re-computes all hashes each time it is called. A
 * performance-critical application could instead use memoization to avoid
 * re-computing these values when validating many signatures within a single
 * transaction. See BIP143 for details.
 */
export declare const generateSigningSerializationBCH: ({ correspondingOutput, coveredBytecode, forkId, locktime, outpointIndex, outpointTransactionHash, outputValue, sequenceNumber, sha256, signingSerializationType, transactionOutpoints, transactionOutputs, transactionSequenceNumbers, version, }: {
    sha256: {
        hash: (input: Uint8Array) => Uint8Array;
    };
    /**
     * The version number of the transaction.
     */
    version: number;
    /**
     * The serialization of all input outpoints (A.K.A. `hashPrevouts`) – used if
     * `ANYONECANPAY` is not set.
     */
    transactionOutpoints: Uint8Array;
    /**
     * The serialization of all input sequence numbers. (A.K.A. `hashSequence`) –
     * used if none of `ANYONECANPAY`, `SINGLE`, or `NONE` are set.
     */
    transactionSequenceNumbers: Uint8Array;
    /**
     * The big-endian (standard) transaction hash of the outpoint being spent.
     */
    outpointTransactionHash: Uint8Array;
    /**
     * The index of the outpoint being spent in `outpointTransactionHash`.
     */
    outpointIndex: number;
    /**
     * The serialized script currently being executed, beginning at the
     * `lastCodeSeparator`.
     */
    coveredBytecode: Uint8Array;
    /**
     * The 8-byte `Uint64LE`-encoded value of the outpoint in satoshis (see
     * `bigIntToBinUint64LE`).
     */
    outputValue: Uint8Array;
    /**
     * The sequence number of the input (A.K.A. `nSequence`).
     */
    sequenceNumber: number;
    /**
     * The serialization of the output at the same index as this input (A.K.A.
     * `hashOutputs` with `SIGHASH_SINGLE`) – only used if `SINGLE` is set.
     */
    correspondingOutput: Uint8Array | undefined;
    /**
     * The serialization of output amounts and locking bytecode values (A.K.A.
     * `hashOutputs` with `SIGHASH_ALL`) – only used if `ALL` is set.
     */
    transactionOutputs: Uint8Array;
    /**
     * The locktime of the transaction.
     */
    locktime: number;
    /**
     * The signing serialization type of the signature (A.K.A. `sighash` type).
     */
    signingSerializationType: Uint8Array;
    /**
     * While a bitcoin-encoded signature only includes a single byte to encode the
     * signing serialization type, a 3-byte forkId can be appended to provide
     * replay-protection between different forks. (See Bitcoin Cash's Replay
     * Protected Sighash spec for details.)
     */
    forkId?: Uint8Array | undefined;
}) => Uint8Array;
/**
 * @param signingSerializationType - the 32-bit number indicating the signing
 * serialization algorithm to use
 */
export declare const isLegacySigningSerialization: (signingSerializationType: number) => boolean;
//# sourceMappingURL=signing-serialization.d.ts.map