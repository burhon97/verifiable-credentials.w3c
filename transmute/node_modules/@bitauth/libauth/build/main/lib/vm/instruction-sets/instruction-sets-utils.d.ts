import { AuthenticationProgramStateCommon } from '../vm-types';
import { AuthenticationErrorBCH, OpcodesBCH } from './bch/bch';
import { OpcodesBTC } from './btc/btc';
import { AuthenticationInstruction, ParsedAuthenticationInstruction, ParsedAuthenticationInstructionMalformed, ParsedAuthenticationInstructions } from './instruction-sets-types';
/**
 * A type-guard which checks if the provided instruction is malformed.
 * @param instruction - the instruction to check
 */
export declare const authenticationInstructionIsMalformed: <Opcodes>(instruction: ParsedAuthenticationInstruction<Opcodes>) => instruction is ParsedAuthenticationInstructionMalformed<Opcodes>;
/**
 * A type-guard which checks if the final instruction in the provided array of
 * instructions is malformed. (Only the final instruction can be malformed.)
 * @param instruction - the array of instructions to check
 */
export declare const authenticationInstructionsAreMalformed: <Opcodes>(instructions: ParsedAuthenticationInstructions<Opcodes>) => instructions is ParsedAuthenticationInstructionMalformed<Opcodes>[];
/**
 * A type-guard which confirms that the final instruction in the provided array
 * is not malformed. (Only the final instruction can be malformed.)
 * @param instruction - the array of instructions to check
 */
export declare const authenticationInstructionsAreNotMalformed: <Opcodes>(instructions: ParsedAuthenticationInstructions<Opcodes>) => instructions is AuthenticationInstruction<Opcodes>[];
/**
 * Returns the number of bytes used to indicate the length of the push in this
 * operation.
 * @param opcode - an opcode between 0x00 and 0x4e
 */
export declare const lengthBytesForPushOpcode: (opcode: number) => 1 | 0 | 2 | 4;
/**
 * Parse one instruction from the provided script.
 *
 * Returns an object with an `instruction` referencing a
 * `ParsedAuthenticationInstruction`, and a `nextIndex` indicating the next
 * index from which to read. If the next index is greater than or equal to the
 * length of the script, the script has been fully parsed.
 *
 * The final `ParsedAuthenticationInstruction` from a serialized script may be
 * malformed if 1) the final operation is a push and 2) too few bytes remain for
 * the push operation to complete.
 *
 * @param script - the script from which to read the next instruction
 * @param index - the offset from which to begin reading
 */
export declare const readAuthenticationInstruction: <Opcodes = number>(script: Uint8Array, index: number) => {
    instruction: ParsedAuthenticationInstruction<Opcodes>;
    nextIndex: number;
};
/**
 * Parse authentication bytecode (`lockingBytecode` or `unlockingBytecode`)
 * into `ParsedAuthenticationInstructions`. The method
 * `authenticationInstructionsAreMalformed` can be used to check if these
 * instructions include a malformed instruction. If not, they are valid
 * `AuthenticationInstructions`.
 *
 * This implementation is common to most bitcoin forks, but the type parameter
 * can be used to strongly type the resulting instructions. For example:
 *
 * ```js
 *  const instructions = parseAuthenticationBytecode<OpcodesBCH>(script);
 * ```
 *
 * @param script - the serialized script to parse
 */
export declare const parseBytecode: <Opcodes = number>(script: Uint8Array) => ParsedAuthenticationInstructions<Opcodes>;
/**
 * Disassemble a malformed authentication instruction into a string description.
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instruction - the malformed instruction to disassemble
 */
export declare const disassembleParsedAuthenticationInstructionMalformed: <Opcodes = number>(opcodes: {
    readonly [opcode: number]: string;
}, instruction: ParsedAuthenticationInstructionMalformed<Opcodes>) => string;
/**
 * Disassemble a properly-formed authentication instruction into a string
 * description.
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instruction - the instruction to disassemble
 */
export declare const disassembleAuthenticationInstruction: <Opcodes = number>(opcodes: {
    readonly [opcode: number]: string;
}, instruction: AuthenticationInstruction<Opcodes>) => string;
/**
 * Disassemble a single `ParsedAuthenticationInstruction` (includes potentially
 * malformed instructions) into its ASM representation.
 *
 * @param script - the instruction to disassemble
 */
export declare const disassembleParsedAuthenticationInstruction: <Opcodes = number>(opcodes: {
    readonly [opcode: number]: string;
}, instruction: ParsedAuthenticationInstruction<Opcodes>) => string;
/**
 * Disassemble an array of `ParsedAuthenticationInstructions` (including
 * potentially malformed instructions) into its ASM representation.
 *
 * @param script - the array of instructions to disassemble
 */
export declare const disassembleParsedAuthenticationInstructions: <Opcodes = number>(opcodes: {
    readonly [opcode: number]: string;
}, instructions: readonly ParsedAuthenticationInstruction<Opcodes>[]) => string;
/**
 * Disassemble authentication bytecode into a lossless ASM representation. (All
 * push operations are represented with the same opcodes used in the bytecode,
 * even when non-minimally encoded.)
 *
 * @param opcodes - the set to use when determining the name of opcodes, e.g. `OpcodesBCH`
 * @param bytecode - the authentication bytecode to disassemble
 */
export declare const disassembleBytecode: <Opcode = number>(opcodes: {
    readonly [opcode: number]: string;
}, bytecode: Uint8Array) => string;
/**
 * Disassemble BCH authentication bytecode into its ASM representation.
 * @param bytecode - the authentication bytecode to disassemble
 */
export declare const disassembleBytecodeBCH: (bytecode: Uint8Array) => string;
/**
 * Disassemble BTC authentication bytecode into its ASM representation.
 * @param bytecode - the authentication bytecode to disassemble
 */
export declare const disassembleBytecodeBTC: (bytecode: Uint8Array) => string;
/**
 * Create an object where each key is an opcode identifier and each value is
 * the bytecode value (`Uint8Array`) it represents.
 * @param opcodes - An opcode enum, e.g. `OpcodesBCH`
 */
export declare const generateBytecodeMap: (opcodes: Record<string, unknown>) => {
    [opcode: string]: Uint8Array;
};
/**
 * Re-assemble a string of disassembled bytecode (see `disassembleBytecode`).
 *
 * @param opcodes - a mapping of opcodes to their respective Uint8Array
 * representation
 * @param disassembledBytecode - the disassembled bytecode to re-assemble
 */
export declare const assembleBytecode: <Opcodes extends number = OpcodesBCH, Errors = AuthenticationErrorBCH>(opcodes: {
    readonly [opcode: string]: Uint8Array;
}, disassembledBytecode: string) => import("../../lib").CompilationResultParseError | import("../../lib").CompilationResultResolveError | {
    bytecode: Uint8Array;
    success: true;
} | import("../../lib").CompilationResultReduceError<AuthenticationProgramStateCommon<Opcodes, Errors>> | import("../../lib").CompilationResultSuccess<AuthenticationProgramStateCommon<Opcodes, Errors>>;
/**
 * Re-assemble a string of disassembled BCH bytecode (see
 * `disassembleBytecodeBCH`).
 *
 * Note, this method performs automatic minimization of push instructions.
 *
 * @param disassembledBytecode - the disassembled BCH bytecode to re-assemble
 */
export declare const assembleBytecodeBCH: (disassembledBytecode: string) => import("../../lib").CompilationResultParseError | import("../../lib").CompilationResultResolveError | {
    bytecode: Uint8Array;
    success: true;
} | import("../../lib").CompilationResultReduceError<AuthenticationProgramStateCommon<OpcodesBCH, AuthenticationErrorBCH>> | import("../../lib").CompilationResultSuccess<AuthenticationProgramStateCommon<OpcodesBCH, AuthenticationErrorBCH>>;
/**
 * Re-assemble a string of disassembled BCH bytecode (see
 * `disassembleBytecodeBTC`).
 *
 * Note, this method performs automatic minimization of push instructions.
 *
 * @param disassembledBytecode - the disassembled BTC bytecode to re-assemble
 */
export declare const assembleBytecodeBTC: (disassembledBytecode: string) => import("../../lib").CompilationResultParseError | import("../../lib").CompilationResultResolveError | {
    bytecode: Uint8Array;
    success: true;
} | import("../../lib").CompilationResultReduceError<AuthenticationProgramStateCommon<OpcodesBTC, AuthenticationErrorBCH>> | import("../../lib").CompilationResultSuccess<AuthenticationProgramStateCommon<OpcodesBTC, AuthenticationErrorBCH>>;
/**
 * Re-serialize a valid authentication instruction.
 * @param instruction - the instruction to serialize
 */
export declare const serializeAuthenticationInstruction: <Opcodes = number>(instruction: AuthenticationInstruction<Opcodes>) => Uint8Array;
/**
 * Re-serialize a malformed authentication instruction.
 * @param instruction - the malformed instruction to serialize
 */
export declare const serializeParsedAuthenticationInstructionMalformed: <Opcodes = number>(instruction: ParsedAuthenticationInstructionMalformed<Opcodes>) => Uint8Array;
/**
 * Re-serialize a potentially-malformed authentication instruction.
 * @param instruction - the potentially-malformed instruction to serialize
 */
export declare const serializeParsedAuthenticationInstruction: <Opcodes = number>(instruction: ParsedAuthenticationInstruction<Opcodes>) => Uint8Array;
/**
 * Re-serialize an array of valid authentication instructions.
 * @param instructions - the array of valid instructions to serialize
 */
export declare const serializeAuthenticationInstructions: <Opcodes = number>(instructions: readonly AuthenticationInstruction<Opcodes>[]) => Uint8Array;
/**
 * Re-serialize an array of potentially-malformed authentication instructions.
 * @param instructions - the array of instructions to serialize
 */
export declare const serializeParsedAuthenticationInstructions: <Opcodes = number>(instructions: readonly ParsedAuthenticationInstruction<Opcodes>[]) => Uint8Array;
//# sourceMappingURL=instruction-sets-utils.d.ts.map