"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineOperations = exports.pushToStack = exports.useThreeScriptNumbers = exports.useTwoScriptNumbers = exports.useOneScriptNumber = exports.useSixStackItems = exports.useFourStackItems = exports.useThreeStackItems = exports.useTwoStackItems = exports.useOneStackItem = exports.mapOverOperations = exports.conditionallyEvaluate = exports.incrementOperationCount = void 0;
const common_1 = require("./common");
const errors_1 = require("./errors");
exports.incrementOperationCount = (operation) => (state) => {
    const nextState = operation(state);
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    nextState.operationCount += 1;
    return nextState;
};
exports.conditionallyEvaluate = (operation) => (state) => state.executionStack.every((item) => item) ? operation(state) : state;
/**
 * Map a function over each operation in an `InstructionSet.operations` object,
 * assigning the result to the same `opcode` in the resulting object.
 * @param operations - an operations map from an `InstructionSet`
 * @param combinator - a function to apply to each operation
 */
exports.mapOverOperations = (operations, ...combinators) => Object.keys(operations).reduce((result, operation) => (Object.assign(Object.assign({}, result), { [operation]: combinators.reduce((op, combinator) => combinator(op), operations[parseInt(operation, 10)]) })), {});
/**
 * Pop one stack item off of `state.stack` and provide that item to `operation`.
 */
exports.useOneStackItem = (state, operation) => {
    // eslint-disable-next-line functional/immutable-data
    const item = state.stack.pop();
    if (item === undefined) {
        return errors_1.applyError(errors_1.AuthenticationErrorCommon.emptyStack, state);
    }
    return operation(state, [item]);
};
exports.useTwoStackItems = (state, operation) => exports.useOneStackItem(state, (nextState, [valueTwo]) => exports.useOneStackItem(nextState, (lastState, [valueTop]) => operation(lastState, [valueTop, valueTwo])));
exports.useThreeStackItems = (state, operation) => exports.useOneStackItem(state, (nextState, [valueThree]) => exports.useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [valueTop, valueTwo, valueThree])));
exports.useFourStackItems = (state, operation) => exports.useTwoStackItems(state, (nextState, [valueThree, valueFour]) => exports.useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [valueTop, valueTwo, valueThree, valueFour])));
exports.useSixStackItems = (state, operation) => exports.useFourStackItems(state, (nextState, [valueThree, valueFour, valueFive, valueSix]) => exports.useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [
    valueTop,
    valueTwo,
    valueThree,
    valueFour,
    valueFive,
    valueSix,
])));
const normalMaximumScriptNumberByteLength = 4;
exports.useOneScriptNumber = (state, operation, { requireMinimalEncoding, maximumScriptNumberByteLength = normalMaximumScriptNumberByteLength, }) => exports.useOneStackItem(state, (nextState, [item]) => {
    const value = common_1.parseBytesAsScriptNumber(item, {
        maximumScriptNumberByteLength,
        requireMinimalEncoding,
    });
    if (common_1.isScriptNumberError(value)) {
        return errors_1.applyError(errors_1.AuthenticationErrorCommon.invalidScriptNumber, state);
    }
    return operation(nextState, [value]);
});
exports.useTwoScriptNumbers = (state, operation, { requireMinimalEncoding, maximumScriptNumberByteLength = normalMaximumScriptNumberByteLength, }) => exports.useOneScriptNumber(state, (nextState, [secondValue]) => exports.useOneScriptNumber(nextState, (lastState, [firstValue]) => operation(lastState, [firstValue, secondValue]), { maximumScriptNumberByteLength, requireMinimalEncoding }), { maximumScriptNumberByteLength, requireMinimalEncoding });
exports.useThreeScriptNumbers = (state, operation, { requireMinimalEncoding, maximumScriptNumberByteLength = normalMaximumScriptNumberByteLength, }) => exports.useTwoScriptNumbers(state, (nextState, [secondValue, thirdValue]) => exports.useOneScriptNumber(nextState, (lastState, [firstValue]) => operation(lastState, [firstValue, secondValue, thirdValue]), { maximumScriptNumberByteLength, requireMinimalEncoding }), { maximumScriptNumberByteLength, requireMinimalEncoding });
/**
 * Return the provided state with the provided value pushed to its stack.
 * @param state - the state to update and return
 * @param data - the value to push to the stack
 */
exports.pushToStack = (state, ...data) => {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    state.stack.push(...data);
    return state;
};
// TODO: if firstOperation errors, secondOperation might overwrite the error
exports.combineOperations = (firstOperation, secondOperation) => (state) => secondOperation(firstOperation(state));
//# sourceMappingURL=combinators.js.map