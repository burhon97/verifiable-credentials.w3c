"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.testHashFunction = void 0;
/* global Buffer */
/* eslint-disable functional/no-expression-statement */
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const path_1 = require("path");
const ava_1 = __importDefault(require("ava"));
const bcrypto = __importStar(require("bcrypto"));
const fc = __importStar(require("fast-check"));
const hashJs = __importStar(require("hash.js"));
const testLength = 10000;
const stringToCharsUint8Array = (str) => new Uint8Array([...str].map((c) => c.charCodeAt(0)));
const maxUint8Number = 255;
const fcUint8Array = (minLength, maxLength) => fc
    .array(fc.integer(0, maxUint8Number), minLength, maxLength)
    .map((a) => Uint8Array.from(a));
exports.testHashFunction = ({ abcHash, bitcoinTsHash, getEmbeddedBinary, hashFunctionName, instantiate, instantiateBytes, nodeJsAlgorithm, testHash, }) => {
    const binary = getEmbeddedBinary();
    const bcryptoAlgorithm = nodeJsAlgorithm.toUpperCase();
    ava_1.default(`[crypto] ${hashFunctionName} getEmbeddedBinary returns the proper binary`, (t) => {
        const path = path_1.join(__dirname, '..', 'bin', `${hashFunctionName}`, `${hashFunctionName}.wasm`);
        const binaryFromDisk = fs_1.readFileSync(path).buffer;
        t.deepEqual(binary, binaryFromDisk);
    });
    ava_1.default(`[crypto] ${hashFunctionName} instantiated with embedded binary`, async (t) => {
        const hashFunction = await instantiate();
        t.deepEqual(hashFunction.hash(stringToCharsUint8Array('abc')), abcHash);
        t.deepEqual(hashFunction.hash(stringToCharsUint8Array('test')), testHash);
        t.deepEqual(hashFunction.hash(stringToCharsUint8Array('bitcoin-ts')), bitcoinTsHash);
    });
    ava_1.default(`[fast-check] [crypto] ${hashFunctionName} instantiated with bytes`, async (t) => {
        const hashFunction = await instantiateBytes(binary);
        const equivalentToNative = fc.property(fcUint8Array(0, testLength), (message) => {
            const hash = crypto_1.createHash(nodeJsAlgorithm);
            t.deepEqual(new Uint8Array(hash.update(Buffer.from(message)).digest()), hashFunction.hash(message));
        });
        const equivalentToBcoin = fc.property(fcUint8Array(0, testLength), (message) => {
            t.deepEqual(new Uint8Array(bcrypto[bcryptoAlgorithm].digest(Buffer.from(message))), hashFunction.hash(message));
        });
        const equivalentToHashJs = fc.property(fcUint8Array(0, testLength), (message) => {
            t.deepEqual(new Uint8Array(hashJs[nodeJsAlgorithm]().update(message).digest()), hashFunction.hash(message));
        });
        t.notThrows(() => {
            fc.assert(equivalentToNative);
            fc.assert(equivalentToBcoin);
            fc.assert(equivalentToHashJs);
        });
    });
    ava_1.default(`[crypto] ${hashFunctionName} incremental hashing`, async (t) => {
        const hashFunction = await instantiate();
        t.deepEqual(hashFunction.final(hashFunction.update(hashFunction.update(hashFunction.update(hashFunction.init(), stringToCharsUint8Array('a')), stringToCharsUint8Array('b')), stringToCharsUint8Array('c'))), abcHash);
        t.deepEqual(hashFunction.final(hashFunction.update(hashFunction.init(), stringToCharsUint8Array('test'))), testHash);
        t.deepEqual(hashFunction.final(hashFunction.update(hashFunction.update(hashFunction.init(), stringToCharsUint8Array('bitcoin')), stringToCharsUint8Array('-ts'))), bitcoinTsHash);
        const equivalentToSinglePass = fc.property(fcUint8Array(1, testLength), fc.integer(1, testLength), (message, chunkSize) => {
            const chunkCount = Math.ceil(message.length / chunkSize);
            const chunks = Array.from({ length: chunkCount })
                .map((_, index) => index * chunkSize)
                .map((startIndex) => message.slice(startIndex, startIndex + chunkSize));
            const incrementalResult = hashFunction.final(chunks.reduce((state, chunk) => hashFunction.update(state, chunk), hashFunction.init()));
            const singlePassResult = hashFunction.hash(message);
            t.deepEqual(incrementalResult, singlePassResult);
        });
        t.notThrows(() => {
            fc.assert(equivalentToSinglePass);
        });
    });
};
//# sourceMappingURL=hash.spec.helper.js.map