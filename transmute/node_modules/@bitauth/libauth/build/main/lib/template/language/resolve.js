"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIdentifierResolver = exports.resolveScriptIdentifier = exports.resolveVariableIdentifier = exports.BuiltInVariables = exports.resolveScriptSegment = void 0;
const format_1 = require("../../format/format");
const instruction_sets_1 = require("../../vm/instruction-sets/instruction-sets");
const compile_1 = require("./compile");
const language_types_1 = require("./language-types");
const language_utils_1 = require("./language-utils");
const pluckRange = (node) => ({
    endColumn: node.end.column,
    endLineNumber: node.end.line,
    startColumn: node.start.column,
    startLineNumber: node.start.line,
});
const removeNumericSeparators = (numericLiteral) => numericLiteral.replace(/_/gu, '');
exports.resolveScriptSegment = (segment, resolveIdentifiers) => {
    // eslint-disable-next-line complexity
    const resolved = segment.value.map((child) => {
        const range = pluckRange(child);
        switch (child.name) {
            case 'Identifier': {
                const identifier = child.value;
                const result = resolveIdentifiers(identifier);
                const ret = result.status
                    ? Object.assign({ range, type: 'bytecode', value: result.bytecode }, (result.type === language_types_1.IdentifierResolutionType.opcode
                        ? {
                            opcode: identifier,
                        }
                        : result.type === language_types_1.IdentifierResolutionType.variable
                            ? Object.assign(Object.assign(Object.assign({}, ('debug' in result ? { debug: result.debug } : {})), ('signature' in result
                                ? { signature: result.signature }
                                : {})), { variable: identifier }) : // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                            result.type === language_types_1.IdentifierResolutionType.script
                                ? { script: identifier, source: result.source }
                                : { unknown: identifier })) : Object.assign(Object.assign(Object.assign({}, ('debug' in result ? { debug: result.debug } : {})), ('recoverable' in result && result.recoverable
                    ? {
                        missingIdentifier: identifier,
                        owningEntity: result.entityOwnership,
                    }
                    : {})), { range, type: 'error', value: result.error });
                return ret;
            }
            case 'Push':
                return {
                    range,
                    type: 'push',
                    value: exports.resolveScriptSegment(child.value, resolveIdentifiers),
                };
            case 'Evaluation':
                return {
                    range,
                    type: 'evaluation',
                    value: exports.resolveScriptSegment(child.value, resolveIdentifiers),
                };
            case 'BigIntLiteral':
                return {
                    literal: child.value,
                    literalType: 'BigIntLiteral',
                    range,
                    type: 'bytecode',
                    value: instruction_sets_1.bigIntToScriptNumber(BigInt(removeNumericSeparators(child.value))),
                };
            case 'BinaryLiteral':
                return {
                    literal: child.value,
                    literalType: 'BinaryLiteral',
                    range,
                    type: 'bytecode',
                    value: instruction_sets_1.bigIntToScriptNumber(BigInt(`0b${removeNumericSeparators(child.value)}`)),
                };
            case 'HexLiteral':
                return {
                    literal: child.value,
                    literalType: 'HexLiteral',
                    range,
                    type: 'bytecode',
                    value: format_1.hexToBin(removeNumericSeparators(child.value)),
                };
            case 'UTF8Literal':
                return {
                    literal: child.value,
                    literalType: 'UTF8Literal',
                    range,
                    type: 'bytecode',
                    value: format_1.utf8ToBin(child.value),
                };
            case 'Comment':
                return {
                    range,
                    type: 'comment',
                    value: child.value,
                };
            default:
                return {
                    range,
                    type: 'error',
                    value: `Unrecognized segment: ${child.name}`,
                };
        }
    });
    return resolved.length === 0
        ? [{ range: pluckRange(segment), type: 'comment', value: '' }]
        : resolved;
};
var BuiltInVariables;
(function (BuiltInVariables) {
    BuiltInVariables["currentBlockTime"] = "current_block_time";
    BuiltInVariables["currentBlockHeight"] = "current_block_height";
    BuiltInVariables["signingSerialization"] = "signing_serialization";
})(BuiltInVariables = exports.BuiltInVariables || (exports.BuiltInVariables = {}));
const attemptCompilerOperation = ({ data, environment, identifier, matchingOperations, operationExample = 'operation_identifier', operationId, variableId, variableType, }) => {
    if (matchingOperations === undefined) {
        return {
            error: `The "${variableId}" variable type can not be resolved because the "${variableType}" operation has not been included in this compiler's CompilationEnvironment.`,
            status: 'error',
        };
    }
    if (typeof matchingOperations === 'function') {
        const operation = matchingOperations;
        return operation(identifier, data, environment);
    }
    if (operationId === undefined) {
        return {
            error: `This "${variableId}" variable could not be resolved because this compiler's "${variableType}" operations require an operation identifier, e.g. '${variableId}.${operationExample}'.`,
            status: 'error',
        };
    }
    const operation = matchingOperations[operationId];
    if (operation === undefined) {
        return {
            error: `The identifier "${identifier}" could not be resolved because the "${variableId}.${operationId}" operation is not available to this compiler.`,
            status: 'error',
        };
    }
    return operation(identifier, data, environment);
};
/**
 * If the identifer can be successfully resolved as a variable, the result is
 * returned as a Uint8Array. If the identifier references a known variable, but
 * an error occurs in resolving it, the error is returned as a string.
 * Otherwise, the identifier is not recognized as a variable, and this method
 * simply returns `false`.
 *
 * @param identifier - The full identifier used to describe this operation, e.g.
 * `owner.signature.all_outputs`.
 * @param data - The `CompilationData` provided to the compiler
 * @param environment - The `CompilationEnvironment` provided to the compiler
 */
exports.resolveVariableIdentifier = ({ data, environment, identifier, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const [variableId, operationId] = identifier.split('.');
    switch (variableId) {
        case BuiltInVariables.currentBlockHeight:
            return attemptCompilerOperation({
                data,
                environment,
                identifier,
                matchingOperations: (_a = environment.operations) === null || _a === void 0 ? void 0 : _a.currentBlockHeight,
                operationId,
                variableId,
                variableType: 'currentBlockHeight',
            });
        case BuiltInVariables.currentBlockTime:
            return attemptCompilerOperation({
                data,
                environment,
                identifier,
                matchingOperations: (_b = environment.operations) === null || _b === void 0 ? void 0 : _b.currentBlockTime,
                operationId,
                variableId,
                variableType: 'currentBlockTime',
            });
        case BuiltInVariables.signingSerialization:
            return attemptCompilerOperation({
                data,
                environment,
                identifier,
                matchingOperations: (_c = environment.operations) === null || _c === void 0 ? void 0 : _c.signingSerialization,
                operationExample: 'version',
                operationId,
                variableId,
                variableType: 'signingSerialization',
            });
        default: {
            const expectedVariable = (_d = environment.variables) === null || _d === void 0 ? void 0 : _d[variableId];
            if (expectedVariable === undefined) {
                return { status: 'skip' };
            }
            return attemptCompilerOperation(Object.assign({ data,
                environment,
                identifier,
                operationId,
                variableId }, {
                // eslint-disable-next-line @typescript-eslint/naming-convention
                AddressData: {
                    matchingOperations: (_e = environment.operations) === null || _e === void 0 ? void 0 : _e.addressData,
                    variableType: 'addressData',
                },
                // eslint-disable-next-line @typescript-eslint/naming-convention
                HdKey: {
                    matchingOperations: (_f = environment.operations) === null || _f === void 0 ? void 0 : _f.hdKey,
                    operationExample: 'public_key',
                    variableType: 'hdKey',
                },
                // eslint-disable-next-line @typescript-eslint/naming-convention
                Key: {
                    matchingOperations: (_g = environment.operations) === null || _g === void 0 ? void 0 : _g.key,
                    operationExample: 'public_key',
                    variableType: 'key',
                },
                // eslint-disable-next-line @typescript-eslint/naming-convention
                WalletData: {
                    matchingOperations: (_h = environment.operations) === null || _h === void 0 ? void 0 : _h.walletData,
                    variableType: 'walletData',
                },
            }[expectedVariable.type]));
        }
    }
};
/**
 * Compile an internal script identifier.
 *
 * @remarks
 * If the identifer can be successfully resolved as a script, the script is
 * compiled and returned as a CompilationResultSuccess. If an error occurs in
 * compiling it, the error is returned as a string.
 *
 * Otherwise, the identifier is not recognized as a script, and this method
 * simply returns `false`.
 *
 * @param identifier - the identifier of the script to be resolved
 * @param data - the provided CompilationData
 * @param environment - the provided CompilationEnvironment
 * @param parentIdentifier - the identifier of the script which references the
 * script being resolved (for detecting circular dependencies)
 */
exports.resolveScriptIdentifier = ({ data, environment, identifier, }) => {
    if (environment.scripts[identifier] === undefined) {
        return false;
    }
    const result = compile_1.compileScriptRaw({ data, environment, scriptId: identifier });
    if (result.success) {
        return result;
    }
    return `Compilation error in resolved script "${identifier}": ${language_utils_1.stringifyErrors(result.errors)}`;
    /*
     * result.errors.reduce(
     *   (all, { error, range }) =>
     *     `${
     *       all === '' ? '' : `${all}; `
     *     } [${
     *       range.startLineNumber
     *     }, ${range.startColumn}]: ${error}`,
     *   ''
     * );
     */
};
/**
 * Return an `IdentifierResolutionFunction` for use in `resolveScriptSegment`.
 *
 * @param scriptId - the `id` of the script for which the resulting
 * `IdentifierResolutionFunction` will be used.
 * @param environment - a snapshot of the context around `scriptId`. See
 * `CompilationEnvironment` for details.
 * @param data - the actual variable values (private keys, shared wallet data,
 * shared address data, etc.) to use in resolving variables.
 */
exports.createIdentifierResolver = ({ data, environment, }) => 
// eslint-disable-next-line complexity
(identifier) => {
    var _a;
    const opcodeResult = (_a = environment.opcodes) === null || _a === void 0 ? void 0 : _a[identifier];
    if (opcodeResult !== undefined) {
        return {
            bytecode: opcodeResult,
            status: true,
            type: language_types_1.IdentifierResolutionType.opcode,
        };
    }
    const variableResult = exports.resolveVariableIdentifier({
        data,
        environment,
        identifier,
    });
    if (variableResult.status !== 'skip') {
        return variableResult.status === 'error'
            ? Object.assign(Object.assign(Object.assign(Object.assign({}, ('debug' in variableResult
                ? { debug: variableResult.debug }
                : {})), { error: variableResult.error }), (environment.entityOwnership === undefined
                ? {}
                : {
                    entityOwnership: environment.entityOwnership[identifier.split('.')[0]],
                })), { recoverable: 'recoverable' in variableResult, status: false, type: language_types_1.IdentifierResolutionErrorType.variable }) : Object.assign(Object.assign(Object.assign(Object.assign({}, ('debug' in variableResult
            ? { debug: variableResult.debug }
            : {})), { bytecode: variableResult.bytecode }), ('signature' in variableResult
            ? {
                signature: variableResult.signature,
            }
            : {})), { status: true, type: language_types_1.IdentifierResolutionType.variable });
    }
    const scriptResult = exports.resolveScriptIdentifier({
        data,
        environment,
        identifier,
    });
    if (scriptResult !== false) {
        return typeof scriptResult === 'string'
            ? {
                error: scriptResult,
                scriptId: identifier,
                status: false,
                type: language_types_1.IdentifierResolutionErrorType.script,
            }
            : {
                bytecode: scriptResult.bytecode,
                source: scriptResult.resolve,
                status: true,
                type: language_types_1.IdentifierResolutionType.script,
            };
    }
    return {
        error: `Unknown identifier "${identifier}".`,
        status: false,
        type: language_types_1.IdentifierResolutionErrorType.unknown,
    };
};
//# sourceMappingURL=resolve.js.map