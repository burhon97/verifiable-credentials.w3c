"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateScenarioCommon = exports.extendCompilationDataWithScenarioBytecode = exports.extendedScenarioDefinitionToCompilationData = exports.generateExtendedScenario = exports.extendScenarioDefinition = exports.extendScenarioDefinitionData = exports.generateDefaultScenarioDefinition = void 0;
const hex_1 = require("../format/hex");
const numbers_1 = require("../format/numbers");
const hd_key_1 = require("../key/hd-key");
const compiler_defaults_1 = require("./compiler-defaults");
const compile_1 = require("./language/compile");
const language_utils_1 = require("./language/language-utils");
/*
 * & {
 *   value: Uint8Array;
 * };
 */
/**
 * Given a compilation environment, generate the default scenario which is
 * extended by all the environments scenarios.
 *
 * For details on default scenario generation, see
 * `AuthenticationTemplateScenario.extends`.
 *
 * @param environment - the compilation environment from which to generate the
 * default scenario
 */
// eslint-disable-next-line complexity
exports.generateDefaultScenarioDefinition = (environment) => {
    const { variables, entityOwnership } = environment;
    const keyVariableIds = variables === undefined
        ? []
        : Object.entries(variables)
            .filter((entry) => entry[1].type === 'Key')
            .map(([id]) => id);
    const entityIds = entityOwnership === undefined
        ? []
        : Object.keys(Object.values(entityOwnership).reduce((all, entityId) => (Object.assign(Object.assign({}, all), { [entityId]: true })), {}));
    const valueMap = [...keyVariableIds, ...entityIds]
        .sort(([idA], [idB]) => idA.localeCompare(idB))
        .reduce((all, id, index) => (Object.assign(Object.assign({}, all), { [id]: numbers_1.bigIntToBinUint256BEClamped(BigInt(index + 1)) })), {});
    const privateKeys = variables === undefined
        ? undefined
        : Object.entries(variables).reduce((all, [variableId, variable]) => variable.type === 'Key'
            ? Object.assign(Object.assign({}, all), { [variableId]: hex_1.binToHex(valueMap[variableId]) }) : all, {});
    const defaultScenario = {
        data: Object.assign({ currentBlockHeight: compiler_defaults_1.CompilerDefaults.defaultScenarioCurrentBlockHeight, currentBlockTime: compiler_defaults_1.CompilerDefaults.defaultScenarioCurrentBlockTime }, (privateKeys === undefined || Object.keys(privateKeys).length === 0
            ? {}
            : { keys: { privateKeys } })),
        transaction: {
            inputs: [{ unlockingBytecode: null }],
            locktime: compiler_defaults_1.CompilerDefaults.defaultScenarioTransactionLocktime,
            outputs: [
                {
                    lockingBytecode: compiler_defaults_1.CompilerDefaults.defaultScenarioTransactionOutputsLockingBytecodeHex,
                },
            ],
            version: compiler_defaults_1.CompilerDefaults.defaultScenarioTransactionVersion,
        },
        value: compiler_defaults_1.CompilerDefaults.defaultScenarioValue,
    };
    const hasHdKeys = variables === undefined
        ? false
        : Object.values(variables).findIndex((variable) => variable.type === 'HdKey') !== -1;
    if (!hasHdKeys) {
        return defaultScenario;
    }
    const { sha256, sha512 } = environment;
    if (sha256 === undefined) {
        return 'An implementations of "sha256" is required to generate defaults for HD keys, but the "sha256" property is not included in this compilation environment.';
    }
    if (sha512 === undefined) {
        return 'An implementations of "sha512" is required to generate defaults for HD keys, but the "sha512" property is not included in this compilation environment.';
    }
    const crypto = { sha256, sha512 };
    const hdPrivateKeys = entityIds.reduce((all, entityId) => {
        /**
         * The first 5,000,000,000 seeds have been tested, scenarios are
         * unlikely to exceed this number of entities.
         */
        const assumeValid = true;
        const masterNode = hd_key_1.deriveHdPrivateNodeFromSeed(crypto, valueMap[entityId], assumeValid);
        const hdPrivateKey = hd_key_1.encodeHdPrivateKey(crypto, {
            network: 'mainnet',
            node: masterNode,
        });
        return Object.assign(Object.assign({}, all), { [entityId]: hdPrivateKey });
    }, {});
    return Object.assign(Object.assign({}, defaultScenario), { data: Object.assign(Object.assign({}, defaultScenario.data), { hdKeys: {
                addressIndex: compiler_defaults_1.CompilerDefaults.defaultScenarioAddressIndex,
                hdPrivateKeys,
            } }) });
};
/**
 * Extend the `data` property of a scenario definition with values from a parent
 * scenario definition. Returns the extended value for `data`.
 *
 * @param parentData - the scenario `data` which is extended by the child
 * scenario
 * @param childData - the scenario `data` which may override values from the
 * parent scenario
 */
// eslint-disable-next-line complexity
exports.extendScenarioDefinitionData = (parentData, childData) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, parentData), childData), (parentData.bytecode === undefined && childData.bytecode === undefined
        ? {}
        : {
            bytecode: Object.assign(Object.assign({}, parentData.bytecode), childData.bytecode),
        })), (parentData.hdKeys === undefined && childData.hdKeys === undefined
        ? {}
        : {
            hdKeys: Object.assign(Object.assign(Object.assign(Object.assign({}, parentData.hdKeys), childData.hdKeys), (((_a = parentData.hdKeys) === null || _a === void 0 ? void 0 : _a.hdPrivateKeys) === undefined &&
                ((_b = childData.hdKeys) === null || _b === void 0 ? void 0 : _b.hdPrivateKeys) === undefined
                ? {}
                : {
                    hdPrivateKeys: Object.assign(Object.assign({}, (_c = parentData.hdKeys) === null || _c === void 0 ? void 0 : _c.hdPrivateKeys), (_d = childData.hdKeys) === null || _d === void 0 ? void 0 : _d.hdPrivateKeys),
                })), (((_e = parentData.hdKeys) === null || _e === void 0 ? void 0 : _e.hdPublicKeys) === undefined &&
                ((_f = childData.hdKeys) === null || _f === void 0 ? void 0 : _f.hdPublicKeys) === undefined
                ? {}
                : {
                    hdPublicKeys: Object.assign(Object.assign({}, (_g = parentData.hdKeys) === null || _g === void 0 ? void 0 : _g.hdPublicKeys), (_h = childData.hdKeys) === null || _h === void 0 ? void 0 : _h.hdPublicKeys),
                })),
        })), (parentData.keys === undefined && childData.keys === undefined
        ? {}
        : {
            keys: {
                privateKeys: Object.assign(Object.assign({}, (_j = parentData.keys) === null || _j === void 0 ? void 0 : _j.privateKeys), (_k = childData.keys) === null || _k === void 0 ? void 0 : _k.privateKeys),
            },
        }));
};
/**
 * Extend a child scenario definition with values from a parent scenario
 * definition. Returns the extended values for `data`, `transaction`, and
 * `value`.
 *
 * @param parentScenario - the scenario which is extended by the child scenario
 * @param childScenario - the scenario which may override values from the parent
 * scenario
 */
// eslint-disable-next-line complexity
exports.extendScenarioDefinition = (parentScenario, childScenario) => {
    var _a, _b, _c;
    return Object.assign(Object.assign(Object.assign({}, (parentScenario.data === undefined && childScenario.data === undefined
        ? {}
        : {
            data: exports.extendScenarioDefinitionData((_a = parentScenario.data) !== null && _a !== void 0 ? _a : {}, (_b = childScenario.data) !== null && _b !== void 0 ? _b : {}),
        })), (parentScenario.transaction === undefined &&
        childScenario.transaction === undefined
        ? {}
        : {
            transaction: Object.assign(Object.assign({}, parentScenario.transaction), childScenario.transaction),
        })), (parentScenario.value === undefined && childScenario.value === undefined
        ? {}
        : { value: (_c = childScenario.value) !== null && _c !== void 0 ? _c : parentScenario.value }));
};
/**
 * Generate the full scenario which is extended by the provided scenario
 * identifier. Scenarios for which `extends` is `undefined` extend the default
 * scenario for the provided compilation environment.
 *
 * @param scenarioId - the identifier of the scenario for from which to select
 * the extended scenario
 * @param environment - the compilation environment from which to generate the
 * extended scenario
 * @param sourceScenarioIds - an array of scenario identifiers indicating the
 * path taken to arrive at the current scenario - used to detect and prevent
 * cycles in extending scenarios (defaults to `[]`)
 */
// eslint-disable-next-line complexity
exports.generateExtendedScenario = ({ environment, scenarioId, sourceScenarioIds = [], }) => {
    var _a;
    if (scenarioId === undefined) {
        return exports.generateDefaultScenarioDefinition(environment);
    }
    if (sourceScenarioIds.includes(scenarioId)) {
        return `Cannot extend scenario "${scenarioId}": scenario "${scenarioId}" extends itself. Scenario inheritance path: ${sourceScenarioIds.join(' → ')}`;
    }
    const scenario = (_a = environment.scenarios) === null || _a === void 0 ? void 0 : _a[scenarioId];
    if (scenario === undefined) {
        return `Cannot extend scenario "${scenarioId}": a scenario with the identifier ${scenarioId} is not included in this compilation environment.`;
    }
    const parentScenario = scenario.extends === undefined
        ? exports.generateDefaultScenarioDefinition(environment)
        : exports.generateExtendedScenario({
            environment,
            scenarioId: scenario.extends,
            sourceScenarioIds: [...sourceScenarioIds, scenarioId],
        });
    if (typeof parentScenario === 'string') {
        return parentScenario;
    }
    return exports.extendScenarioDefinition(parentScenario, scenario);
};
/**
 * Derive standard `CompilationData` properties from an extended scenario
 * definition.
 * @param definition - a scenario definition which has been extended by the
 * default scenario definition
 */
// eslint-disable-next-line complexity
exports.extendedScenarioDefinitionToCompilationData = (definition) => {
    var _a;
    return (Object.assign(Object.assign(Object.assign(Object.assign({}, (definition.data.currentBlockHeight === undefined
        ? {}
        : {
            currentBlockHeight: definition.data.currentBlockHeight,
        })), (definition.data.currentBlockTime === undefined
        ? {}
        : {
            currentBlockTime: definition.data.currentBlockTime,
        })), (definition.data.hdKeys === undefined
        ? {}
        : {
            hdKeys: Object.assign(Object.assign(Object.assign({}, (definition.data.hdKeys.addressIndex === undefined
                ? {}
                : {
                    addressIndex: definition.data.hdKeys.addressIndex,
                })), (definition.data.hdKeys.hdPrivateKeys !== undefined &&
                Object.keys(definition.data.hdKeys.hdPrivateKeys).length > 0
                ? {
                    hdPrivateKeys: definition.data.hdKeys.hdPrivateKeys,
                }
                : {})), (definition.data.hdKeys.hdPublicKeys === undefined
                ? {}
                : {
                    hdPublicKeys: definition.data.hdKeys.hdPublicKeys,
                })),
        })), (((_a = definition.data.keys) === null || _a === void 0 ? void 0 : _a.privateKeys) !== undefined &&
        Object.keys(definition.data.keys.privateKeys).length > 0
        ? {
            keys: {
                privateKeys: Object.entries(definition.data.keys.privateKeys).reduce((all, [id, hex]) => (Object.assign(Object.assign({}, all), { [id]: hex_1.hexToBin(hex) })), {}),
            },
        }
        : {})));
};
/**
 * Extend a `CompilationData` object with the compiled result of the bytecode
 * scripts provided by a `AuthenticationTemplateScenarioData`.
 *
 * @param compilationData - the compilation data to extend
 * @param environment - the compilation environment in which to compile the
 * scripts
 * @param scenarioDataBytecodeScripts - the `data.bytecode` property of an
 * `AuthenticationTemplateScenarioData`
 */
exports.extendCompilationDataWithScenarioBytecode = ({ compilationData, environment, scenarioDataBytecodeScripts, }) => {
    const prefixBytecodeScriptId = (id) => `${compiler_defaults_1.CompilerDefaults.scenarioBytecodeScriptPrefix}${id}`;
    const bytecodeScripts = Object.entries(scenarioDataBytecodeScripts).reduce((all, [id, script]) => {
        return Object.assign(Object.assign({}, all), { [prefixBytecodeScriptId(id)]: script });
    }, {});
    const bytecodeScriptExtendedEnvironment = Object.assign(Object.assign({}, environment), { scripts: Object.assign(Object.assign({}, environment.scripts), bytecodeScripts) });
    const bytecodeCompilations = Object.keys(scenarioDataBytecodeScripts).map((id) => {
        const result = compile_1.compileScriptRaw({
            data: compilationData,
            environment: bytecodeScriptExtendedEnvironment,
            scriptId: prefixBytecodeScriptId(id),
        });
        if (result.success) {
            return {
                bytecode: result.bytecode,
                id,
            };
        }
        return {
            errors: result.errors,
            id,
        };
    });
    const failedResults = bytecodeCompilations.filter((result) => 'errors' in result);
    if (failedResults.length > 0) {
        return `${failedResults
            .map((result) => `Compilation error while generating bytecode for "${result.id}": ${language_utils_1.stringifyErrors(result.errors)}`)
            .join('; ')}`;
    }
    const compiledBytecode = bytecodeCompilations.reduce((all, result) => (Object.assign(Object.assign({}, all), { [result.id]: result.bytecode })), {});
    return Object.assign(Object.assign({}, (Object.keys(compiledBytecode).length > 0
        ? { bytecode: compiledBytecode }
        : {})), compilationData);
};
/**
 * The default `lockingBytecode` value for scenario outputs is a new empty
 * object (`{}`).
 */
const getScenarioOutputDefaultLockingBytecode = () => ({});
/**
 * Generate a scenario given a compilation environment. If neither `scenarioId`
 * or `unlockingScriptId` are provided, the default scenario for the compilation
 * environment will be generated.
 *
 * Returns either the full `CompilationData` for the selected scenario or an
 * error message (as a `string`).
 *
 * @param scenarioId - the ID of the scenario to generate – if `undefined`, the
 * default scenario
 * @param unlockingScriptId - the ID of the unlocking script under test by this
 * scenario – if `undefined` but required by the scenario, an error will be
 * produced
 * @param environment - the compilation environment from which to generate the
 * scenario
 */
// eslint-disable-next-line complexity
exports.generateScenarioCommon = ({ environment, scenarioId, unlockingScriptId, }) => {
    var _a, _b;
    const { scenario, scenarioName } = scenarioId === undefined
        ? { scenario: {}, scenarioName: `the default scenario` }
        : {
            scenario: (_a = environment.scenarios) === null || _a === void 0 ? void 0 : _a[scenarioId],
            scenarioName: `scenario "${scenarioId}"`,
        };
    if (scenario === undefined) {
        return `Cannot generate ${scenarioName}: a scenario with the identifier ${scenarioId} is not included in this compilation environment.`;
    }
    const parentScenario = exports.generateExtendedScenario({ environment, scenarioId });
    if (typeof parentScenario === 'string') {
        return `Cannot generate ${scenarioName}: ${parentScenario}`;
    }
    const extendedScenario = exports.extendScenarioDefinition(parentScenario, scenario);
    const partialCompilationData = exports.extendedScenarioDefinitionToCompilationData(extendedScenario);
    const fullCompilationData = exports.extendCompilationDataWithScenarioBytecode({
        compilationData: partialCompilationData,
        environment,
        scenarioDataBytecodeScripts: (_b = extendedScenario.data.bytecode) !== null && _b !== void 0 ? _b : {},
    });
    if (typeof fullCompilationData === 'string') {
        return `Cannot generate ${scenarioName}: ${fullCompilationData}`;
    }
    const testedInputs = extendedScenario.transaction.inputs.filter((input) => input.unlockingBytecode === null);
    if (testedInputs.length !== 1) {
        return `Cannot generate ${scenarioName}: the specific input under test in this scenario is ambiguous – "transaction.inputs" must include exactly one input which has "unlockingBytecode" set to "null".`;
    }
    const testedInputIndex = extendedScenario.transaction.inputs.findIndex((input) => input.unlockingBytecode === null);
    const outputs = extendedScenario.transaction.outputs.map((output) => {
        var _a, _b;
        return ({
            lockingBytecode: (_a = output.lockingBytecode) !== null && _a !== void 0 ? _a : getScenarioOutputDefaultLockingBytecode(),
            satoshis: (_b = output.satoshis) !== null && _b !== void 0 ? _b : compiler_defaults_1.CompilerDefaults.defaultScenarioOutputSatoshis,
        });
    });
    const compiledOutputResults = outputs.map(
    // eslint-disable-next-line complexity
    (output, index) => {
        var _a, _b;
        const satoshis = typeof output.satoshis === 'string'
            ? hex_1.hexToBin(output.satoshis)
            : numbers_1.bigIntToBinUint64LE(BigInt(output.satoshis));
        if (typeof output.lockingBytecode === 'string') {
            return {
                lockingBytecode: hex_1.hexToBin(output.lockingBytecode),
                satoshis,
            };
        }
        const specifiedLockingScriptId = output.lockingBytecode.script;
        const impliedLockingScriptId = unlockingScriptId === undefined
            ? undefined
            : (_a = environment.unlockingScripts) === null || _a === void 0 ? void 0 : _a[unlockingScriptId];
        const scriptId = typeof specifiedLockingScriptId === 'string'
            ? specifiedLockingScriptId
            : impliedLockingScriptId;
        if (scriptId === undefined) {
            if (unlockingScriptId === undefined) {
                return `Cannot generate locking bytecode for output ${index}: this output is set to use the script unlocked by the unlocking script under test, but an unlocking script ID was not provided for scenario generation.`;
            }
            return `Cannot generate locking bytecode for output ${index}: the locking script unlocked by "${unlockingScriptId}" is not provided in this compilation environment.`;
        }
        const overriddenDataDefinition = output.lockingBytecode.overrides === undefined
            ? undefined
            : exports.extendScenarioDefinitionData(extendedScenario.data, output.lockingBytecode.overrides);
        const overriddenCompilationData = overriddenDataDefinition === undefined
            ? undefined
            : exports.extendCompilationDataWithScenarioBytecode({
                compilationData: exports.extendedScenarioDefinitionToCompilationData({
                    data: overriddenDataDefinition,
                }),
                environment,
                scenarioDataBytecodeScripts: (_b = overriddenDataDefinition.bytecode) !== null && _b !== void 0 ? _b : {},
            });
        if (typeof overriddenCompilationData === 'string') {
            return `Cannot generate locking bytecode for output ${index}: ${overriddenCompilationData}`;
        }
        const data = overriddenCompilationData === undefined
            ? fullCompilationData
            : overriddenCompilationData;
        const result = compile_1.compileScript(scriptId, data, environment);
        if (!result.success) {
            return `Cannot generate locking bytecode for output ${index}: ${language_utils_1.stringifyErrors(result.errors)}`;
        }
        return { lockingBytecode: result.bytecode, satoshis };
    });
    const outputCompilationErrors = compiledOutputResults.filter((result) => typeof result === 'string');
    if (outputCompilationErrors.length > 0) {
        return `Cannot generate ${scenarioName}: ${outputCompilationErrors.join('; ')}`;
    }
    const compiledOutputs = compiledOutputResults;
    const sourceSatoshis = typeof extendedScenario.value === 'number'
        ? numbers_1.bigIntToBinUint64LE(BigInt(extendedScenario.value))
        : hex_1.hexToBin(extendedScenario.value);
    const unlockingBytecodeUnderTest = undefined;
    return {
        data: fullCompilationData,
        program: {
            inputIndex: testedInputIndex,
            sourceOutput: { satoshis: sourceSatoshis },
            spendingTransaction: {
                // eslint-disable-next-line complexity
                inputs: extendedScenario.transaction.inputs.map((input) => {
                    var _a, _b, _c;
                    return ({
                        outpointIndex: (_a = input.outpointIndex) !== null && _a !== void 0 ? _a : compiler_defaults_1.CompilerDefaults.defaultScenarioInputOutpointIndex,
                        outpointTransactionHash: hex_1.hexToBin((_b = input.outpointTransactionHash) !== null && _b !== void 0 ? _b : compiler_defaults_1.CompilerDefaults.defaultScenarioInputOutpointTransactionHash),
                        sequenceNumber: (_c = input.sequenceNumber) !== null && _c !== void 0 ? _c : compiler_defaults_1.CompilerDefaults.defaultScenarioInputSequenceNumber,
                        unlockingBytecode: input.unlockingBytecode === null
                            ? unlockingBytecodeUnderTest
                            : hex_1.hexToBin(typeof input.unlockingBytecode === 'string'
                                ? input.unlockingBytecode
                                : compiler_defaults_1.CompilerDefaults.defaultScenarioInputUnlockingBytecodeHex),
                    });
                }),
                locktime: extendedScenario.transaction.locktime,
                outputs: compiledOutputs,
                version: extendedScenario.transaction.version,
            },
        },
    };
};
//# sourceMappingURL=scenarios.js.map