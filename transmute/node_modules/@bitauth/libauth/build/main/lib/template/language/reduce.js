"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reduceScript = exports.verifyBtlEvaluationState = void 0;
const format_1 = require("../../format/format");
const instruction_sets_1 = require("../../vm/instruction-sets/instruction-sets");
const language_utils_1 = require("./language-utils");
const emptyReductionTraceNode = (range) => ({
    bytecode: Uint8Array.of(),
    range,
});
/**
 * Perform the standard verification of BTL evaluation results. This ensures
 * that evaluations complete as expected: if an error occurs while computing an
 * evaluation, script compilation should fail.
 *
 * Three requirements are enforced:
 * - the evaluation may not produce an `error`
 * - the resulting stack must contain exactly 1 item
 * - the resulting execution stack must be empty (no missing `OP_ENDIF`s)
 *
 * This differs from the virtual machine's built-in `vm.verify` in that it is
 * often more lenient, for example, evaluations can succeed with an non-truthy
 * value on top of the stack.
 *
 * @param state - the final program state to verify
 */
exports.verifyBtlEvaluationState = (state) => {
    if (state.error !== undefined) {
        return state.error;
    }
    if (state.executionStack.length !== 0) {
        return instruction_sets_1.AuthenticationErrorCommon.nonEmptyExecutionStack;
    }
    if (state.stack.length !== 1) {
        return instruction_sets_1.AuthenticationErrorCommon.requiresCleanStack;
    }
    return true;
};
/**
 * Reduce a resolved script, returning the resulting bytecode and a trace of the
 * reduction process.
 *
 * This method will return an error if provided a `resolvedScript` with
 * resolution errors. To check for resolution errors, use `getResolutionErrors`.
 *
 * @param resolvedScript - the `CompiledScript` to reduce
 * @param vm - the `AuthenticationVirtualMachine` to use for evaluations
 * @param createEvaluationProgram - a method which accepts the compiled bytecode
 * of an evaluation and returns the authentication program used to evaluate it
 */
exports.reduceScript = (resolvedScript, vm, createEvaluationProgram) => {
    const script = resolvedScript.map((segment) => {
        switch (segment.type) {
            case 'bytecode':
                return { bytecode: segment.value, range: segment.range };
            case 'push': {
                const push = exports.reduceScript(segment.value, vm, createEvaluationProgram);
                const bytecode = instruction_sets_1.encodeDataPush(push.bytecode);
                return Object.assign(Object.assign({ bytecode }, (push.errors === undefined ? undefined : { errors: push.errors })), { push, range: segment.range });
            }
            case 'evaluation': {
                if (typeof vm === 'undefined' ||
                    typeof createEvaluationProgram === 'undefined') {
                    return Object.assign({ errors: [
                            {
                                error: 'Both a VM and a createState method are required to reduce evaluations.',
                                range: segment.range,
                            },
                        ] }, emptyReductionTraceNode(segment.range));
                }
                const reductionTrace = exports.reduceScript(segment.value, vm, createEvaluationProgram);
                if (reductionTrace.errors !== undefined) {
                    return Object.assign(Object.assign({}, emptyReductionTraceNode(segment.range)), { errors: reductionTrace.errors, source: reductionTrace, trace: [] });
                }
                const trace = vm.debug(createEvaluationProgram(reductionTrace.bytecode));
                /**
                 * `vm.debug` should always return at least one state.
                 */
                const lastState = trace[trace.length - 1];
                const result = exports.verifyBtlEvaluationState(lastState);
                const bytecode = lastState.stack[lastState.stack.length - 1];
                return Object.assign(Object.assign({}, (typeof result === 'string'
                    ? {
                        bytecode: Uint8Array.of(),
                        errors: [
                            {
                                error: `Failed to reduce evaluation: ${result}`,
                                range: segment.range,
                            },
                        ],
                    }
                    : {
                        bytecode,
                    })), { range: segment.range, source: reductionTrace, trace });
            }
            case 'comment':
                return emptyReductionTraceNode(segment.range);
            case 'error':
                return Object.assign({ errors: [
                        {
                            error: `Tried to reduce a BTL script with resolution errors: ${segment.value}`,
                            range: segment.range,
                        },
                    ] }, emptyReductionTraceNode(segment.range));
            // eslint-disable-next-line functional/no-conditional-statement
            default:
                // eslint-disable-next-line functional/no-throw-statement, @typescript-eslint/no-throw-literal, no-throw-literal
                throw new Error(`"${segment.type}" is not a known segment type.`);
        }
    });
    const reduction = script.reduce((all, segment) => (Object.assign({ bytecode: [...all.bytecode, segment.bytecode], ranges: [...all.ranges, segment.range] }, (all.errors !== undefined || segment.errors !== undefined
        ? {
            errors: [
                ...(all.errors === undefined ? [] : all.errors),
                ...(segment.errors === undefined ? [] : segment.errors),
            ],
        }
        : undefined))), { bytecode: [], ranges: [] });
    return Object.assign(Object.assign({}, (reduction.errors === undefined
        ? undefined
        : { errors: reduction.errors })), { bytecode: format_1.flattenBinArray(reduction.bytecode), range: language_utils_1.mergeRanges(reduction.ranges, resolvedScript.length === 0 ? undefined : resolvedScript[0].range), script });
};
//# sourceMappingURL=reduce.js.map