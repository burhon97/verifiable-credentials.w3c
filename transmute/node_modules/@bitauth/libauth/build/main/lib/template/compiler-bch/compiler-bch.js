"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.authenticationTemplateToCompilerBCH = exports.createCompilerBCH = exports.compilerOperationsBCH = exports.compilerOperationSigningSerializationFullBCH = exports.compilerOperationHdKeySchnorrDataSignatureBCH = exports.compilerOperationHdKeyEcdsaDataSignatureBCH = exports.compilerOperationHelperHdKeyDataSignatureBCH = exports.compilerOperationKeySchnorrDataSignatureBCH = exports.compilerOperationKeyEcdsaDataSignatureBCH = exports.compilerOperationHelperKeyDataSignatureBCH = exports.compilerOperationHelperComputeDataSignatureBCH = exports.compilerOperationKeySchnorrSignatureBCH = exports.compilerOperationKeyEcdsaSignatureBCH = exports.compilerOperationHelperKeySignatureBCH = exports.compilerOperationHdKeySchnorrSignatureBCH = exports.compilerOperationHdKeyEcdsaSignatureBCH = exports.compilerOperationHelperHdKeySignatureBCH = exports.compilerOperationHelperComputeSignatureBCH = exports.SigningSerializationAlgorithmIdentifier = void 0;
const crypto_1 = require("../../crypto/crypto");
const signing_serialization_1 = require("../../vm/instruction-sets/common/signing-serialization");
const instruction_sets_1 = require("../../vm/instruction-sets/instruction-sets");
const virtual_machine_1 = require("../../vm/virtual-machine");
const compiler_1 = require("../compiler");
const compiler_operation_helpers_1 = require("../compiler-operation-helpers");
const compiler_operations_1 = require("../compiler-operations");
var SigningSerializationAlgorithmIdentifier;
(function (SigningSerializationAlgorithmIdentifier) {
    /**
     * A.K.A. `SIGHASH_ALL`
     */
    SigningSerializationAlgorithmIdentifier["allOutputs"] = "all_outputs";
    /**
     * A.K.A. `SIGHASH_ALL|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["allOutputsSingleInput"] = "all_outputs_single_input";
    /**
     * A.K.A. `SIGHASH_SINGLE`
     */
    SigningSerializationAlgorithmIdentifier["correspondingOutput"] = "corresponding_output";
    /**
     * A.K.A. `SIGHASH_SINGLE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["correspondingOutputSingleInput"] = "corresponding_output_single_input";
    /**
     * A.K.A `SIGHASH_NONE`
     */
    SigningSerializationAlgorithmIdentifier["noOutputs"] = "no_outputs";
    /**
     * A.K.A `SIGHASH_NONE|ANYONE_CAN_PAY`
     */
    SigningSerializationAlgorithmIdentifier["noOutputsSingleInput"] = "no_outputs_single_input";
})(SigningSerializationAlgorithmIdentifier = exports.SigningSerializationAlgorithmIdentifier || (exports.SigningSerializationAlgorithmIdentifier = {}));
// eslint-disable-next-line complexity
const getSigningSerializationType = (algorithmIdentifier, prefix = '') => {
    switch (algorithmIdentifier) {
        case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.allOutputs | signing_serialization_1.SigningSerializationFlag.forkId);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.allOutputsSingleInput}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.allOutputs |
                signing_serialization_1.SigningSerializationFlag.singleInput |
                signing_serialization_1.SigningSerializationFlag.forkId);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutput}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.correspondingOutput |
                signing_serialization_1.SigningSerializationFlag.forkId);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.correspondingOutputSingleInput}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.correspondingOutput |
                signing_serialization_1.SigningSerializationFlag.singleInput |
                signing_serialization_1.SigningSerializationFlag.forkId);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputs}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.noOutputs | signing_serialization_1.SigningSerializationFlag.forkId);
        case `${prefix}${SigningSerializationAlgorithmIdentifier.noOutputsSingleInput}`:
            return Uint8Array.of(
            // eslint-disable-next-line no-bitwise
            signing_serialization_1.SigningSerializationFlag.noOutputs |
                signing_serialization_1.SigningSerializationFlag.singleInput |
                signing_serialization_1.SigningSerializationFlag.forkId);
        default:
            return undefined;
    }
};
exports.compilerOperationHelperComputeSignatureBCH = ({ coveredBytecode, identifier, transactionContext, operationName, privateKey, sha256, sign, }) => {
    const [, , algorithm, unknown] = identifier.split('.');
    if (unknown !== undefined) {
        return {
            error: `Unknown component in "${identifier}" – the fragment "${unknown}" is not recognized.`,
            status: 'error',
        };
    }
    if (algorithm === undefined) {
        return {
            error: `Invalid signature identifier. Signatures must be of the form: "[variable_id].${operationName}.[signing_serialization_type]".`,
            status: 'error',
        };
    }
    const signingSerializationType = getSigningSerializationType(algorithm);
    if (signingSerializationType === undefined) {
        return {
            error: `Unknown signing serialization algorithm, "${algorithm}".`,
            status: 'error',
        };
    }
    const serialization = signing_serialization_1.generateSigningSerializationBCH({
        correspondingOutput: transactionContext.correspondingOutput,
        coveredBytecode,
        locktime: transactionContext.locktime,
        outpointIndex: transactionContext.outpointIndex,
        outpointTransactionHash: transactionContext.outpointTransactionHash,
        outputValue: transactionContext.outputValue,
        sequenceNumber: transactionContext.sequenceNumber,
        sha256,
        signingSerializationType,
        transactionOutpoints: transactionContext.transactionOutpoints,
        transactionOutputs: transactionContext.transactionOutputs,
        transactionSequenceNumbers: transactionContext.transactionSequenceNumbers,
        version: transactionContext.version,
    });
    const digest = sha256.hash(sha256.hash(serialization));
    const bitcoinEncodedSignature = Uint8Array.from([
        ...sign(privateKey, digest),
        ...signingSerializationType,
    ]);
    return {
        bytecode: bitcoinEncodedSignature,
        signature: { serialization },
        status: 'success',
    };
};
exports.compilerOperationHelperHdKeySignatureBCH = ({ operationName, secp256k1Method, }) => compiler_operation_helpers_1.attemptCompilerOperations([compiler_operation_helpers_1.compilerOperationAttemptBytecodeResolution], compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['hdKeys', 'transactionContext'],
    environmentProperties: [
        'entityOwnership',
        'ripemd160',
        'secp256k1',
        'sha256',
        'sha512',
        'variables',
        'sourceScriptIds',
        'unlockingScripts',
    ],
    operation: (identifier, data, environment) => {
        const { hdKeys, transactionContext } = data;
        const { secp256k1, sha256, sourceScriptIds, unlockingScripts, } = environment;
        const derivationResult = compiler_operation_helpers_1.compilerOperationHelperDeriveHdKeyPrivate({
            environment,
            hdKeys,
            identifier,
        });
        if (derivationResult.status === 'error')
            return derivationResult;
        const result = compiler_operation_helpers_1.compilerOperationHelperGenerateCoveredBytecode({
            data,
            environment,
            identifier,
            sourceScriptIds,
            unlockingScripts,
        });
        if ('error' in result) {
            return result;
        }
        return exports.compilerOperationHelperComputeSignatureBCH({
            coveredBytecode: result,
            identifier,
            operationName,
            privateKey: derivationResult.bytecode,
            sha256,
            sign: secp256k1[secp256k1Method],
            transactionContext,
        });
    },
}));
exports.compilerOperationHdKeyEcdsaSignatureBCH = exports.compilerOperationHelperHdKeySignatureBCH({
    operationName: 'signature',
    secp256k1Method: 'signMessageHashDER',
});
exports.compilerOperationHdKeySchnorrSignatureBCH = exports.compilerOperationHelperHdKeySignatureBCH({
    operationName: 'schnorr_signature',
    secp256k1Method: 'signMessageHashSchnorr',
});
exports.compilerOperationHelperKeySignatureBCH = ({ operationName, secp256k1Method, }) => compiler_operation_helpers_1.attemptCompilerOperations([compiler_operation_helpers_1.compilerOperationAttemptBytecodeResolution], compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['keys', 'transactionContext'],
    environmentProperties: [
        'sha256',
        'secp256k1',
        'unlockingScripts',
        'sourceScriptIds',
    ],
    operation: (identifier, data, environment) => {
        const { keys, transactionContext } = data;
        const { secp256k1, sha256, unlockingScripts, sourceScriptIds, } = environment;
        const { privateKeys } = keys;
        const [variableId] = identifier.split('.');
        const privateKey = privateKeys === undefined ? undefined : privateKeys[variableId];
        if (privateKey === undefined) {
            return {
                error: `Identifier "${identifier}" refers to a Key, but a private key for "${variableId}" (or an existing signature) was not provided in the compilation data.`,
                recoverable: true,
                status: 'error',
            };
        }
        const result = compiler_operation_helpers_1.compilerOperationHelperGenerateCoveredBytecode({
            data,
            environment,
            identifier,
            sourceScriptIds,
            unlockingScripts,
        });
        if ('error' in result) {
            return result;
        }
        return exports.compilerOperationHelperComputeSignatureBCH({
            coveredBytecode: result,
            identifier,
            operationName,
            privateKey,
            sha256,
            sign: secp256k1[secp256k1Method],
            transactionContext,
        });
    },
}));
exports.compilerOperationKeyEcdsaSignatureBCH = exports.compilerOperationHelperKeySignatureBCH({
    operationName: 'signature',
    secp256k1Method: 'signMessageHashDER',
});
exports.compilerOperationKeySchnorrSignatureBCH = exports.compilerOperationHelperKeySignatureBCH({
    operationName: 'schnorr_signature',
    secp256k1Method: 'signMessageHashSchnorr',
});
exports.compilerOperationHelperComputeDataSignatureBCH = ({ data, environment, identifier, operationName, privateKey, sha256, sign, }) => {
    const [, , scriptId, unknown] = identifier.split('.');
    if (unknown !== undefined) {
        return {
            error: `Unknown component in "${identifier}" – the fragment "${unknown}" is not recognized.`,
            status: 'error',
        };
    }
    if (scriptId === undefined) {
        return {
            error: `Invalid data signature identifier. Data signatures must be of the form: "[variable_id].${operationName}.[target_script_id]".`,
            status: 'error',
        };
    }
    const result = compiler_operation_helpers_1.compilerOperationHelperCompileScript({
        data,
        environment,
        targetScriptId: scriptId,
    });
    if (result === false) {
        return {
            error: `Data signature tried to sign an unknown target script, "${scriptId}".`,
            status: 'error',
        };
    }
    if ('error' in result) {
        return result;
    }
    const digest = sha256.hash(result);
    return {
        bytecode: sign(privateKey, digest),
        signature: { message: result },
        status: 'success',
    };
};
exports.compilerOperationHelperKeyDataSignatureBCH = ({ operationName, secp256k1Method, }) => compiler_operation_helpers_1.attemptCompilerOperations([compiler_operation_helpers_1.compilerOperationAttemptBytecodeResolution], compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['keys'],
    environmentProperties: ['sha256', 'secp256k1'],
    operation: (identifier, data, environment) => {
        const { keys } = data;
        const { secp256k1, sha256 } = environment;
        const { privateKeys } = keys;
        const [variableId] = identifier.split('.');
        const privateKey = privateKeys === undefined ? undefined : privateKeys[variableId];
        if (privateKey === undefined) {
            return {
                error: `Identifier "${identifier}" refers to a Key, but a private key for "${variableId}" (or an existing signature) was not provided in the compilation data.`,
                recoverable: true,
                status: 'error',
            };
        }
        return exports.compilerOperationHelperComputeDataSignatureBCH({
            data,
            environment,
            identifier,
            operationName,
            privateKey,
            sha256,
            sign: secp256k1[secp256k1Method],
        });
    },
}));
exports.compilerOperationKeyEcdsaDataSignatureBCH = exports.compilerOperationHelperKeyDataSignatureBCH({
    operationName: 'data_signature',
    secp256k1Method: 'signMessageHashDER',
});
exports.compilerOperationKeySchnorrDataSignatureBCH = exports.compilerOperationHelperKeyDataSignatureBCH({
    operationName: 'schnorr_data_signature',
    secp256k1Method: 'signMessageHashSchnorr',
});
exports.compilerOperationHelperHdKeyDataSignatureBCH = ({ operationName, secp256k1Method, }) => compiler_operation_helpers_1.attemptCompilerOperations([compiler_operation_helpers_1.compilerOperationAttemptBytecodeResolution], compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['hdKeys'],
    environmentProperties: [
        'entityOwnership',
        'ripemd160',
        'secp256k1',
        'sha256',
        'sha512',
        'variables',
    ],
    operation: (identifier, data, environment) => {
        const { hdKeys } = data;
        const { secp256k1, sha256 } = environment;
        const derivationResult = compiler_operation_helpers_1.compilerOperationHelperDeriveHdKeyPrivate({
            environment,
            hdKeys,
            identifier,
        });
        if (derivationResult.status === 'error')
            return derivationResult;
        return exports.compilerOperationHelperComputeDataSignatureBCH({
            data,
            environment,
            identifier,
            operationName,
            privateKey: derivationResult.bytecode,
            sha256,
            sign: secp256k1[secp256k1Method],
        });
    },
}));
exports.compilerOperationHdKeyEcdsaDataSignatureBCH = exports.compilerOperationHelperHdKeyDataSignatureBCH({
    operationName: 'data_signature',
    secp256k1Method: 'signMessageHashDER',
});
exports.compilerOperationHdKeySchnorrDataSignatureBCH = exports.compilerOperationHelperHdKeyDataSignatureBCH({
    operationName: 'schnorr_data_signature',
    secp256k1Method: 'signMessageHashSchnorr',
});
exports.compilerOperationSigningSerializationFullBCH = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: ['sha256', 'sourceScriptIds', 'unlockingScripts'],
    operation: (identifier, data, environment) => {
        const [, algorithmOrComponent, unknownPart] = identifier.split('.');
        if (algorithmOrComponent === undefined) {
            return {
                error: `Invalid signing serialization operation. Include the desired component or algorithm, e.g. "signing_serialization.version".`,
                status: 'error',
            };
        }
        if (unknownPart !== undefined) {
            return {
                error: `Unknown component in "${identifier}" – the fragment "${unknownPart}" is not recognized.`,
                status: 'error',
            };
        }
        const signingSerializationType = getSigningSerializationType(algorithmOrComponent, 'full_');
        if (signingSerializationType === undefined) {
            return {
                error: `Unknown signing serialization algorithm, "${algorithmOrComponent}".`,
                status: 'error',
            };
        }
        const { sha256, sourceScriptIds, unlockingScripts } = environment;
        const result = compiler_operation_helpers_1.compilerOperationHelperGenerateCoveredBytecode({
            data,
            environment,
            identifier,
            sourceScriptIds,
            unlockingScripts,
        });
        if ('error' in result) {
            return result;
        }
        const { transactionContext } = data;
        return {
            bytecode: signing_serialization_1.generateSigningSerializationBCH({
                correspondingOutput: transactionContext.correspondingOutput,
                coveredBytecode: result,
                locktime: transactionContext.locktime,
                outpointIndex: transactionContext.outpointIndex,
                outpointTransactionHash: transactionContext.outpointTransactionHash,
                outputValue: transactionContext.outputValue,
                sequenceNumber: transactionContext.sequenceNumber,
                sha256,
                signingSerializationType,
                transactionOutpoints: transactionContext.transactionOutpoints,
                transactionOutputs: transactionContext.transactionOutputs,
                transactionSequenceNumbers: transactionContext.transactionSequenceNumbers,
                version: transactionContext.version,
            }),
            status: 'success',
        };
    },
});
/* eslint-disable camelcase, @typescript-eslint/naming-convention */
exports.compilerOperationsBCH = Object.assign(Object.assign({}, compiler_operations_1.compilerOperationsCommon), { hdKey: {
        data_signature: exports.compilerOperationHdKeyEcdsaDataSignatureBCH,
        public_key: compiler_operations_1.compilerOperationsCommon.hdKey.public_key,
        schnorr_data_signature: exports.compilerOperationHdKeySchnorrDataSignatureBCH,
        schnorr_signature: exports.compilerOperationHdKeySchnorrSignatureBCH,
        signature: exports.compilerOperationHdKeyEcdsaSignatureBCH,
    }, key: {
        data_signature: exports.compilerOperationKeyEcdsaDataSignatureBCH,
        public_key: compiler_operations_1.compilerOperationsCommon.key.public_key,
        schnorr_data_signature: exports.compilerOperationKeySchnorrDataSignatureBCH,
        schnorr_signature: exports.compilerOperationKeySchnorrSignatureBCH,
        signature: exports.compilerOperationKeyEcdsaSignatureBCH,
    }, signingSerialization: Object.assign(Object.assign({}, compiler_operations_1.compilerOperationsCommon.signingSerialization), { full_all_outputs: exports.compilerOperationSigningSerializationFullBCH, full_all_outputs_single_input: exports.compilerOperationSigningSerializationFullBCH, full_corresponding_output: exports.compilerOperationSigningSerializationFullBCH, full_corresponding_output_single_input: exports.compilerOperationSigningSerializationFullBCH, full_no_outputs: exports.compilerOperationSigningSerializationFullBCH, full_no_outputs_single_input: exports.compilerOperationSigningSerializationFullBCH }) });
/**
 * Create a compiler using the default BCH environment.
 *
 * Internally instantiates the necessary crypto and VM implementations – use
 * `createCompiler` for more control.
 *
 * @param scriptsAndOverrides - a compilation environment from which properties
 * will be used to override properties of the default BCH environment – must
 * include the `scripts` property
 */
exports.createCompilerBCH = async (scriptsAndOverrides) => {
    const [sha1, sha256, sha512, ripemd160, secp256k1] = await Promise.all([
        crypto_1.instantiateSha1(),
        crypto_1.instantiateSha256(),
        crypto_1.instantiateSha512(),
        crypto_1.instantiateRipemd160(),
        crypto_1.instantiateSecp256k1(),
    ]);
    const vm = virtual_machine_1.createAuthenticationVirtualMachine(instruction_sets_1.createInstructionSetBCH({
        flags: instruction_sets_1.getFlagsForInstructionSetBCH(instruction_sets_1.instructionSetBCHCurrentStrict),
        ripemd160,
        secp256k1,
        sha1,
        sha256,
    }));
    return compiler_1.createCompiler(Object.assign({
        createAuthenticationProgram: compiler_1.createAuthenticationProgramEvaluationCommon,
        opcodes: instruction_sets_1.generateBytecodeMap(instruction_sets_1.OpcodesBCH),
        operations: exports.compilerOperationsBCH,
        ripemd160,
        secp256k1,
        sha256,
        sha512,
        vm,
    }, scriptsAndOverrides));
};
/**
 * Create a BCH `Compiler` from an `AuthenticationTemplate` and an optional set
 * of overrides.
 * @param template - the `AuthenticationTemplate` from which to create the BCH
 * compiler
 * @param overrides - a compilation environment from which properties will be
 * used to override properties of the default BCH environment
 */
exports.authenticationTemplateToCompilerBCH = async (template, overrides) => exports.createCompilerBCH(Object.assign(Object.assign({}, overrides), compiler_1.authenticationTemplateToCompilationEnvironment(template)));
//# sourceMappingURL=compiler-bch.js.map