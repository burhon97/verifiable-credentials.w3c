"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileScript = exports.compileScriptP2shUnlocking = exports.compileScriptP2shLocking = exports.compileScriptRaw = exports.compileScriptContents = exports.describeExpectedInput = void 0;
const compiler_1 = require("../compiler");
const language_utils_1 = require("./language-utils");
const parse_1 = require("./parse");
const reduce_1 = require("./reduce");
const resolve_1 = require("./resolve");
/**
 * A text-formatting method to pretty-print the list of expected inputs
 * (`Encountered unexpected input while parsing script. Expected ...`). If
 * present, the `EOF` expectation is always moved to the end of the list.
 * @param expectedArray - the alphabetized list of expected inputs produced by
 * `parseScript`
 */
exports.describeExpectedInput = (expectedArray) => {
    /**
     * The constant used by the parser to denote the end of the input
     */
    const EOF = 'EOF';
    const newArray = expectedArray.filter((value) => value !== EOF);
    // eslint-disable-next-line functional/no-conditional-statement
    if (newArray.length !== expectedArray.length) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        newArray.push('the end of the script');
    }
    const withoutLastElement = newArray.slice(0, newArray.length - 1);
    const lastElement = newArray[newArray.length - 1];
    const arrayRequiresCommas = 3;
    const arrayRequiresOr = 2;
    return `Encountered unexpected input while parsing script. Expected ${newArray.length >= arrayRequiresCommas
        ? withoutLastElement.join(', ').concat(`, or ${lastElement}`)
        : newArray.length === arrayRequiresOr
            ? newArray.join(' or ')
            : lastElement}.`;
};
/**
 * This method is generally for internal use. The `compileScript` method is the
 * recommended API for direct compilation.
 */
exports.compileScriptContents = ({ data, environment, script, }) => {
    const parseResult = parse_1.parseScript(script);
    if (!parseResult.status) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: exports.describeExpectedInput(parseResult.expected),
                    range: {
                        endColumn: parseResult.index.column,
                        endLineNumber: parseResult.index.line,
                        startColumn: parseResult.index.column,
                        startLineNumber: parseResult.index.line,
                    },
                },
            ],
            success: false,
        };
    }
    const resolver = resolve_1.createIdentifierResolver({ data, environment });
    const resolvedScript = resolve_1.resolveScriptSegment(parseResult.value, resolver);
    const resolutionErrors = language_utils_1.getResolutionErrors(resolvedScript);
    if (resolutionErrors.length !== 0) {
        return {
            errorType: 'resolve',
            errors: resolutionErrors,
            parse: parseResult.value,
            resolve: resolvedScript,
            success: false,
        };
    }
    const reduction = reduce_1.reduceScript(resolvedScript, environment.vm, environment.createAuthenticationProgram);
    return Object.assign(Object.assign({}, (reduction.errors === undefined
        ? { bytecode: reduction.bytecode, success: true }
        : { errorType: 'reduce', errors: reduction.errors, success: false })), { parse: parseResult.value, reduce: reduction, resolve: resolvedScript });
};
const emptyRange = () => ({
    endColumn: 0,
    endLineNumber: 0,
    startColumn: 0,
    startLineNumber: 0,
});
/**
 * This method is generally for internal use. The `compileScript` method is the
 * recommended API for direct compilation.
 */
exports.compileScriptRaw = ({ data, environment, scriptId, }) => {
    var _a;
    const script = environment.scripts[scriptId];
    if (script === undefined) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: `No script with an ID of "${scriptId}" was provided in the compilation environment.`,
                    range: emptyRange(),
                },
            ],
            success: false,
        };
    }
    if (((_a = environment.sourceScriptIds) === null || _a === void 0 ? void 0 : _a.includes(scriptId)) === true) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: `A circular dependency was encountered: script "${scriptId}" relies on itself to be generated. (Source scripts: ${environment.sourceScriptIds.join(' â†’ ')})`,
                    range: emptyRange(),
                },
            ],
            success: false,
        };
    }
    const sourceScriptIds = environment.sourceScriptIds === undefined
        ? [scriptId]
        : [...environment.sourceScriptIds, scriptId];
    return exports.compileScriptContents({
        data,
        environment: Object.assign(Object.assign({}, environment), { sourceScriptIds }),
        script,
    });
};
exports.compileScriptP2shLocking = ({ lockingBytecode, vm, }) => {
    const compiler = compiler_1.createCompilerCommonSynchronous({
        scripts: {
            p2shLocking: 'OP_HASH160 <$(<lockingBytecode> OP_HASH160)> OP_EQUAL',
        },
        variables: { lockingBytecode: { type: 'AddressData' } },
        vm,
    });
    return compiler.generateBytecode('p2shLocking', {
        bytecode: { lockingBytecode },
    });
};
exports.compileScriptP2shUnlocking = ({ lockingBytecode, unlockingBytecode, }) => {
    const compiler = compiler_1.createCompilerCommonSynchronous({
        scripts: {
            p2shUnlocking: 'unlockingBytecode <lockingBytecode>',
        },
        variables: {
            lockingBytecode: { type: 'AddressData' },
            unlockingBytecode: { type: 'AddressData' },
        },
    });
    return compiler.generateBytecode('p2shUnlocking', {
        bytecode: { lockingBytecode, unlockingBytecode },
    });
};
/**
 * Parse, resolve, and reduce the selected script using the provided `data` and
 * `environment`.
 *
 * Note, locktime validation only occurs if `transactionContext` is provided in
 * the environment.
 */
// eslint-disable-next-line complexity
exports.compileScript = (scriptId, data, environment) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const locktimeDisablingSequenceNumber = 0xffffffff;
    const lockTimeTypeBecomesTimestamp = 500000000;
    if (((_a = data.transactionContext) === null || _a === void 0 ? void 0 : _a.locktime) !== undefined) {
        if (((_b = environment.unlockingScriptTimeLockTypes) === null || _b === void 0 ? void 0 : _b[scriptId]) === 'height' &&
            data.transactionContext.locktime >= lockTimeTypeBecomesTimestamp) {
            return {
                errorType: 'parse',
                errors: [
                    {
                        error: `The script "${scriptId}" requires a height-based locktime (less than 500,000,000), but this transaction uses a timestamp-based locktime ("${data.transactionContext.locktime}").`,
                        range: emptyRange(),
                    },
                ],
                success: false,
            };
        }
        if (((_c = environment.unlockingScriptTimeLockTypes) === null || _c === void 0 ? void 0 : _c[scriptId]) === 'timestamp' &&
            data.transactionContext.locktime < lockTimeTypeBecomesTimestamp) {
            return {
                errorType: 'parse',
                errors: [
                    {
                        error: `The script "${scriptId}" requires a timestamp-based locktime (greater than or equal to 500,000,000), but this transaction uses a height-based locktime ("${data.transactionContext.locktime}").`,
                        range: emptyRange(),
                    },
                ],
                success: false,
            };
        }
    }
    if (((_d = data.transactionContext) === null || _d === void 0 ? void 0 : _d.sequenceNumber) !== undefined &&
        ((_e = environment.unlockingScriptTimeLockTypes) === null || _e === void 0 ? void 0 : _e[scriptId]) !== undefined &&
        data.transactionContext.sequenceNumber === locktimeDisablingSequenceNumber) {
        return {
            errorType: 'parse',
            errors: [
                {
                    error: `The script "${scriptId}" requires a locktime, but this input's sequence number is set to disable transaction locktime (0xffffffff). This will cause the OP_CHECKLOCKTIMEVERIFY operation to error when the transaction is verified. To be valid, this input must use a sequence number which does not disable locktime.`,
                    range: emptyRange(),
                },
            ],
            success: false,
        };
    }
    const rawResult = exports.compileScriptRaw({
        data,
        environment,
        scriptId,
    });
    if (!rawResult.success) {
        return rawResult;
    }
    const unlocks = (_f = environment.unlockingScripts) === null || _f === void 0 ? void 0 : _f[scriptId];
    const unlockingScriptType = unlocks === undefined
        ? undefined
        : (_g = environment.lockingScriptTypes) === null || _g === void 0 ? void 0 : _g[unlocks];
    const isP2shUnlockingScript = unlockingScriptType === 'p2sh';
    const lockingScriptType = (_h = environment.lockingScriptTypes) === null || _h === void 0 ? void 0 : _h[scriptId];
    const isP2shLockingScript = lockingScriptType === 'p2sh';
    if (isP2shLockingScript) {
        const transformedResult = exports.compileScriptP2shLocking({
            lockingBytecode: rawResult.bytecode,
            vm: environment.vm,
        });
        if (!transformedResult.success) {
            return transformedResult;
        }
        return Object.assign(Object.assign({}, rawResult), { bytecode: transformedResult.bytecode, transformed: 'p2sh-locking' });
    }
    if (isP2shUnlockingScript) {
        const lockingBytecodeResult = exports.compileScriptRaw({
            data,
            environment,
            scriptId: unlocks,
        });
        if (!lockingBytecodeResult.success) {
            return lockingBytecodeResult;
        }
        const transformedResult = exports.compileScriptP2shUnlocking({
            lockingBytecode: lockingBytecodeResult.bytecode,
            unlockingBytecode: rawResult.bytecode,
        });
        return Object.assign(Object.assign({}, rawResult), { bytecode: transformedResult.bytecode, transformed: 'p2sh-unlocking' });
    }
    return rawResult;
};
//# sourceMappingURL=compile.js.map