"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compilerOperationsCommon = exports.compilerOperationHdKeyPublicKeyCommon = exports.compilerOperationKeyPublicKeyCommon = exports.compilerOperationSigningSerializationVersion = exports.compilerOperationSigningSerializationTransactionSequenceNumbersHash = exports.compilerOperationSigningSerializationTransactionSequenceNumbers = exports.compilerOperationSigningSerializationTransactionOutputsHash = exports.compilerOperationSigningSerializationTransactionOutputs = exports.compilerOperationSigningSerializationTransactionOutpointsHash = exports.compilerOperationSigningSerializationTransactionOutpoints = exports.compilerOperationSigningSerializationSequenceNumber = exports.compilerOperationSigningSerializationOutputValue = exports.compilerOperationSigningSerializationOutpointTransactionHash = exports.compilerOperationSigningSerializationOutpointIndex = exports.compilerOperationSigningSerializationLocktime = exports.compilerOperationSigningSerializationCoveredBytecodeLength = exports.compilerOperationSigningSerializationCoveredBytecode = exports.compilerOperationSigningSerializationCorrespondingOutputHash = exports.compilerOperationSigningSerializationCorrespondingOutput = exports.compilerOperationCurrentBlockHeight = exports.compilerOperationCurrentBlockTime = exports.compilerOperationWalletData = exports.compilerOperationAddressData = void 0;
const numbers_1 = require("../format/numbers");
const hd_key_1 = require("../key/hd-key");
const instruction_sets_1 = require("../vm/instruction-sets/instruction-sets");
const compiler_defaults_1 = require("./compiler-defaults");
const compiler_operation_helpers_1 = require("./compiler-operation-helpers");
exports.compilerOperationAddressData = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['bytecode'],
    environmentProperties: [],
    operation: (identifier, data) => {
        const { bytecode } = data;
        if (identifier in bytecode) {
            return { bytecode: bytecode[identifier], status: 'success' };
        }
        return {
            error: `Identifier "${identifier}" refers to an AddressData, but "${identifier}" was not provided in the CompilationData "bytecode".`,
            recoverable: true,
            status: 'error',
        };
    },
});
exports.compilerOperationWalletData = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['bytecode'],
    environmentProperties: [],
    operation: (identifier, data) => {
        const { bytecode } = data;
        if (identifier in bytecode) {
            return { bytecode: bytecode[identifier], status: 'success' };
        }
        return {
            error: `Identifier "${identifier}" refers to a WalletData, but "${identifier}" was not provided in the CompilationData "bytecode".`,
            recoverable: true,
            status: 'error',
        };
    },
});
exports.compilerOperationCurrentBlockTime = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['currentBlockTime'],
    environmentProperties: [],
    operation: (_, data) => {
        return {
            bytecode: numbers_1.numberToBinUint32LE(data.currentBlockTime),
            status: 'success',
        };
    },
});
exports.compilerOperationCurrentBlockHeight = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['currentBlockHeight'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: instruction_sets_1.bigIntToScriptNumber(BigInt(data.currentBlockHeight)),
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationCorrespondingOutput = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => data.transactionContext.correspondingOutput === undefined
        ? { bytecode: Uint8Array.of(), status: 'success' }
        : {
            bytecode: data.transactionContext.correspondingOutput,
            status: 'success',
        },
});
exports.compilerOperationSigningSerializationCorrespondingOutputHash = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: ['sha256'],
    operation: (_, data, environment) => data.transactionContext.correspondingOutput === undefined
        ? { bytecode: Uint8Array.of(), status: 'success' }
        : {
            bytecode: environment.sha256.hash(environment.sha256.hash(data.transactionContext.correspondingOutput)),
            status: 'success',
        },
});
const compilerOperationHelperSigningSerializationCoveredBytecode = (returnLength) => compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: ['sourceScriptIds', 'unlockingScripts'],
    operation: (identifier, data, environment) => {
        const { unlockingScripts, sourceScriptIds } = environment;
        const result = compiler_operation_helpers_1.compilerOperationHelperGenerateCoveredBytecode({
            data,
            environment,
            identifier,
            sourceScriptIds,
            unlockingScripts,
        });
        if ('error' in result) {
            return result;
        }
        return {
            bytecode: returnLength
                ? numbers_1.bigIntToBitcoinVarInt(BigInt(result.length))
                : result,
            status: 'success',
        };
    },
});
exports.compilerOperationSigningSerializationCoveredBytecode = compilerOperationHelperSigningSerializationCoveredBytecode(false);
exports.compilerOperationSigningSerializationCoveredBytecodeLength = compilerOperationHelperSigningSerializationCoveredBytecode(true);
exports.compilerOperationSigningSerializationLocktime = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: numbers_1.numberToBinUint32LE(data.transactionContext.locktime),
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationOutpointIndex = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: numbers_1.numberToBinUint32LE(data.transactionContext.outpointIndex),
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationOutpointTransactionHash = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: data.transactionContext.outpointTransactionHash,
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationOutputValue = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: data.transactionContext.outputValue,
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationSequenceNumber = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: numbers_1.numberToBinUint32LE(data.transactionContext.sequenceNumber),
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationTransactionOutpoints = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: data.transactionContext.transactionOutpoints,
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationTransactionOutpointsHash = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: ['sha256'],
    operation: (_, data, environment) => ({
        bytecode: environment.sha256.hash(environment.sha256.hash(data.transactionContext.transactionOutpoints)),
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationTransactionOutputs = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: data.transactionContext.transactionOutputs,
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationTransactionOutputsHash = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: ['sha256'],
    operation: (_, data, environment) => ({
        bytecode: environment.sha256.hash(environment.sha256.hash(data.transactionContext.transactionOutputs)),
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationTransactionSequenceNumbers = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: data.transactionContext.transactionSequenceNumbers,
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationTransactionSequenceNumbersHash = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: ['sha256'],
    operation: (_, data, environment) => ({
        bytecode: environment.sha256.hash(environment.sha256.hash(data.transactionContext.transactionSequenceNumbers)),
        status: 'success',
    }),
});
exports.compilerOperationSigningSerializationVersion = compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['transactionContext'],
    environmentProperties: [],
    operation: (_, data) => ({
        bytecode: numbers_1.numberToBinUint32LE(data.transactionContext.version),
        status: 'success',
    }),
});
exports.compilerOperationKeyPublicKeyCommon = compiler_operation_helpers_1.attemptCompilerOperations([compiler_operation_helpers_1.compilerOperationAttemptBytecodeResolution], compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['keys'],
    environmentProperties: ['secp256k1'],
    operation: (identifier, data, environment) => {
        const { keys } = data;
        const { secp256k1 } = environment;
        const { privateKeys } = keys;
        const [variableId] = identifier.split('.');
        if (privateKeys !== undefined &&
            privateKeys[variableId] !== undefined) {
            return {
                bytecode: secp256k1.derivePublicKeyCompressed(privateKeys[variableId]),
                status: 'success',
            };
        }
        return {
            error: `Identifier "${identifier}" refers to a public key, but no public or private keys for "${variableId}" were provided in the compilation data.`,
            recoverable: true,
            status: 'error',
        };
    },
}));
exports.compilerOperationHdKeyPublicKeyCommon = compiler_operation_helpers_1.attemptCompilerOperations([compiler_operation_helpers_1.compilerOperationAttemptBytecodeResolution], compiler_operation_helpers_1.compilerOperationRequires({
    canBeSkipped: false,
    dataProperties: ['hdKeys'],
    environmentProperties: [
        'entityOwnership',
        'ripemd160',
        'secp256k1',
        'sha256',
        'sha512',
        'variables',
    ],
    operation: 
    // eslint-disable-next-line complexity
    (identifier, data, environment) => {
        var _a, _b, _c;
        const { hdKeys } = data;
        const { hdPrivateKeys, addressIndex, hdPublicKeys } = hdKeys;
        const [variableId] = identifier.split('.');
        const entityId = environment.entityOwnership[variableId];
        if (entityId === undefined) {
            return compiler_operation_helpers_1.compilerOperationHelperUnknownEntity(identifier, variableId);
        }
        if (addressIndex === undefined) {
            return compiler_operation_helpers_1.compilerOperationHelperAddressIndex(identifier);
        }
        const entityHdPrivateKey = hdPrivateKeys === undefined ? undefined : hdPrivateKeys[entityId];
        /**
         * Guaranteed to be an `HdKey` if this method is reached in the compiler.
         */
        const hdKey = environment.variables[variableId];
        if (entityHdPrivateKey !== undefined) {
            const privateResult = compiler_operation_helpers_1.compilerOperationHelperDeriveHdPrivateNode({
                addressIndex,
                entityHdPrivateKey,
                entityId,
                environment,
                hdKey,
                identifier,
            });
            if (privateResult.status === 'error')
                return privateResult;
            return {
                bytecode: environment.secp256k1.derivePublicKeyCompressed(privateResult.bytecode),
                status: 'success',
            };
        }
        const entityHdPublicKey = hdPublicKeys === undefined ? undefined : hdPublicKeys[entityId];
        if (entityHdPublicKey === undefined) {
            return {
                error: `Identifier "${identifier}" refers to an HdKey owned by "${entityId}", but an HD private key or HD public key for this entity was not provided in the compilation data.`,
                recoverable: true,
                status: 'error',
            };
        }
        const addressOffset = (_a = hdKey.addressOffset) !== null && _a !== void 0 ? _a : compiler_defaults_1.CompilerDefaults.hdKeyAddressOffset;
        const privateDerivationPath = (_b = hdKey.privateDerivationPath) !== null && _b !== void 0 ? _b : compiler_defaults_1.CompilerDefaults.hdKeyPrivateDerivationPath;
        const publicDerivationPath = (_c = hdKey.publicDerivationPath) !== null && _c !== void 0 ? _c : privateDerivationPath.replace('m', 'M');
        const validPublicPathWithIndex = /^M(?:\/(?:[0-9]+|i))*$/u;
        if (!validPublicPathWithIndex.test(publicDerivationPath)) {
            return {
                error: `Could not generate ${identifier} – the path "${publicDerivationPath}" is not a valid "publicDerivationPath".`,
                status: 'error',
            };
        }
        const i = addressIndex + addressOffset;
        const instancePath = publicDerivationPath.replace('i', i.toString());
        const masterContents = hd_key_1.decodeHdPublicKey(environment, entityHdPublicKey);
        if (typeof masterContents === 'string') {
            return {
                error: `Could not generate "${identifier}" – the HD public key provided for "${entityId}" could not be decoded: ${masterContents}`,
                status: 'error',
            };
        }
        const instanceNode = hd_key_1.deriveHdPath(environment, masterContents.node, instancePath);
        if (typeof instanceNode === 'string') {
            return {
                error: `Could not generate "${identifier}" – the path "${instancePath}" could not be derived for entity "${entityId}": ${instanceNode}`,
                status: 'error',
            };
        }
        return { bytecode: instanceNode.publicKey, status: 'success' };
    },
}));
/* eslint-disable camelcase, @typescript-eslint/naming-convention */
exports.compilerOperationsCommon = {
    addressData: exports.compilerOperationAddressData,
    currentBlockHeight: exports.compilerOperationCurrentBlockHeight,
    currentBlockTime: exports.compilerOperationCurrentBlockTime,
    hdKey: {
        public_key: exports.compilerOperationHdKeyPublicKeyCommon,
    },
    key: {
        public_key: exports.compilerOperationKeyPublicKeyCommon,
    },
    signingSerialization: {
        corresponding_output: exports.compilerOperationSigningSerializationCorrespondingOutput,
        corresponding_output_hash: exports.compilerOperationSigningSerializationCorrespondingOutputHash,
        covered_bytecode: exports.compilerOperationSigningSerializationCoveredBytecode,
        covered_bytecode_length: exports.compilerOperationSigningSerializationCoveredBytecodeLength,
        locktime: exports.compilerOperationSigningSerializationLocktime,
        outpoint_index: exports.compilerOperationSigningSerializationOutpointIndex,
        outpoint_transaction_hash: exports.compilerOperationSigningSerializationOutpointTransactionHash,
        output_value: exports.compilerOperationSigningSerializationOutputValue,
        sequence_number: exports.compilerOperationSigningSerializationSequenceNumber,
        transaction_outpoints: exports.compilerOperationSigningSerializationTransactionOutpoints,
        transaction_outpoints_hash: exports.compilerOperationSigningSerializationTransactionOutpointsHash,
        transaction_outputs: exports.compilerOperationSigningSerializationTransactionOutputs,
        transaction_outputs_hash: exports.compilerOperationSigningSerializationTransactionOutputsHash,
        transaction_sequence_numbers: exports.compilerOperationSigningSerializationTransactionSequenceNumbers,
        transaction_sequence_numbers_hash: exports.compilerOperationSigningSerializationTransactionSequenceNumbersHash,
        version: exports.compilerOperationSigningSerializationVersion,
    },
    walletData: exports.compilerOperationWalletData,
};
/* eslint-enable camelcase, @typescript-eslint/naming-convention */
//# sourceMappingURL=compiler-operations.js.map