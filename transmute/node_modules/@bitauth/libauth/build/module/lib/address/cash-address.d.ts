import { Immutable } from '../format/format';
export declare enum CashAddressNetworkPrefix {
    mainnet = "bitcoincash",
    testnet = "bchtest",
    regtest = "bchreg"
}
export declare const cashAddressBitToSize: {
    readonly 0: 160;
    readonly 1: 192;
    readonly 2: 224;
    readonly 3: 256;
    readonly 4: 320;
    readonly 5: 384;
    readonly 6: 448;
    readonly 7: 512;
};
export declare const cashAddressSizeToBit: {
    readonly 160: 0;
    readonly 192: 1;
    readonly 224: 2;
    readonly 256: 3;
    readonly 320: 4;
    readonly 384: 5;
    readonly 448: 6;
    readonly 512: 7;
};
/**
 * The CashAddress specification standardizes the format of the version byte:
 * - Most significant bit: reserved, must be `0`
 * - next 4 bits: Address Type
 * - 3 least significant bits: Hash Size
 *
 * Only two Address Type values are currently standardized:
 * - 0 (`0b0000`): P2PKH
 * - 1 (`0b0001`): P2SH
 *
 * While both P2PKH and P2SH addresses always use 160 bit hashes, the
 * CashAddress specification standardizes other sizes for future use (or use by
 * other systems), see `CashAddressSizeBit`.
 *
 * With these constraints, only two version byte values are currently standard.
 */
export declare enum CashAddressVersionByte {
    /**
     * Pay to Public Key Hash (P2PKH): `0b00000000`
     *
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0000` (P2PKH)
     * - Size bits: `000` (160 bits)
     */
    P2PKH = 0,
    /**
     * Pay to Script Hash (P2SH): `0b00001000`
     *
     * - Most significant bit: `0` (reserved)
     * - Address Type bits: `0001` (P2SH)
     * - Size bits: `000` (160 bits)
     */
    P2SH = 8
}
/**
 * The address types currently defined in the CashAddress specification. See
 * also: `CashAddressVersionByte`.
 */
export declare enum CashAddressType {
    /**
     * Pay to Public Key Hash (P2PKH)
     */
    P2PKH = 0,
    /**
     * Pay to Script Hash (P2SH)
     */
    P2SH = 1
}
export declare type CashAddressAvailableTypes = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15;
export declare type CashAddressAvailableSizesInBits = keyof typeof cashAddressSizeToBit;
export declare type CashAddressAvailableSizes = keyof typeof cashAddressBitToSize;
/**
 * Encode a CashAddress version byte for the given address type and hash length.
 * See `CashAddressVersionByte` for more information.
 *
 * The `type` parameter must be a number between `0` and `15`, and `bitLength`
 * must be one of the standardized lengths. To use the contents of a variable,
 * cast it to `CashAddressType` or `CashAddressSize` respectively, e.g.:
 * ```ts
 * const type = 3 as CashAddressType;
 * const size = 160 as CashAddressSize;
 * getCashAddressVersionByte(type, size);
 * ```
 * @param type - the address type of the hash being encoded
 * @param bitLength - the bit length of the hash being encoded
 */
export declare const encodeCashAddressVersionByte: (type: CashAddressAvailableTypes, bitLength: CashAddressAvailableSizesInBits) => number;
export declare enum CashAddressVersionByteDecodingError {
    reservedBitSet = "Reserved bit is set."
}
/**
 * Decode a CashAddress version byte.
 * @param version - the version byte to decode
 */
export declare const decodeCashAddressVersionByte: (version: number) => CashAddressVersionByteDecodingError.reservedBitSet | {
    bitLength: 256 | 192 | 224 | 160 | 320 | 384 | 448 | 512;
    type: number;
};
/**
 * Convert a string into an array of 5-bit numbers, representing the
 * characters in a case-insensitive way.
 * @param prefix - the prefix to mask
 */
export declare const maskCashAddressPrefix: (prefix: string) => number[];
/**
 * Perform the CashAddress polynomial modulo operation, which is based on the
 * Bech32 polynomial modulo operation, but the returned checksum is 40 bits,
 * rather than 30.
 *
 * A.K.A. `PolyMod`
 *
 * @remarks
 * Notes from Bitcoin ABC:
 * This function will compute what 8 5-bit values to XOR into the last 8 input
 * values, in order to make the checksum 0. These 8 values are packed together
 * in a single 40-bit integer. The higher bits correspond to earlier values.
 *
 * The input is interpreted as a list of coefficients of a polynomial over F
 * = GF(32), with an implicit 1 in front. If the input is [v0,v1,v2,v3,v4],
 * that polynomial is v(x) = 1*x^5 + v0*x^4 + v1*x^3 + v2*x^2 + v3*x + v4.
 * The implicit 1 guarantees that [v0,v1,v2,...] has a distinct checksum
 * from [0,v0,v1,v2,...].
 *
 * The output is a 40-bit integer whose 5-bit groups are the coefficients of
 * the remainder of v(x) mod g(x), where g(x) is the cashaddr generator, x^8
 * + [19]*x^7 + [3]*x^6 + [25]*x^5 + [11]*x^4 + [25]*x^3 + [3]*x^2 + [19]*x
 * + [1]. g(x) is chosen in such a way that the resulting code is a BCH
 * code, guaranteeing detection of up to 4 errors within a window of 1025
 * characters. Among the various possible BCH codes, one was selected to in
 * fact guarantee detection of up to 5 errors within a window of 160
 * characters and 6 errors within a window of 126 characters. In addition,
 * the code guarantee the detection of a burst of up to 8 errors.
 *
 * Note that the coefficients are elements of GF(32), here represented as
 * decimal numbers between []. In this finite field, addition is just XOR of
 * the corresponding numbers. For example, [27] + [13] = [27 ^ 13] = [22].
 * Multiplication is more complicated, and requires treating the bits of
 * values themselves as coefficients of a polynomial over a smaller field,
 * GF(2), and multiplying those polynomials mod a^5 + a^3 + 1. For example,
 * [5] * [26] = (a^2 + 1) * (a^4 + a^3 + a) = (a^4 + a^3 + a) * a^2 + (a^4 +
 * a^3 + a) = a^6 + a^5 + a^4 + a = a^3 + 1 (mod a^5 + a^3 + 1) = [9].
 *
 * During the course of the loop below, `c` contains the bit-packed
 * coefficients of the polynomial constructed from just the values of v that
 * were processed so far, mod g(x). In the above example, `c` initially
 * corresponds to 1 mod (x), and after processing 2 inputs of v, it
 * corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the
 * starting value for `c`.
 *
 * @privateRemarks
 * Derived from the `bitcore-lib-cash` implementation, which does not require
 * BigInt: https://github.com/bitpay/bitcore
 *
 * @param v - Array of 5-bit integers over which the checksum is to be computed
 */
export declare const cashAddressPolynomialModulo: (v: readonly number[]) => number;
/**
 * Convert the checksum returned by `cashAddressPolynomialModulo` to an array of
 * 5-bit positive integers which can be Base32 encoded.
 * @param checksum - a 40 bit checksum returned by `cashAddressPolynomialModulo`
 */
export declare const cashAddressChecksumToUint5Array: (checksum: number) => number[];
/**
 * Encode a hash as a CashAddress-like string using the CashAddress format.
 *
 * To encode a standard CashAddress, use `encodeCashAddress`.
 *
 * @param prefix - a valid prefix indicating the network for which to encode the
 * address – must be only lowercase letters
 * @param version - a single byte indicating the version of this address
 * @param hash - the hash to encode
 */
export declare const encodeCashAddressFormat: <Prefix extends string = CashAddressNetworkPrefix, Version extends number = CashAddressVersionByte>(prefix: Prefix, version: Version, hash: Immutable<Uint8Array>) => string;
export declare enum CashAddressEncodingError {
    unsupportedHashLength = "CashAddress encoding error: a hash of this length can not be encoded as a valid CashAddress."
}
/**
 * Encode a hash as a CashAddress.
 *
 * Note, this method does not enforce error handling via the type system. The
 * returned string may be a `CashAddressEncodingError.unsupportedHashLength`
 * if `hash` is not a valid length. Check the result if the input is potentially
 * malformed.
 *
 * For other address standards which closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * `encodeCashAddressFormat`.
 *
 * @param prefix - a valid prefix indicating the network for which to encode the
 * address (usually a `CashAddressNetworkPrefix`) – must be only lowercase
 * letters
 * @param type - the `CashAddressType` to encode in the version byte – usually a
 * `CashAddressType`
 * @param hash - the hash to encode (for P2PKH, the public key hash; for P2SH,
 * the redeeming bytecode hash)
 */
export declare const encodeCashAddress: <Prefix extends string = CashAddressNetworkPrefix, Type extends CashAddressAvailableTypes = CashAddressType>(prefix: Prefix, type: Type, hash: Uint8Array) => string;
export declare enum CashAddressDecodingError {
    improperPadding = "CashAddress decoding error: the payload is improperly padded.",
    invalidCharacters = "CashAddress decoding error: the payload contains non-bech32 characters.",
    invalidChecksum = "CashAddress decoding error: invalid checksum \u2013 please review the address for errors.",
    invalidFormat = "CashAddress decoding error: CashAddresses should be of the form \"prefix:payload\".",
    mismatchedHashLength = "CashAddress decoding error: mismatched hash length for specified address version.",
    reservedByte = "CashAddress decoding error: unknown CashAddress version, reserved byte set."
}
/**
 * Decode and validate a string using the CashAddress format. This is more
 * lenient than `decodeCashAddress`, which also validates the contents of the
 * version byte.
 *
 * Note, this method requires `address` to include a network prefix. To
 * decode a string with an unknown prefix, try
 * `decodeCashAddressFormatWithoutPrefix`.
 *
 * @param address - the CashAddress-like string to decode
 */
export declare const decodeCashAddressFormat: (address: string) => CashAddressDecodingError.improperPadding | CashAddressDecodingError.invalidCharacters | CashAddressDecodingError.invalidChecksum | CashAddressDecodingError.invalidFormat | {
    hash: Uint8Array;
    prefix: string;
    version: number;
};
/**
 * Decode and validate a CashAddress, strictly checking the version byte
 * according to the CashAddress specification. This is important for error
 * detection in CashAddresses.
 *
 * For other address-like standards which closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * `decodeCashAddressFormat`.
 *
 * Note, this method requires that CashAddresses include a network prefix. To
 * decode an address with an unknown prefix, try
 * `decodeCashAddressFormatWithoutPrefix`.
 *
 * @param address - the CashAddress to decode
 */
export declare const decodeCashAddress: (address: string) => CashAddressDecodingError | {
    hash: Uint8Array;
    prefix: string;
    type: number;
};
/**
 * Attempt to decode and validate a CashAddress against a list of possible
 * prefixes. If the correct prefix is known, use `decodeCashAddress`.
 *
 * @param address - the CashAddress to decode
 * @param possiblePrefixes - the network prefixes to try
 */
export declare const decodeCashAddressFormatWithoutPrefix: (address: string, possiblePrefixes?: readonly string[]) => CashAddressDecodingError.improperPadding | CashAddressDecodingError.invalidCharacters | CashAddressDecodingError.invalidChecksum | CashAddressDecodingError.invalidFormat | {
    hash: Uint8Array;
    prefix: string;
    version: number;
};
/**
 * Convert a CashAddress polynomial to CashAddress string format.
 *
 * @remarks
 * CashAddress polynomials take the form:
 *
 * `[lowest 5 bits of each prefix character] 0 [payload + checksum]`
 *
 * This method remaps the 5-bit integers in the prefix location to the matching
 * ASCII lowercase characters, replaces the separator with `:`, and then Bech32
 * encodes the remaining payload and checksum.
 *
 * @param polynomial - an array of 5-bit integers representing the terms of a
 * CashAddress polynomial
 */
export declare const cashAddressPolynomialToCashAddress: (polynomial: readonly number[]) => string;
export declare enum CashAddressCorrectionError {
    tooManyErrors = "This address has more than 2 errors and cannot be corrected."
}
/**
 * Attempt to correct up to 2 errors in a CashAddress. The CashAddress must be
 * properly formed (include a prefix and only contain Bech32 characters).
 *
 * ## **Improper use of this method carries the risk of lost funds.**
 *
 * It is strongly advised that this method only be used under explicit user
 * control. With enough errors, this method is likely to find a plausible
 * correction for any address (but for which no private key exists). This is
 * effectively equivalent to burning the funds.
 *
 * Only 2 substitution errors can be corrected (or a single swap) – deletions
 * and insertions (errors which shift many other characters and change the
 * length of the payload) can never be safely corrected and will produce an
 * error.
 *
 * Errors can be corrected in both the prefix and the payload, but attempting to
 * correct errors in the prefix prior to this method can improve results, e.g.
 * for `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x`, the string
 * `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can be corrected, while
 * `typo:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can not.
 *
 * @privateRemarks
 * Derived from: https://github.com/deadalnix/cashaddressed
 *
 * @param address - the CashAddress on which to attempt error correction
 */
export declare const attemptCashAddressFormatErrorCorrection: (address: string) => CashAddressDecodingError.invalidCharacters | CashAddressDecodingError.invalidFormat | CashAddressCorrectionError.tooManyErrors | {
    address: string;
    corrections: number[];
};
//# sourceMappingURL=cash-address.d.ts.map