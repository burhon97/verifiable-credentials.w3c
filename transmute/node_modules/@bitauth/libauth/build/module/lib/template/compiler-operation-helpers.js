import { decodeHdPrivateKey, deriveHdPath } from '../key/hd-key';
import { CompilerDefaults } from './compiler-defaults';
import { resolveScriptIdentifier } from './language/resolve';
/**
 * Attempt a series of compiler operations, skipping to the next operation if
 * the current operation returns a `CompilerOperationSkip` (indicating it failed
 * and can be skipped). The `finalOperation` may not be skipped, and must either
 * return `CompilerOperationSuccess` or `CompilerOperationError`.
 *
 * @param operations - an array of skippable operations to try
 * @param finalOperation - a final, un-skippable operation
 */
export const attemptCompilerOperations = (operations, finalOperation) => (identifier, data, environment) => {
    // eslint-disable-next-line functional/no-loop-statement
    for (const operation of operations) {
        const result = operation(identifier, data, environment);
        if (result.status !== 'skip')
            return result;
    }
    return finalOperation(identifier, data, environment);
};
/**
 * Modify a compiler operation to verify that certain properties exist in the
 * `CompilationData` and `CompilationEnvironment` before executing the provided
 * operation. If the properties don't exist, an error message is returned.
 *
 * This is useful for eliminating repetitive existence checks.
 *
 * @param canBeSkipped - if `true`, the accepted operation may return `false`,
 * and any missing properties will cause the returned operation to return
 * `false` (meaning the operation should be skipped)
 * @param dataProperties - an array of the top-level properties required in the
 * `CompilationData`
 * @param environmentProperties - an array of the top-level properties required
 * in the `CompilationEnvironment`
 * @param operation - the operation to run if all required properties exist
 */
export const compilerOperationRequires = ({ canBeSkipped, dataProperties, environmentProperties, operation, }) => (identifier, data, environment) => {
    // eslint-disable-next-line functional/no-loop-statement
    for (const property of environmentProperties) {
        if (environment[property] === undefined)
            return (canBeSkipped
                ? { status: 'skip' }
                : {
                    error: `Cannot resolve "${identifier}" – the "${property}" property was not provided in the compilation environment.`,
                    status: 'error',
                });
    }
    // eslint-disable-next-line functional/no-loop-statement
    for (const property of dataProperties) {
        if (data[property] === undefined)
            return (canBeSkipped
                ? { status: 'skip' }
                : {
                    error: `Cannot resolve "${identifier}" – the "${property}" property was not provided in the compilation data.`,
                    status: 'error',
                });
    }
    return operation(identifier, data, environment);
};
export const compilerOperationAttemptBytecodeResolution = compilerOperationRequires({
    canBeSkipped: true,
    dataProperties: ['bytecode'],
    environmentProperties: [],
    operation: (identifier, data) => {
        const { bytecode } = data;
        if (bytecode[identifier] !== undefined) {
            return { bytecode: bytecode[identifier], status: 'success' };
        }
        return { status: 'skip' };
    },
});
// eslint-disable-next-line complexity
export const compilerOperationHelperDeriveHdPrivateNode = ({ addressIndex, entityId, entityHdPrivateKey, environment, hdKey, identifier, }) => {
    var _a, _b;
    const addressOffset = (_a = hdKey.addressOffset) !== null && _a !== void 0 ? _a : CompilerDefaults.hdKeyAddressOffset;
    const privateDerivationPath = (_b = hdKey.privateDerivationPath) !== null && _b !== void 0 ? _b : CompilerDefaults.hdKeyPrivateDerivationPath;
    const i = addressIndex + addressOffset;
    const validPrivatePathWithIndex = /^m(?:\/(?:[0-9]+|i)'?)*$/u;
    if (!validPrivatePathWithIndex.test(privateDerivationPath)) {
        return {
            error: `Could not generate ${identifier} – the path "${privateDerivationPath}" is not a valid "privateDerivationPath".`,
            status: 'error',
        };
    }
    const instancePath = privateDerivationPath.replace('i', i.toString());
    const masterContents = decodeHdPrivateKey(environment, entityHdPrivateKey);
    if (typeof masterContents === 'string') {
        return {
            error: `Could not generate ${identifier} – the HD private key provided for ${entityId} could not be decoded: ${masterContents}`,
            status: 'error',
        };
    }
    const instanceNode = deriveHdPath(environment, masterContents.node, instancePath);
    if (typeof instanceNode === 'string') {
        return {
            error: `Could not generate ${identifier} – the path "${instancePath}" could not be derived for entity "${entityId}": ${instanceNode}`,
            status: 'error',
        };
    }
    return {
        bytecode: instanceNode.privateKey,
        status: 'success',
    };
};
export const compilerOperationHelperUnknownEntity = (identifier, variableId) => ({
    error: `Identifier "${identifier}" refers to an HdKey, but the "entityOwnership" for "${variableId}" is not available in this compilation environment.`,
    status: 'error',
});
export const compilerOperationHelperAddressIndex = (identifier) => ({
    error: `Identifier "${identifier}" refers to an HdKey, but "hdKeys.addressIndex" was not provided in the compilation data.`,
    status: 'error',
});
export const compilerOperationHelperDeriveHdKeyPrivate = ({ environment, hdKeys, identifier, }) => {
    const { addressIndex, hdPrivateKeys } = hdKeys;
    const [variableId] = identifier.split('.');
    const entityId = environment.entityOwnership[variableId];
    if (entityId === undefined) {
        return compilerOperationHelperUnknownEntity(identifier, variableId);
    }
    if (addressIndex === undefined) {
        return compilerOperationHelperAddressIndex(identifier);
    }
    const entityHdPrivateKey = hdPrivateKeys === undefined ? undefined : hdPrivateKeys[entityId];
    if (entityHdPrivateKey === undefined) {
        return {
            error: `Identifier "${identifier}" refers to an HdKey owned by "${entityId}", but an HD private key for this entity (or an existing signature) was not provided in the compilation data.`,
            recoverable: true,
            status: 'error',
        };
    }
    /**
     * Guaranteed to be an `HdKey` if this method is reached in the compiler.
     */
    const hdKey = environment.variables[variableId];
    return compilerOperationHelperDeriveHdPrivateNode({
        addressIndex,
        entityHdPrivateKey,
        entityId,
        environment,
        hdKey,
        identifier,
    });
};
/**
 * Returns `false` if the target script ID doesn't exist in the compilation
 * environment (allows for the caller to generate the error message).
 *
 * If the compilation produced errors, returns a `CompilerOperationErrorFatal`.
 *
 * If the compilation was successful, returns the compiled bytecode as a
 * `Uint8Array`.
 */
export const compilerOperationHelperCompileScript = ({ targetScriptId, data, environment, }) => {
    const signingTarget = environment.scripts[targetScriptId];
    const compiledTarget = resolveScriptIdentifier({
        data,
        environment,
        identifier: targetScriptId,
    });
    if (signingTarget === undefined || compiledTarget === false) {
        return false;
    }
    if (typeof compiledTarget === 'string') {
        return {
            error: compiledTarget,
            status: 'error',
        };
    }
    return compiledTarget.bytecode;
};
/**
 * Returns either the properly generated `coveredBytecode` or a
 * `CompilerOperationErrorFatal`.
 */
export const compilerOperationHelperGenerateCoveredBytecode = ({ data, environment, identifier, sourceScriptIds, unlockingScripts, }) => {
    const currentScriptId = sourceScriptIds[sourceScriptIds.length - 1];
    if (currentScriptId === undefined) {
        return {
            error: `Identifier "${identifier}" requires a signing serialization, but "coveredBytecode" cannot be determined because the compilation environment's "sourceScriptIds" is empty.`,
            status: 'error',
        };
    }
    const targetLockingScriptId = unlockingScripts[currentScriptId];
    if (targetLockingScriptId === undefined) {
        return {
            error: `Identifier "${identifier}" requires a signing serialization, but "coveredBytecode" cannot be determined because "${currentScriptId}" is not present in the compilation environment "unlockingScripts".`,
            status: 'error',
        };
    }
    const result = compilerOperationHelperCompileScript({
        data,
        environment,
        targetScriptId: targetLockingScriptId,
    });
    if (result === false) {
        return {
            error: `Identifier "${identifier}" requires a signing serialization which covers an unknown locking script, "${targetLockingScriptId}".`,
            status: 'error',
        };
    }
    return result;
};
//# sourceMappingURL=compiler-operation-helpers.js.map