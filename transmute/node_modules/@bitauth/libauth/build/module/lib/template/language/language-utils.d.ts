import { AuthenticationProgramStateExecutionStack } from '../../vm/vm';
import { CompilationError, CompilationErrorRecoverable, EvaluationSample, Range, ResolvedScript, ResolvedSegmentLiteralType, ScriptReductionTraceChildNode, ScriptReductionTraceScriptNode } from './language-types';
/**
 * Combine an array of `Range`s into a single larger `Range`.
 *
 * @param ranges - an array of `Range`s
 * @param parentRange - the range to assume if `ranges` is an empty array
 */
export declare const mergeRanges: (ranges: Range[], parentRange?: Range) => {
    startColumn: number;
    startLineNumber: number;
    endColumn: number;
    endLineNumber: number;
};
/**
 * Returns true if the `outerRange` fully contains the `innerRange`, otherwise,
 * `false`.
 *
 * @param outerRange - the bounds of the outer range
 * @param innerRange - the inner range to test
 * @param exclusive - disallow the `innerRange` from overlapping the
 * `outerRange` (such that the outer start and end columns may not be equal) –
 * defaults to `true`
 */
export declare const containsRange: (outerRange: Range, innerRange: Range, exclusive?: boolean) => boolean;
/**
 * Perform a simplified compilation on a Bitauth Templating Language (BTL)
 * script containing only hex literals, bigint literals, UTF8 literals, and push
 * statements. Scripts may not contain variables/operations, evaluations, or
 * opcode identifiers (use hex literals instead).
 *
 * This is useful for accepting complex user input in advanced interfaces,
 * especially for `AddressData` and `WalletData`.
 *
 * Returns the compiled bytecode as a `Uint8Array`, or throws an error message.
 *
 * @param script - a simple BTL script containing no variables or evaluations
 */
export declare const compileBtl: (script: string) => string | Uint8Array;
/**
 * Extract a list of the errors which occurred while resolving a script.
 *
 * @param resolvedScript - the result of `resolveScript` from which to extract
 * errors
 */
export declare const getResolutionErrors: (resolvedScript: ResolvedScript) => CompilationError[];
/**
 * Verify that every error in the provided array can be resolved by providing
 * additional variables in the compilation data (rather than deeper issues, like
 * problems with the authentication template or wallet implementation).
 *
 * Note, errors are only recoverable if the "entity ownership" of each missing
 * identifier is known (specified in `CompilationData`'s `entityOwnership`).
 *
 * @param errors - an array of compilation errors
 */
export declare const allErrorsAreRecoverable: (errors: CompilationError[]) => errors is CompilationErrorRecoverable[];
/**
 * A single resolution for a `ResolvedSegment`. The `variable`, `script`, or
 * `opcode` property contains the full identifier which resolved to `bytecode`.
 */
export interface BtlResolution {
    bytecode: Uint8Array;
    type: 'variable' | 'script' | 'opcode' | ResolvedSegmentLiteralType;
    text: string;
}
/**
 * Get an array of all resolutions used in a `ResolvedScript`.
 * @param resolvedScript - the resolved script to search
 */
export declare const extractBytecodeResolutions: (resolvedScript: ResolvedScript) => BtlResolution[];
/**
 * Extract an object mapping the variable identifiers used in a `ResolvedScript`
 * to their resolved bytecode.
 *
 * @param resolvedScript - the resolved script to search
 */
export declare const extractResolvedVariableBytecodeMap: (resolvedScript: ResolvedScript) => {
    [fullIdentifier: string]: Uint8Array;
};
/**
 * Format a list of `CompilationError`s into a single string, with an error
 * start position following each error. E.g. for line 1, column 2:
 * `The error message. [1, 2]`
 *
 * Errors are separated with the `separator`, which defaults to `; `, e.g.:
 * `The first error message. [1, 2]; The second error message. [3, 4]`
 *
 * @param errors - an array of compilation errors
 * @param separator - the characters with which to join the formatted errors.
 */
export declare const stringifyErrors: (errors: CompilationError[], separator?: string) => string;
export interface SampleExtractionResult<ProgramState, Opcodes = number> {
    /**
     * The samples successfully extracted from the provided `nodes` and `trace`.
     *
     * In a successful evaluation, one sample will be produced for each state in
     * `trace` with the exception of the last state (the evaluation result) which
     * will be returned in `unmatchedStates`.
     *
     * In an unsuccessful evaluation, the `trace` states will be exhausted before
     * all `nodes` have been matched. In this case, all matched samples are
     * returned, and the final state (the evaluation result) is dropped. This can
     * be detected by checking if the length of `unmatchedStates` is `0`.
     */
    samples: EvaluationSample<ProgramState, Opcodes>[];
    /**
     * If the provided `nodes` are exhausted before all states from `trace` have
     * been matched, the remaining "unmatched" states are returned. This is useful
     * for extracting samples for an evaluation involving two or more
     * compilations.
     *
     * In a successful evaluation, after samples have been extracted from each set
     * of `nodes`, the final `trace` state (the evaluation result) will be
     * returned in `unmatchedStates`.
     */
    unmatchedStates: ProgramState[];
}
/**
 * Extract a set of "evaluation samples" from the result of a BTL compilation
 * and a matching debug trace (from `vm.debug`), pairing program states with the
 * source ranges which produced them – like a "source map" for complete
 * evaluations. This is useful for omniscient debuggers like Bitauth IDE.
 *
 * Returns an array of samples and an array of unmatched program states
 * remaining if `nodes` doesn't contain enough instructions to consume all
 * program states provided in `trace`. Returned samples are ordered by the
 * ending position (line and column) of their range.
 *
 * If all program states are consumed before the available nodes are exhausted,
 * the remaining nodes are ignored (the produced samples end at the last
 * instruction for which a program state exists). This usually occurs when an
 * error halts evaluation before the end of the script. (Note: if this occurs,
 * the final trace state will not be used, as it is expected to be the
 * duplicated final result produced by `vm.debug`, and should not be matched
 * with the next instruction. The returned `unmatchedStates` will have a length
 * of `0`.)
 *
 * This method allows for samples to be extracted from a single evaluation;
 * most applications should use `extractEvaluationSamplesRecursive` instead.
 *
 * @remarks
 * This method incrementally concatenates the reduced bytecode from each node,
 * parsing the result into evaluation samples.
 *
 * Each node can contain only a portion of an instruction (like a long push
 * operation), or it can contain multiple instructions (like a long hex literal
 * representing a string of bytecode or an evaluation which is not wrapped by a
 * push).
 *
 * If a node contains only a portion of an instruction, the bytecode from
 * additional nodes are concatenated (and ranges merged) until an instruction
 * can be created. If any bytecode remains after a sample has been created, the
 * next sample begins in the same range. (For this reason, it's possible that
 * samples overlap.)
 *
 * If a node contains more than one instruction, the intermediate states
 * produced before the final state for that sample are saved to the sample's
 * `intermediateStates` array.
 *
 * If the program states in `trace` are exhausted before the final instruction
 * in a sample (usually caused by an evaluation error), the last instruction
 * with a matching program state is used for the sample (with its program
 * state), and the unmatched instructions are ignored. (This allows the "last
 * known state" to be displayed for the sample which caused evaluation to halt.)
 *
 * ---
 *
 * For example, the following script demonstrates many of these cases:
 *
 * `0x00 0x01 0xab01 0xcd9300 $(OP_3 <0x00> OP_SWAP OP_CAT) 0x010203`
 *
 * Which compiles to `0x0001ab01cd93000003010203`, disassembled:
 *
 * `OP_0 OP_PUSHBYTES_1 0xab OP_PUSHBYTES_1 0xcd OP_ADD OP_0 OP_0 OP_PUSHBYTES_3 0x010203`
 *
 * In the script, there are 6 top-level nodes (identified below within `[]`):
 *
 * `[0x00] [0x01] [0xab01] [0xcd9300] [$(OP_3 <0x00> OP_SWAP OP_CAT)] [0x010203]`
 *
 * These nodes together encode 7 instructions, some within a single node, and
 * some split between several nodes. Below we substitute the evaluation for its
 * result `0x0003` to group instructions by `[]`:
 *
 * `[0x00] [0x01 0xab][01 0xcd][93][00] [0x00][03 0x010203]`
 *
 * The "resolution" of samples is limited to the range of single nodes: nodes
 * cannot always be introspected to determine where contained instructions begin
 * and end. For example, it is ambiguous which portions of the evaluation are
 * responsible for the initial `0x00` and which are responsible for the `0x03`.
 *
 * For this reason, the range of each sample is limited to the range(s) of one
 * or more adjacent nodes. Samples may overlap in the range of a node which is
 * responsible for both ending a previous sample and beginning a new sample.
 * (Though, only 2 samples can overlap. If a node is responsible for more than 2
 * instructions, the second sample includes `internalStates` for instructions
 * which occur before the end of the second sample.)
 *
 * In this case, there are 6 samples identified below within `[]`, where each
 * `[` is closed by the closest following `]` (no nesting):
 *
 * `[0x00] [0x01 [0xab01] [0xcd9300]] [[$(OP_3 <0x00> OP_SWAP OP_CAT)] 0x010203]`
 *
 * The ranges for each sample (in terms of nodes) are as follows:
 * - Sample 1: node 1
 * - Sample 2: node 2 + node 3
 * - Sample 3: node 3 + node 4
 * - Sample 4: node 4
 * - Sample 5: node 5
 * - Sample 6: node 5 + node 6
 *
 * Note that the following samples overlap:
 * - Sample 2 and Sample 3
 * - Sample 3 and Sample 4
 * - Sample 5 and Sample 6
 *
 * Finally, note that Sample 4 will have one internal state produced by the
 * `OP_ADD` instruction. Sample 4 then ends with the `OP_0` (`0x00`) instruction
 * at the end of the `0xcd9300` node.
 *
 * ---
 *
 * Note, this implementation relies on the expectation that `trace` begins with
 * the initial program state, contains a single program state per instruction,
 * and ends with the final program state (as produced by `vm.debug`). It also
 * expects the `bytecode` provided by nodes to be parsable by `parseBytecode`.
 *
 * @param evaluationRange - the range of the script node which was evaluated to
 * produce the `trace`
 * @param nodes - an array of reduced nodes to parse
 * @param trace - the `vm.debug` result to map to these nodes
 */
export declare const extractEvaluationSamples: <ProgramState, Opcodes = number>({ evaluationRange, nodes, trace, }: {
    evaluationRange: Range;
    nodes: ScriptReductionTraceChildNode<ProgramState>[];
    trace: ProgramState[];
}) => SampleExtractionResult<ProgramState, Opcodes>;
/**
 * Similar to `extractEvaluationSamples`, but recursively extracts samples from
 * evaluations within the provided array of nodes.
 *
 * Because BTL evaluations are fully self-contained, there should never be
 * unmatched states from evaluations within a script reduction trace tree. (For
 * this reason, this method does not return the `unmatchedStates` from nested
 * evaluations.)
 *
 * Returned samples are ordered by the ending position (line and column) of
 * their range. Samples from BTL evaluations which occur within an outer
 * evaluation appear before their parent sample (which uses their result).
 *
 * @param evaluationRange - the range of the script node which was evaluated to
 * produce the `trace`
 * @param nodes - an array of reduced nodes to parse
 * @param trace - the `vm.debug` result to map to these nodes
 */
export declare const extractEvaluationSamplesRecursive: <ProgramState, Opcodes = number>({ evaluationRange, nodes, trace, }: {
    evaluationRange: Range;
    nodes: ScriptReductionTraceChildNode<ProgramState>[];
    trace: ProgramState[];
}) => SampleExtractionResult<ProgramState, Opcodes>;
/**
 * Extract an array of ranges which were unused by an evaluation. This is useful
 * in development tooling for fading out or hiding code which is unimportant to
 * the current evaluation being tested.
 *
 * @remarks
 * Only ranges which are guaranteed to be unimportant to an evaluation are
 * returned by this method. These ranges are extracted from samples which:
 * - are preceded by a sample which ends with execution disabled (e.g. an
 * unsuccessful `OP_IF`)
 * - end with execution disabled, and
 * - contain no `internalStates` which enable execution.
 *
 * Note, internal states which temporarily re-enable and then disable execution
 * again can still have an effect on the parent evaluation, so this method
 * conservatively excludes such samples. For example, the hex literal
 * `0x675167`, which encodes `OP_ELSE OP_1 OP_ELSE`, could begin and end with
 * states in which execution is disabled, yet a `1` is pushed to the stack
 * during the sample's evaluation. (Samples like this are unusual, and can
 * almost always be reformatted to clearly separate the executed and unexecuted
 * instructions.)
 *
 * @param samples - an array of samples ordered by the ending position (line and
 * column) of their range.
 * @param evaluationBegins - the line and column at which the initial sample's
 * evaluation range begins (where the preceding state is assumed to be
 * executing), defaults to `1,1`
 */
export declare const extractUnexecutedRanges: <ProgramState extends AuthenticationProgramStateExecutionStack, Opcodes = number>(samples: EvaluationSample<ProgramState, Opcodes>[], evaluationBegins?: string) => Range[];
//# sourceMappingURL=language-utils.d.ts.map