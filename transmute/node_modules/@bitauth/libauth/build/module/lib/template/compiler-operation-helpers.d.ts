import { TransactionContextCommon } from '../transaction/transaction-types';
import { AnyCompilationEnvironment, CompilationData, CompilationEnvironment, CompilerOperation, CompilerOperationErrorFatal, CompilerOperationResult } from './compiler-types';
import { AuthenticationTemplateHdKey } from './template-types';
/**
 * Attempt a series of compiler operations, skipping to the next operation if
 * the current operation returns a `CompilerOperationSkip` (indicating it failed
 * and can be skipped). The `finalOperation` may not be skipped, and must either
 * return `CompilerOperationSuccess` or `CompilerOperationError`.
 *
 * @param operations - an array of skippable operations to try
 * @param finalOperation - a final, un-skippable operation
 */
export declare const attemptCompilerOperations: <TransactionContext = TransactionContextCommon>(operations: CompilerOperation<TransactionContext, true, CompilationData<TransactionContext>, CompilationEnvironment<TransactionContext, import("./compiler-types").CompilerOperationsKeysCommon, import("./compiler-types").CompilerOperationsSigningSerializationCommon, false, false, false, false>>[], finalOperation: CompilerOperation<TransactionContext, false, CompilationData<TransactionContext>, CompilationEnvironment<TransactionContext, import("./compiler-types").CompilerOperationsKeysCommon, import("./compiler-types").CompilerOperationsSigningSerializationCommon, false, false, false, false>>) => CompilerOperation<TransactionContext, false, CompilationData<TransactionContext>, CompilationEnvironment<TransactionContext, import("./compiler-types").CompilerOperationsKeysCommon, import("./compiler-types").CompilerOperationsSigningSerializationCommon, false, false, false, false>>;
/**
 * Modify a compiler operation to verify that certain properties exist in the
 * `CompilationData` and `CompilationEnvironment` before executing the provided
 * operation. If the properties don't exist, an error message is returned.
 *
 * This is useful for eliminating repetitive existence checks.
 *
 * @param canBeSkipped - if `true`, the accepted operation may return `false`,
 * and any missing properties will cause the returned operation to return
 * `false` (meaning the operation should be skipped)
 * @param dataProperties - an array of the top-level properties required in the
 * `CompilationData`
 * @param environmentProperties - an array of the top-level properties required
 * in the `CompilationEnvironment`
 * @param operation - the operation to run if all required properties exist
 */
export declare const compilerOperationRequires: <CanBeSkipped extends boolean, RequiredDataProperties extends "keys" | "bytecode" | "currentBlockHeight" | "currentBlockTime" | "hdKeys" | "transactionContext", RequiredEnvironmentProperties extends "sha256" | "sha512" | "ripemd160" | "operations" | "createAuthenticationProgram" | "entityOwnership" | "lockingScriptTypes" | "opcodes" | "scenarios" | "scripts" | "secp256k1" | "sourceScriptIds" | "unlockingScripts" | "unlockingScriptTimeLockTypes" | "variables" | "vm", TransactionContext = TransactionContextCommon>({ canBeSkipped, dataProperties, environmentProperties, operation, }: {
    canBeSkipped: CanBeSkipped;
    dataProperties: RequiredDataProperties[];
    environmentProperties: RequiredEnvironmentProperties[];
    operation: (identifier: string, data: Required<Pick<CompilationData<TransactionContext>, RequiredDataProperties>> & CompilationData<TransactionContext>, environment: Required<Pick<CompilationEnvironment<TransactionContext, import("./compiler-types").CompilerOperationsKeysCommon, import("./compiler-types").CompilerOperationsSigningSerializationCommon, false, false, false, false>, RequiredEnvironmentProperties>> & CompilationEnvironment<TransactionContext, import("./compiler-types").CompilerOperationsKeysCommon, import("./compiler-types").CompilerOperationsSigningSerializationCommon, false, false, false, false>) => CompilerOperationResult<CanBeSkipped>;
}) => CompilerOperation<TransactionContext, CanBeSkipped, CompilationData<TransactionContext>, CompilationEnvironment<TransactionContext, import("./compiler-types").CompilerOperationsKeysCommon, import("./compiler-types").CompilerOperationsSigningSerializationCommon, false, false, false, false>>;
export declare const compilerOperationAttemptBytecodeResolution: CompilerOperation<TransactionContextCommon, true, CompilationData<TransactionContextCommon>, CompilationEnvironment<TransactionContextCommon, import("./compiler-types").CompilerOperationsKeysCommon, import("./compiler-types").CompilerOperationsSigningSerializationCommon, false, false, false, false>>;
export declare const compilerOperationHelperDeriveHdPrivateNode: ({ addressIndex, entityId, entityHdPrivateKey, environment, hdKey, identifier, }: {
    addressIndex: number;
    entityId: string;
    entityHdPrivateKey: string;
    environment: {
        ripemd160: NonNullable<CompilationEnvironment['ripemd160']>;
        secp256k1: NonNullable<CompilationEnvironment['secp256k1']>;
        sha256: NonNullable<CompilationEnvironment['sha256']>;
        sha512: NonNullable<CompilationEnvironment['sha512']>;
    };
    hdKey: AuthenticationTemplateHdKey;
    identifier: string;
}) => CompilerOperationResult;
export declare const compilerOperationHelperUnknownEntity: (identifier: string, variableId: string) => {
    error: string;
    status: "error";
};
export declare const compilerOperationHelperAddressIndex: (identifier: string) => {
    error: string;
    status: "error";
};
export declare const compilerOperationHelperDeriveHdKeyPrivate: ({ environment, hdKeys, identifier, }: {
    environment: {
        entityOwnership: NonNullable<CompilationEnvironment['entityOwnership']>;
        ripemd160: NonNullable<CompilationEnvironment['ripemd160']>;
        secp256k1: NonNullable<CompilationEnvironment['secp256k1']>;
        sha256: NonNullable<CompilationEnvironment['sha256']>;
        sha512: NonNullable<CompilationEnvironment['sha512']>;
        variables: NonNullable<CompilationEnvironment['variables']>;
    };
    hdKeys: NonNullable<CompilationData['hdKeys']>;
    identifier: string;
}) => CompilerOperationResult;
/**
 * Returns `false` if the target script ID doesn't exist in the compilation
 * environment (allows for the caller to generate the error message).
 *
 * If the compilation produced errors, returns a `CompilerOperationErrorFatal`.
 *
 * If the compilation was successful, returns the compiled bytecode as a
 * `Uint8Array`.
 */
export declare const compilerOperationHelperCompileScript: <TransactionContext>({ targetScriptId, data, environment, }: {
    targetScriptId: string;
    data: CompilationData<TransactionContext>;
    environment: AnyCompilationEnvironment<TransactionContext>;
}) => false | Uint8Array | CompilerOperationErrorFatal;
/**
 * Returns either the properly generated `coveredBytecode` or a
 * `CompilerOperationErrorFatal`.
 */
export declare const compilerOperationHelperGenerateCoveredBytecode: <TransactionContext>({ data, environment, identifier, sourceScriptIds, unlockingScripts, }: {
    data: CompilationData<TransactionContext>;
    environment: AnyCompilationEnvironment<TransactionContext>;
    identifier: string;
    sourceScriptIds: string[];
    unlockingScripts: {
        [unlockingScriptId: string]: string;
    };
}) => CompilerOperationErrorFatal | Uint8Array;
//# sourceMappingURL=compiler-operation-helpers.d.ts.map