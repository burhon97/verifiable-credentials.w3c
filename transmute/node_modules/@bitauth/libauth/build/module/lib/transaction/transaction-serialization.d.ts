import { Sha256 } from '../crypto/sha256';
import { Input, Output, Transaction } from './transaction-types';
/**
 * @param bin - the raw transaction from which to read the input
 * @param offset - the offset at which the input begins
 */
export declare const readTransactionInput: (bin: Uint8Array, offset: number) => {
    input: {
        outpointIndex: number;
        outpointTransactionHash: Uint8Array;
        sequenceNumber: number;
        unlockingBytecode: Uint8Array;
    };
    nextOffset: number;
};
/**
 * Encode a single input for inclusion in an encoded transaction.
 *
 * @param output - the input to encode
 */
export declare const encodeInput: (input: Input) => Uint8Array;
/**
 * Encode a set of inputs for inclusion in an encoded transaction including
 * the prefixed number of inputs.
 *
 * Format: [BitcoinVarInt: input count] [encoded inputs]
 *
 * @param inputs - the set of inputs to encode
 */
export declare const encodeInputs: (inputs: readonly Input[]) => Uint8Array;
/**
 * Read a single transaction output from an encoded transaction.
 *
 * @param bin - the raw transaction from which to read the output
 * @param offset - the offset at which the output begins
 */
export declare const readTransactionOutput: (bin: Uint8Array, offset: number) => {
    nextOffset: number;
    output: {
        lockingBytecode: Uint8Array;
        satoshis: Uint8Array;
    };
};
/**
 * Encode a single output for inclusion in an encoded transaction.
 *
 * @param output - the output to encode
 */
export declare const encodeOutput: (output: Output) => Uint8Array;
/**
 * Encode a set of outputs for inclusion in an encoded transaction
 * including the prefixed number of outputs.
 *
 * Format: [BitcoinVarInt: output count] [encoded outputs]
 *
 * @param outputs - the set of outputs to encode
 */
export declare const encodeOutputsForTransaction: (outputs: readonly Output[]) => Uint8Array;
/**
 * Decode a `Uint8Array` using the version 1 or 2 raw transaction format.
 *
 * Note: this method throws runtime errors when attempting to decode messages
 * which do not properly follow the transaction format. If the input is
 * untrusted, use `decodeTransaction`.
 *
 * @param bin - the raw message to decode
 */
export declare const decodeTransactionUnsafe: (bin: Uint8Array) => Transaction;
export declare enum TransactionDecodingError {
    invalidFormat = "Transaction decoding error: message does not follow the version 1 or version 2 transaction format."
}
/**
 * Decode a `Uint8Array` using the version 1 or 2 raw transaction format.
 *
 * @param bin - the raw message to decode
 */
export declare const decodeTransaction: (bin: Uint8Array) => Transaction<Input<Uint8Array, Uint8Array>, Output<Uint8Array, Uint8Array>> | TransactionDecodingError.invalidFormat;
/**
 * Encode a `Transaction` using the standard P2P network format. This
 * serialization is also used when computing the transaction's hash (A.K.A.
 * "transaction ID" or "TXID").
 */
export declare const encodeTransaction: (tx: Transaction) => Uint8Array;
/**
 * Compute a transaction hash (A.K.A. "transaction ID" or "TXID") from an
 * encoded transaction in big-endian byte order. This is the byte order
 * typically used by block explorers and other user interfaces.
 *
 * @returns the transaction hash as a string
 *
 * @param transaction - the encoded transaction
 * @param sha256 - an implementation of sha256
 */
export declare const getTransactionHashBE: (sha256: {
    hash: Sha256['hash'];
}, transaction: Uint8Array) => Uint8Array;
/**
 * Compute a transaction hash (A.K.A. "transaction ID" or "TXID") from an
 * encoded transaction in little-endian byte order. This is the byte order
 * used in P2P network messages.
 *
 * @remarks
 * The result of sha256 is defined by its specification as big-endian, but
 * bitcoin message formats always reverse the order of this result for
 * serialization in P2P network messages.
 *
 * @returns the transaction hash in little-endian byte order
 *
 * @param transaction - the encoded transaction
 * @param sha256 - an implementation of sha256
 */
export declare const getTransactionHashLE: (sha256: {
    hash: Sha256['hash'];
}, transaction: Uint8Array) => Uint8Array;
/**
 * Return a `Transaction`'s hash as a string (in big-endian byte order as is
 * common for user interfaces).
 *
 * @param transaction - the encoded transaction
 * @param sha256 - an implementation of sha256
 */
export declare const getTransactionHash: (sha256: {
    hash: Sha256['hash'];
}, transaction: Uint8Array) => string;
/**
 * Get the hash of all outpoints in a series of inputs. (For use in
 * `hashTransactionOutpoints`.)
 *
 * @param inputs - the series of inputs from which to extract the outpoints
 * @param sha256 - an implementation of sha256
 */
export declare const encodeOutpoints: (inputs: readonly {
    outpointIndex: number;
    outpointTransactionHash: Uint8Array;
}[]) => Uint8Array;
/**
 * Encode an array of transaction outputs for use in transaction signing
 * serializations.
 *
 * @param outputs - the array of outputs to encode
 */
export declare const encodeOutputsForSigning: (outputs: readonly Output[]) => Uint8Array;
/**
 * Encode an array of input sequence numbers for use in transaction signing
 * serializations.
 *
 * @param inputs - the array of inputs from which to extract the sequence
 * numbers
 */
export declare const encodeSequenceNumbersForSigning: (inputs: readonly {
    sequenceNumber: number;
}[]) => Uint8Array;
//# sourceMappingURL=transaction-serialization.d.ts.map