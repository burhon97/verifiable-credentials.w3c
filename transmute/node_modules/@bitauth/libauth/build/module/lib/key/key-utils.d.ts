/**
 * Verify that a private key is valid for the Secp256k1 curve. Returns `true`
 * for success, or `false` on failure.
 *
 * Private keys are 256-bit numbers encoded as a 32-byte, big-endian Uint8Array.
 * Nearly every 256-bit number is a valid secp256k1 private key. Specifically,
 * any 256-bit number greater than `0x01` and less than
 * `0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140`
 * is a valid private key. This range is part of the definition of the
 * secp256k1 elliptic curve parameters.
 *
 * This method does not require the `Secp256k1` WASM implementation (available
 * via `instantiateSecp256k1`).
 */
export declare const validateSecp256k1PrivateKey: (privateKey: Uint8Array) => boolean;
/**
 * Securely generate a valid Secp256k1 private key given a secure source of
 * randomness.
 *
 * **Node.js Usage**
 * ```ts
 * import { randomBytes } from 'crypto';
 * import { generatePrivateKey } from '@bitauth/libauth';
 *
 * const key = generatePrivateKey(secp256k1, () => randomBytes(32));
 * ```
 *
 * **Browser Usage**
 * ```ts
 * import { generatePrivateKey } from '@bitauth/libauth';
 *
 * const key = generatePrivateKey(secp256k1, () =>
 *   window.crypto.getRandomValues(new Uint8Array(32))
 * );
 * ```
 *
 * @param secp256k1 - an implementation of Secp256k1
 * @param secureRandom - a method which returns a securely-random 32-byte
 * Uint8Array
 */
export declare const generatePrivateKey: (secureRandom: () => Uint8Array) => Uint8Array;
//# sourceMappingURL=key-utils.d.ts.map