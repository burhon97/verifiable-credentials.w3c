import { flattenBinArray } from '../../../format/hex';
import { combineOperations, pushToStack, useOneScriptNumber, useOneStackItem, useThreeStackItems, useTwoScriptNumbers, useTwoStackItems, } from '../common/combinators';
import { ConsensusCommon } from '../common/common';
import { isValidPublicKeyEncoding, isValidSignatureEncodingDER, } from '../common/encoding';
import { applyError, AuthenticationErrorCommon } from '../common/errors';
import { opVerify } from '../common/flow-control';
import { bigIntToScriptNumber, booleanToScriptNumber } from '../common/types';
import { AuthenticationErrorBCH } from './bch-errors';
import { OpcodesBCH } from './bch-opcodes';
import { ConsensusBCH } from './bch-types';
export const opCat = () => (state) => useTwoStackItems(state, (nextState, [a, b]) => a.length + b.length > ConsensusCommon.maximumStackItemLength
    ? applyError(AuthenticationErrorBCH.exceededMaximumStackItemLength, nextState)
    : pushToStack(nextState, flattenBinArray([a, b])));
export const opSplit = ({ requireMinimalEncoding, }) => (state) => useOneScriptNumber(state, (nextState, value) => {
    const index = Number(value);
    return useOneStackItem(nextState, (finalState, [item]) => index < 0 || index > item.length
        ? applyError(AuthenticationErrorBCH.invalidSplitIndex, finalState)
        : pushToStack(finalState, item.slice(0, index), item.slice(index)));
}, { requireMinimalEncoding });
var Constants;
(function (Constants) {
    Constants[Constants["positiveSign"] = 0] = "positiveSign";
    Constants[Constants["negativeSign"] = 128] = "negativeSign";
})(Constants || (Constants = {}));
export const padMinimallyEncodedScriptNumber = (scriptNumber, length) => {
    // eslint-disable-next-line functional/no-let
    let signBit = Constants.positiveSign;
    // eslint-disable-next-line functional/no-conditional-statement
    if (scriptNumber.length > 0) {
        // eslint-disable-next-line functional/no-expression-statement, no-bitwise
        signBit = scriptNumber[scriptNumber.length - 1] & Constants.negativeSign;
        // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
        scriptNumber[scriptNumber.length - 1] &= Constants.negativeSign - 1;
    }
    const result = Array.from(scriptNumber);
    // eslint-disable-next-line functional/no-loop-statement
    while (result.length < length - 1) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        result.push(0);
    }
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    result.push(signBit);
    return Uint8Array.from(result);
};
export const opNum2Bin = () => (state) => useOneScriptNumber(state, (nextState, value) => {
    const targetLength = Number(value);
    return targetLength > ConsensusCommon.maximumStackItemLength
        ? applyError(AuthenticationErrorBCH.exceededMaximumStackItemLength, nextState)
        : useOneScriptNumber(nextState, (finalState, [target]) => {
            const minimallyEncoded = bigIntToScriptNumber(target);
            return minimallyEncoded.length > targetLength
                ? applyError(AuthenticationErrorBCH.insufficientLength, finalState)
                : minimallyEncoded.length === targetLength
                    ? pushToStack(finalState, minimallyEncoded)
                    : pushToStack(finalState, padMinimallyEncodedScriptNumber(minimallyEncoded, targetLength));
        }, {
            maximumScriptNumberByteLength: 
            // TODO: is this right?
            ConsensusCommon.maximumStackItemLength,
            requireMinimalEncoding: false,
        });
}, { requireMinimalEncoding: true });
export const opBin2Num = () => (state) => useOneScriptNumber(state, (nextState, [target]) => {
    const minimallyEncoded = bigIntToScriptNumber(target);
    return minimallyEncoded.length > ConsensusCommon.maximumScriptNumberLength
        ? applyError(AuthenticationErrorBCH.exceededMaximumScriptNumberLength, nextState)
        : pushToStack(nextState, minimallyEncoded);
}, {
    // TODO: is this right?
    maximumScriptNumberByteLength: ConsensusCommon.maximumStackItemLength,
    requireMinimalEncoding: false,
});
export const bitwiseOperation = (combine) => (state) => useTwoStackItems(state, (nextState, [a, b]) => a.length === b.length
    ? pushToStack(nextState, combine(a, b))
    : applyError(AuthenticationErrorBCH.mismatchedBitwiseOperandLength, nextState));
export const opAnd = () => bitwiseOperation((a, b) => a.map((v, i) => v & b[i]));
export const opOr = () => bitwiseOperation((a, b) => a.map((v, i) => v | b[i]));
export const opXor = () => bitwiseOperation((a, b) => a.map((v, i) => v ^ b[i]));
export const opDiv = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [a, b]) => b === BigInt(0)
    ? applyError(AuthenticationErrorBCH.divisionByZero, nextState)
    : pushToStack(nextState, bigIntToScriptNumber(a / b)), { requireMinimalEncoding });
export const opMod = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [a, b]) => b === BigInt(0)
    ? applyError(AuthenticationErrorBCH.divisionByZero, nextState)
    : pushToStack(nextState, bigIntToScriptNumber(a % b)), { requireMinimalEncoding });
/**
 * Validate the encoding of a raw signature â€“ a signature without a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param signature - the raw signature
 */
export const isValidSignatureEncodingBCHRaw = (signature) => signature.length === 0 ||
    signature.length === ConsensusBCH.schnorrSignatureLength ||
    isValidSignatureEncodingDER(signature);
export const opCheckDataSig = ({ secp256k1, sha256, }) => (state) => 
// eslint-disable-next-line complexity
useThreeStackItems(state, (nextState, [signature, message, publicKey]) => {
    if (!isValidSignatureEncodingBCHRaw(signature)) {
        return applyError(AuthenticationErrorCommon.invalidSignatureEncoding, nextState);
    }
    if (!isValidPublicKeyEncoding(publicKey)) {
        return applyError(AuthenticationErrorCommon.invalidPublicKeyEncoding, nextState);
    }
    const digest = sha256.hash(message);
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    nextState.signedMessages.push(message);
    const useSchnorr = signature.length === ConsensusBCH.schnorrSignatureLength;
    const success = useSchnorr
        ? secp256k1.verifySignatureSchnorr(signature, publicKey, digest)
        : secp256k1.verifySignatureDERLowS(signature, publicKey, digest);
    return !success && signature.length !== 0
        ? applyError(AuthenticationErrorCommon.nonNullSignatureFailure, nextState)
        : pushToStack(nextState, booleanToScriptNumber(success));
});
export const opCheckDataSigVerify = ({ secp256k1, sha256, }) => combineOperations(opCheckDataSig({ secp256k1, sha256 }), opVerify());
export const opReverseBytes = () => (state) => useOneStackItem(state, (nextState, [item]) => pushToStack(nextState, item.slice().reverse()));
export const bitcoinCashOperations = ({ flags, secp256k1, sha256, }) => {
    const operations = {
        [OpcodesBCH.OP_CAT]: opCat(),
        [OpcodesBCH.OP_SPLIT]: opSplit(flags),
        [OpcodesBCH.OP_NUM2BIN]: opNum2Bin(),
        [OpcodesBCH.OP_BIN2NUM]: opBin2Num(),
        [OpcodesBCH.OP_AND]: opAnd(),
        [OpcodesBCH.OP_OR]: opOr(),
        [OpcodesBCH.OP_XOR]: opXor(),
        [OpcodesBCH.OP_DIV]: opDiv(flags),
        [OpcodesBCH.OP_MOD]: opMod(flags),
        [OpcodesBCH.OP_CHECKDATASIG]: opCheckDataSig({
            secp256k1,
            sha256,
        }),
        [OpcodesBCH.OP_CHECKDATASIGVERIFY]: opCheckDataSigVerify({ secp256k1, sha256 }),
    };
    return flags.opReverseBytes
        ? { ...operations, [OpcodesBCH.OP_REVERSEBYTES]: opReverseBytes() }
        : operations;
};
//# sourceMappingURL=bch-operations.js.map