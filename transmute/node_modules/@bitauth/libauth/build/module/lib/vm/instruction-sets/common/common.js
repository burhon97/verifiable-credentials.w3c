import { encodeOutpoints, encodeOutput, encodeOutputsForSigning, encodeSequenceNumbersForSigning, } from '../../../transaction/transaction-serialization';
import { arithmeticOperations } from './arithmetic';
import { bitwiseOperations } from './bitwise';
import { conditionallyEvaluate, incrementOperationCount, mapOverOperations, } from './combinators';
import { cryptoOperations } from './crypto';
import { applyError, AuthenticationErrorCommon } from './errors';
import { conditionalFlowControlOperations, reservedOperation, unconditionalFlowControlOperations, } from './flow-control';
import { disabledOperations, nonOperations } from './nop';
import { OpcodesCommon } from './opcodes';
import { pushNumberOperations, pushOperations } from './push';
import { spliceOperations } from './splice';
import { stackOperations } from './stack';
import { timeOperations } from './time';
export * from './arithmetic';
export * from './bitwise';
export * from './combinators';
export * from './crypto';
export * from './descriptions';
export * from './encoding';
export * from './errors';
export * from './flow-control';
export * from './nop';
export * from './opcodes';
export * from './push';
export * from './signing-serialization';
export * from './splice';
export * from './stack';
export * from './time';
export * from './types';
export var ConsensusCommon;
(function (ConsensusCommon) {
    /**
     * A.K.A. `MAX_SCRIPT_ELEMENT_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumStackItemLength"] = 520] = "maximumStackItemLength";
    ConsensusCommon[ConsensusCommon["maximumScriptNumberLength"] = 4] = "maximumScriptNumberLength";
    /**
     * A.K.A. `MAX_OPS_PER_SCRIPT`
     */
    ConsensusCommon[ConsensusCommon["maximumOperationCount"] = 201] = "maximumOperationCount";
    /**
     * A.K.A. `MAX_SCRIPT_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumBytecodeLength"] = 10000] = "maximumBytecodeLength";
    /**
     * A.K.A. `MAX_STACK_SIZE`
     */
    ConsensusCommon[ConsensusCommon["maximumStackDepth"] = 1000] = "maximumStackDepth";
})(ConsensusCommon || (ConsensusCommon = {}));
export const undefinedOperation = () => ({
    undefined: conditionallyEvaluate((state) => applyError(AuthenticationErrorCommon.unknownOpcode, state)),
});
export const checkLimitsCommon = (operation) => (state) => {
    const nextState = operation(state);
    return nextState.stack.length + nextState.alternateStack.length >
        ConsensusCommon.maximumStackDepth
        ? applyError(AuthenticationErrorCommon.exceededMaximumStackDepth, nextState)
        : nextState.operationCount > ConsensusCommon.maximumOperationCount
            ? applyError(AuthenticationErrorCommon.exceededMaximumOperationCount, nextState)
            : nextState;
};
export const commonOperations = ({ flags, ripemd160, secp256k1, sha1, sha256, }) => {
    const unconditionalOperations = {
        ...disabledOperations(),
        ...pushOperations(flags),
        ...mapOverOperations(unconditionalFlowControlOperations(flags), incrementOperationCount),
    };
    const conditionalOperations = mapOverOperations({
        ...pushNumberOperations(),
        [OpcodesCommon.OP_RESERVED]: reservedOperation(),
    }, conditionallyEvaluate);
    const incrementingOperations = mapOverOperations({
        ...arithmeticOperations(flags),
        ...bitwiseOperations(),
        ...cryptoOperations({
            flags,
            ripemd160,
            secp256k1,
            sha1,
            sha256,
        }),
        ...conditionalFlowControlOperations(),
        ...stackOperations(flags),
        ...spliceOperations(),
        ...timeOperations(flags),
        ...nonOperations(flags),
    }, conditionallyEvaluate, incrementOperationCount);
    return mapOverOperations({
        ...unconditionalOperations,
        ...incrementingOperations,
        ...conditionalOperations,
    }, checkLimitsCommon);
};
export const cloneStack = (stack) => stack.reduce((newStack, element) => {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    newStack.push(element.slice());
    return newStack;
}, []);
export const createAuthenticationProgramInternalStateCommon = ({ instructions, stack = [], }) => ({
    alternateStack: [],
    executionStack: [],
    instructions,
    ip: 0,
    lastCodeSeparator: -1,
    operationCount: 0,
    signatureOperationsCount: 0,
    signedMessages: [],
    stack,
});
export const createTransactionContextCommon = (program) => ({
    correspondingOutput: program.inputIndex < program.spendingTransaction.outputs.length
        ? encodeOutput(program.spendingTransaction.outputs[program.inputIndex])
        : undefined,
    locktime: program.spendingTransaction.locktime,
    outpointIndex: program.spendingTransaction.inputs[program.inputIndex].outpointIndex,
    outpointTransactionHash: program.spendingTransaction.inputs[program.inputIndex]
        .outpointTransactionHash,
    outputValue: program.sourceOutput.satoshis,
    sequenceNumber: program.spendingTransaction.inputs[program.inputIndex].sequenceNumber,
    transactionOutpoints: encodeOutpoints(program.spendingTransaction.inputs),
    transactionOutputs: encodeOutputsForSigning(program.spendingTransaction.outputs),
    transactionSequenceNumbers: encodeSequenceNumbersForSigning(program.spendingTransaction.inputs),
    version: program.spendingTransaction.version,
});
export const createAuthenticationProgramStateCommon = ({ transactionContext, instructions, stack, }) => ({
    ...createAuthenticationProgramInternalStateCommon({
        instructions,
        stack,
    }),
    ...transactionContext,
});
/**
 * Note: this implementation does not safely clone elements within array
 * properties. Mutating values within arrays will mutate those values in cloned
 * program states.
 */
export const cloneAuthenticationProgramStateCommon = (state) => ({
    ...(state.error === undefined ? {} : { error: state.error }),
    alternateStack: state.alternateStack.slice(),
    correspondingOutput: state.correspondingOutput,
    executionStack: state.executionStack.slice(),
    instructions: state.instructions.slice(),
    ip: state.ip,
    lastCodeSeparator: state.lastCodeSeparator,
    locktime: state.locktime,
    operationCount: state.operationCount,
    outpointIndex: state.outpointIndex,
    outpointTransactionHash: state.outpointTransactionHash.slice(),
    outputValue: state.outputValue,
    sequenceNumber: state.sequenceNumber,
    signatureOperationsCount: state.signatureOperationsCount,
    signedMessages: state.signedMessages.slice(),
    stack: state.stack.slice(),
    transactionOutpoints: state.transactionOutpoints,
    transactionOutputs: state.transactionOutputs,
    transactionSequenceNumbers: state.transactionSequenceNumbers,
    version: state.version,
});
const sha256HashLength = 32;
const outputValueLength = 8;
/**
 * This is a meaningless but complete `TransactionContextCommon` which uses `0`
 * values for each property.
 */
export const createTransactionContextCommonEmpty = () => ({
    correspondingOutput: Uint8Array.of(0),
    locktime: 0,
    outpointIndex: 0,
    outpointTransactionHash: new Uint8Array(sha256HashLength),
    outputValue: new Uint8Array(outputValueLength),
    sequenceNumber: 0,
    transactionOutpoints: Uint8Array.of(0),
    transactionOutputs: Uint8Array.of(0),
    transactionSequenceNumbers: Uint8Array.of(0),
    version: 0,
});
const correspondingOutput = 1;
const transactionOutpoints = 2;
const transactionOutputs = 3;
const transactionSequenceNumbers = 4;
const outpointTransactionHashFill = 5;
/**
 * This is a meaningless but complete `TransactionContextCommon` which uses a
 * different value for each property. This is useful for testing and debugging.
 */
export const createTransactionContextCommonTesting = () => ({
    correspondingOutput: Uint8Array.of(correspondingOutput),
    locktime: 0,
    outpointIndex: 0,
    outpointTransactionHash: new Uint8Array(sha256HashLength).fill(outpointTransactionHashFill),
    outputValue: new Uint8Array(outputValueLength),
    sequenceNumber: 0,
    transactionOutpoints: Uint8Array.of(transactionOutpoints),
    transactionOutputs: Uint8Array.of(transactionOutputs),
    transactionSequenceNumbers: Uint8Array.of(transactionSequenceNumbers),
    version: 0,
});
/**
 * Create an "empty" common authentication program state, suitable for testing a
 * VM/compiler.
 */
export const createAuthenticationProgramStateCommonEmpty = ({ instructions, stack = [], }) => ({
    ...createAuthenticationProgramInternalStateCommon({ instructions, stack }),
    ...createTransactionContextCommonEmpty(),
});
//# sourceMappingURL=common.js.map