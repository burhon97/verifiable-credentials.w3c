import { isScriptNumberError, parseBytesAsScriptNumber } from './common';
import { applyError, AuthenticationErrorCommon } from './errors';
import { OpcodesCommon } from './opcodes';
var Bits;
(function (Bits) {
    Bits[Bits["sequenceLocktimeDisableFlag"] = 31] = "sequenceLocktimeDisableFlag";
    Bits[Bits["sequenceLocktimeTypeFlag"] = 22] = "sequenceLocktimeTypeFlag";
})(Bits || (Bits = {}));
var Constants;
(function (Constants) {
    Constants[Constants["locktimeScriptNumberByteLength"] = 5] = "locktimeScriptNumberByteLength";
    Constants[Constants["locktimeThreshold"] = 500000000] = "locktimeThreshold";
    Constants[Constants["locktimeDisablingSequenceNumber"] = 4294967295] = "locktimeDisablingSequenceNumber";
    Constants[Constants["sequenceLocktimeTransactionVersionMinimum"] = 2] = "sequenceLocktimeTransactionVersionMinimum";
    // eslint-disable-next-line no-bitwise
    Constants[Constants["sequenceLocktimeDisableFlag"] = 2147483648] = "sequenceLocktimeDisableFlag";
    // eslint-disable-next-line no-bitwise
    Constants[Constants["sequenceLocktimeTypeFlag"] = 4194304] = "sequenceLocktimeTypeFlag";
    Constants[Constants["sequenceGranularity"] = 9] = "sequenceGranularity";
    Constants[Constants["sequenceLocktimeMask"] = 65535] = "sequenceLocktimeMask";
})(Constants || (Constants = {}));
export const readLocktime = (state, operation, flags) => {
    const item = state.stack[state.stack.length - 1];
    if (item === undefined) {
        return applyError(AuthenticationErrorCommon.emptyStack, state);
    }
    const parsedLocktime = parseBytesAsScriptNumber(item, {
        maximumScriptNumberByteLength: Constants.locktimeScriptNumberByteLength,
        requireMinimalEncoding: flags.requireMinimalEncoding,
    });
    if (isScriptNumberError(parsedLocktime)) {
        return applyError(AuthenticationErrorCommon.invalidScriptNumber, state);
    }
    const locktime = Number(parsedLocktime);
    if (locktime < 0) {
        return applyError(AuthenticationErrorCommon.negativeLocktime, state);
    }
    return operation(state, locktime);
};
const locktimeTypesAreCompatible = (locktime, requiredLocktime) => (locktime < Constants.locktimeThreshold &&
    requiredLocktime < Constants.locktimeThreshold) ||
    (locktime >= Constants.locktimeThreshold &&
        requiredLocktime >= Constants.locktimeThreshold);
export const opCheckLockTimeVerify = (flags) => (state) => readLocktime(state, (nextState, requiredLocktime) => {
    if (!locktimeTypesAreCompatible(nextState.locktime, requiredLocktime)) {
        return applyError(AuthenticationErrorCommon.incompatibleLocktimeType, nextState);
    }
    if (requiredLocktime > nextState.locktime) {
        return applyError(AuthenticationErrorCommon.unsatisfiedLocktime, nextState);
    }
    if (nextState.sequenceNumber === Constants.locktimeDisablingSequenceNumber) {
        return applyError(AuthenticationErrorCommon.locktimeDisabled, nextState);
    }
    return nextState;
}, flags);
// eslint-disable-next-line no-bitwise
const includesFlag = (value, flag) => (value & flag) !== 0;
export const opCheckSequenceVerify = (flags) => (state) => readLocktime(state, 
// eslint-disable-next-line complexity
(nextState, requiredSequence) => {
    const sequenceLocktimeDisabled = includesFlag(requiredSequence, Constants.sequenceLocktimeDisableFlag);
    if (sequenceLocktimeDisabled) {
        return nextState;
    }
    if (nextState.version < Constants.sequenceLocktimeTransactionVersionMinimum) {
        return applyError(AuthenticationErrorCommon.checkSequenceUnavailable, nextState);
    }
    if (includesFlag(nextState.sequenceNumber, Constants.sequenceLocktimeDisableFlag)) {
        return applyError(AuthenticationErrorCommon.unmatchedSequenceDisable, nextState);
    }
    if (includesFlag(requiredSequence, Constants.sequenceLocktimeTypeFlag) !==
        includesFlag(nextState.sequenceNumber, Constants.sequenceLocktimeTypeFlag)) {
        return applyError(AuthenticationErrorCommon.incompatibleSequenceType, nextState);
    }
    if (
    // eslint-disable-next-line no-bitwise
    (requiredSequence & Constants.sequenceLocktimeMask) >
        // eslint-disable-next-line no-bitwise
        (nextState.sequenceNumber & Constants.sequenceLocktimeMask)) {
        return applyError(AuthenticationErrorCommon.unsatisfiedSequenceNumber, nextState);
    }
    return nextState;
}, flags);
export const timeOperations = (flags) => ({
    [OpcodesCommon.OP_CHECKLOCKTIMEVERIFY]: opCheckLockTimeVerify(flags),
    [OpcodesCommon.OP_CHECKSEQUENCEVERIFY]: opCheckSequenceVerify(flags),
});
//# sourceMappingURL=time.js.map