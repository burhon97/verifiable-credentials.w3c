import { combineOperations, pushToStack, useOneScriptNumber, useThreeScriptNumbers, useTwoScriptNumbers, } from './combinators';
import { opVerify } from './flow-control';
import { OpcodesCommon } from './opcodes';
import { bigIntToScriptNumber, booleanToScriptNumber } from './types';
export const op1Add = ({ requireMinimalEncoding, }) => (state) => useOneScriptNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToScriptNumber(value + BigInt(1))), { requireMinimalEncoding });
export const op1Sub = ({ requireMinimalEncoding, }) => (state) => useOneScriptNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToScriptNumber(value - BigInt(1))), { requireMinimalEncoding });
export const opNegate = ({ requireMinimalEncoding, }) => (state) => useOneScriptNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToScriptNumber(-value)), { requireMinimalEncoding });
export const opAbs = ({ requireMinimalEncoding, }) => (state) => useOneScriptNumber(state, (nextState, [value]) => pushToStack(nextState, bigIntToScriptNumber(value < 0 ? -value : value)), { requireMinimalEncoding });
export const opNot = ({ requireMinimalEncoding, }) => (state) => useOneScriptNumber(state, (nextState, [value]) => pushToStack(nextState, value === BigInt(0)
    ? bigIntToScriptNumber(BigInt(1))
    : bigIntToScriptNumber(BigInt(0))), { requireMinimalEncoding });
export const op0NotEqual = ({ requireMinimalEncoding, }) => (state) => useOneScriptNumber(state, (nextState, [value]) => pushToStack(nextState, value === BigInt(0)
    ? bigIntToScriptNumber(BigInt(0))
    : bigIntToScriptNumber(BigInt(1))), { requireMinimalEncoding });
export const opAdd = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToScriptNumber(firstValue + secondValue)), { requireMinimalEncoding });
export const opSub = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToScriptNumber(firstValue - secondValue)), { requireMinimalEncoding });
export const opBoolAnd = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToScriptNumber(firstValue !== BigInt(0) && secondValue !== BigInt(0))), { requireMinimalEncoding });
export const opBoolOr = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToScriptNumber(firstValue !== BigInt(0) || secondValue !== BigInt(0))), { requireMinimalEncoding });
export const opNumEqual = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToScriptNumber(firstValue === secondValue)), { requireMinimalEncoding });
export const opNumEqualVerify = (flags) => combineOperations(opNumEqual(flags), opVerify());
export const opNumNotEqual = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToScriptNumber(firstValue !== secondValue)), { requireMinimalEncoding });
export const opLessThan = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToScriptNumber(firstValue < secondValue)), { requireMinimalEncoding });
export const opLessThanOrEqual = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToScriptNumber(firstValue <= secondValue)), { requireMinimalEncoding });
export const opGreaterThan = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToScriptNumber(firstValue > secondValue)), { requireMinimalEncoding });
export const opGreaterThanOrEqual = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, booleanToScriptNumber(firstValue >= secondValue)), { requireMinimalEncoding });
export const opMin = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToScriptNumber(firstValue < secondValue ? firstValue : secondValue)), { requireMinimalEncoding });
export const opMax = ({ requireMinimalEncoding, }) => (state) => useTwoScriptNumbers(state, (nextState, [firstValue, secondValue]) => pushToStack(nextState, bigIntToScriptNumber(firstValue > secondValue ? firstValue : secondValue)), { requireMinimalEncoding });
export const opWithin = ({ requireMinimalEncoding, }) => (state) => useThreeScriptNumbers(state, (nextState, [firstValue, secondValue, thirdValue]) => pushToStack(nextState, booleanToScriptNumber(secondValue <= firstValue && firstValue < thirdValue)), { requireMinimalEncoding });
export const arithmeticOperations = (flags) => ({
    [OpcodesCommon.OP_1ADD]: op1Add(flags),
    [OpcodesCommon.OP_1SUB]: op1Sub(flags),
    [OpcodesCommon.OP_NEGATE]: opNegate(flags),
    [OpcodesCommon.OP_ABS]: opAbs(flags),
    [OpcodesCommon.OP_NOT]: opNot(flags),
    [OpcodesCommon.OP_0NOTEQUAL]: op0NotEqual(flags),
    [OpcodesCommon.OP_ADD]: opAdd(flags),
    [OpcodesCommon.OP_SUB]: opSub(flags),
    [OpcodesCommon.OP_BOOLAND]: opBoolAnd(flags),
    [OpcodesCommon.OP_BOOLOR]: opBoolOr(flags),
    [OpcodesCommon.OP_NUMEQUAL]: opNumEqual(flags),
    [OpcodesCommon.OP_NUMEQUALVERIFY]: opNumEqualVerify(flags),
    [OpcodesCommon.OP_NUMNOTEQUAL]: opNumNotEqual(flags),
    [OpcodesCommon.OP_LESSTHAN]: opLessThan(flags),
    [OpcodesCommon.OP_LESSTHANOREQUAL]: opLessThanOrEqual(flags),
    [OpcodesCommon.OP_GREATERTHAN]: opGreaterThan(flags),
    [OpcodesCommon.OP_GREATERTHANOREQUAL]: opGreaterThanOrEqual(flags),
    [OpcodesCommon.OP_MIN]: opMin(flags),
    [OpcodesCommon.OP_MAX]: opMax(flags),
    [OpcodesCommon.OP_WITHIN]: opWithin(flags),
});
//# sourceMappingURL=arithmetic.js.map