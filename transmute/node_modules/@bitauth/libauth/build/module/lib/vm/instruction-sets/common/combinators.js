import { isScriptNumberError, parseBytesAsScriptNumber } from './common';
import { applyError, AuthenticationErrorCommon } from './errors';
export const incrementOperationCount = (operation) => (state) => {
    const nextState = operation(state);
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    nextState.operationCount += 1;
    return nextState;
};
export const conditionallyEvaluate = (operation) => (state) => state.executionStack.every((item) => item) ? operation(state) : state;
/**
 * Map a function over each operation in an `InstructionSet.operations` object,
 * assigning the result to the same `opcode` in the resulting object.
 * @param operations - an operations map from an `InstructionSet`
 * @param combinator - a function to apply to each operation
 */
export const mapOverOperations = (operations, ...combinators) => Object.keys(operations).reduce((result, operation) => ({
    ...result,
    [operation]: combinators.reduce((op, combinator) => combinator(op), operations[parseInt(operation, 10)]),
}), {});
/**
 * Pop one stack item off of `state.stack` and provide that item to `operation`.
 */
export const useOneStackItem = (state, operation) => {
    // eslint-disable-next-line functional/immutable-data
    const item = state.stack.pop();
    if (item === undefined) {
        return applyError(AuthenticationErrorCommon.emptyStack, state);
    }
    return operation(state, [item]);
};
export const useTwoStackItems = (state, operation) => useOneStackItem(state, (nextState, [valueTwo]) => useOneStackItem(nextState, (lastState, [valueTop]) => operation(lastState, [valueTop, valueTwo])));
export const useThreeStackItems = (state, operation) => useOneStackItem(state, (nextState, [valueThree]) => useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [valueTop, valueTwo, valueThree])));
export const useFourStackItems = (state, operation) => useTwoStackItems(state, (nextState, [valueThree, valueFour]) => useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [valueTop, valueTwo, valueThree, valueFour])));
export const useSixStackItems = (state, operation) => useFourStackItems(state, (nextState, [valueThree, valueFour, valueFive, valueSix]) => useTwoStackItems(nextState, (lastState, [valueTop, valueTwo]) => operation(lastState, [
    valueTop,
    valueTwo,
    valueThree,
    valueFour,
    valueFive,
    valueSix,
])));
const normalMaximumScriptNumberByteLength = 4;
export const useOneScriptNumber = (state, operation, { requireMinimalEncoding, maximumScriptNumberByteLength = normalMaximumScriptNumberByteLength, }) => useOneStackItem(state, (nextState, [item]) => {
    const value = parseBytesAsScriptNumber(item, {
        maximumScriptNumberByteLength,
        requireMinimalEncoding,
    });
    if (isScriptNumberError(value)) {
        return applyError(AuthenticationErrorCommon.invalidScriptNumber, state);
    }
    return operation(nextState, [value]);
});
export const useTwoScriptNumbers = (state, operation, { requireMinimalEncoding, maximumScriptNumberByteLength = normalMaximumScriptNumberByteLength, }) => useOneScriptNumber(state, (nextState, [secondValue]) => useOneScriptNumber(nextState, (lastState, [firstValue]) => operation(lastState, [firstValue, secondValue]), { maximumScriptNumberByteLength, requireMinimalEncoding }), { maximumScriptNumberByteLength, requireMinimalEncoding });
export const useThreeScriptNumbers = (state, operation, { requireMinimalEncoding, maximumScriptNumberByteLength = normalMaximumScriptNumberByteLength, }) => useTwoScriptNumbers(state, (nextState, [secondValue, thirdValue]) => useOneScriptNumber(nextState, (lastState, [firstValue]) => operation(lastState, [firstValue, secondValue, thirdValue]), { maximumScriptNumberByteLength, requireMinimalEncoding }), { maximumScriptNumberByteLength, requireMinimalEncoding });
/**
 * Return the provided state with the provided value pushed to its stack.
 * @param state - the state to update and return
 * @param data - the value to push to the stack
 */
export const pushToStack = (state, ...data) => {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    state.stack.push(...data);
    return state;
};
// TODO: if firstOperation errors, secondOperation might overwrite the error
export const combineOperations = (firstOperation, secondOperation) => (state) => secondOperation(firstOperation(state));
//# sourceMappingURL=combinators.js.map