import { Operation } from '../../virtual-machine';
import { AuthenticationProgramStateError, AuthenticationProgramStateExecutionStack, AuthenticationProgramStateMinimum, AuthenticationProgramStateStack } from '../../vm-types';
import { AuthenticationErrorCommon } from './errors';
import { OpcodesCommon } from './opcodes';
export declare enum PushOperationConstants {
    OP_0 = 0,
    /**
     * OP_PUSHBYTES_75
     */
    maximumPushByteOperationSize = 75,
    OP_PUSHDATA_1 = 76,
    OP_PUSHDATA_2 = 77,
    OP_PUSHDATA_4 = 78,
    /**
     * OP_PUSHDATA_4
     */
    highestPushDataOpcode = 78,
    /**
     * For OP_1 to OP_16, `opcode` is the number offset by `0x50` (80):
     *
     * `OP_N = 0x50 + N`
     *
     * OP_0 is really OP_PUSHBYTES_0 (`0x00`), so it does not follow this pattern.
     */
    pushNumberOpcodesOffset = 80,
    /** OP_1 through OP_16 */
    pushNumberOpcodes = 16,
    negativeOne = 129,
    OP_1NEGATE = 79,
    /**
     * 256 - 1
     */
    maximumPushData1Size = 255,
    /**
     * Standard consensus parameter for most Bitcoin forks.
     */
    maximumPushSize = 520,
    /**
     * 256 ** 2 - 1
     */
    maximumPushData2Size = 65535,
    /**
     * 256 ** 4 - 1
     */
    maximumPushData4Size = 4294967295
}
/**
 * Returns the minimal bytecode required to push the provided `data` to the
 * stack.
 *
 * @remarks
 * This method conservatively encodes a `Uint8Array` as a data push. For Script
 * Numbers which can be pushed using a single opcode (-1 through 16), the
 * equivalent bytecode value is returned. Other `data` values will be prefixed
 * with the proper opcode and push length bytes (if necessary) to create the
 * minimal push instruction.
 *
 * Note, while some single-byte Script Number pushes will be minimally-encoded
 * by this method, all larger inputs will be encoded as-is (it cannot be assumed
 * that inputs are intended to be used as Script Numbers). To encode the push of
 * a Script Number, minimally-encode the number before passing it to this
 * method, e.g.:
 * `encodeDataPush(bigIntToScriptNumber(parseBytesAsScriptNumber(nonMinimalNumber)))`.
 *
 * The maximum `bytecode` length which can be encoded for a push in the Bitcoin
 * system is `4294967295` (~4GB). This method assumes a smaller input â€“ if
 * `bytecode` has the potential to be longer, it should be checked (and the
 * error handled) prior to calling this method.
 *
 * @param data - the Uint8Array to push to the stack
 */
export declare const encodeDataPush: (data: Uint8Array) => Uint8Array;
/**
 * Returns true if the provided `data` is minimally-encoded by the provided
 * `opcode`.
 * @param opcode - the opcode used to push `data`
 * @param data - the contents of the push
 */
export declare const isMinimalDataPush: (opcode: number, data: Uint8Array) => boolean;
export declare const pushByteOpcodes: readonly OpcodesCommon[];
export declare const pushOperation: <Opcodes, State extends AuthenticationProgramStateStack<Uint8Array> & AuthenticationProgramStateMinimum<Opcodes> & AuthenticationProgramStateError<Errors, AuthenticationErrorCommon> & AuthenticationProgramStateExecutionStack, Errors>(flags: {
    requireMinimalEncoding: boolean;
}, maximumPushSize?: PushOperationConstants) => Operation<State>;
export declare const pushOperations: <Opcodes, State extends AuthenticationProgramStateStack<Uint8Array> & AuthenticationProgramStateMinimum<Opcodes> & AuthenticationProgramStateError<Errors, AuthenticationErrorCommon> & AuthenticationProgramStateExecutionStack, Errors>(flags: {
    requireMinimalEncoding: boolean;
}, maximumPushSize?: PushOperationConstants) => {
    readonly [opcode: number]: Operation<State>;
};
export declare const pushNumberOpcodes: readonly OpcodesCommon[];
export declare const pushNumberOperations: <Opcodes, ProgramState extends AuthenticationProgramStateStack<Uint8Array> & AuthenticationProgramStateMinimum<Opcodes>>() => {
    readonly [opcode: number]: Operation<ProgramState>;
};
//# sourceMappingURL=push.d.ts.map