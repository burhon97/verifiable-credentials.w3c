import { opNot } from './arithmetic';
import { conditionallyEvaluate, useOneStackItem } from './combinators';
import { stackItemIsTruthy } from './common';
import { applyError, AuthenticationErrorCommon } from './errors';
import { OpcodesCommon } from './opcodes';
export const opVerify = () => (state) => useOneStackItem(state, (nextState, [item]) => stackItemIsTruthy(item)
    ? nextState
    : applyError(AuthenticationErrorCommon.failedVerify, nextState));
export const reservedOperation = () => (state) => applyError(AuthenticationErrorCommon.calledReserved, state);
export const opReturn = () => (state) => applyError(AuthenticationErrorCommon.calledReturn, state);
export const conditionalFlowControlOperations = () => ({
    [OpcodesCommon.OP_RESERVED]: reservedOperation(),
    [OpcodesCommon.OP_VER]: reservedOperation(),
    [OpcodesCommon.OP_VERIFY]: opVerify(),
    [OpcodesCommon.OP_RETURN]: opReturn(),
    [OpcodesCommon.OP_RESERVED1]: reservedOperation(),
    [OpcodesCommon.OP_RESERVED2]: reservedOperation(),
});
export const opIf = () => (state) => {
    if (state.executionStack.every((item) => item)) {
        // eslint-disable-next-line functional/immutable-data
        const element = state.stack.pop();
        if (element === undefined) {
            return applyError(AuthenticationErrorCommon.emptyStack, state);
        }
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        state.executionStack.push(stackItemIsTruthy(element));
        return state;
    }
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    state.executionStack.push(false);
    return state;
};
export const opNotIf = (flags) => {
    const not = conditionallyEvaluate(opNot(flags));
    const ifOp = opIf();
    return (state) => ifOp(not(state));
};
export const opEndIf = () => (state) => {
    // eslint-disable-next-line functional/immutable-data
    const element = state.executionStack.pop();
    if (element === undefined) {
        return applyError(AuthenticationErrorCommon.unexpectedEndIf, state);
    }
    return state;
};
export const opElse = () => (state) => {
    const top = state.executionStack[state.executionStack.length - 1];
    if (top === undefined) {
        return applyError(AuthenticationErrorCommon.unexpectedElse, state);
    }
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    state.executionStack[state.executionStack.length - 1] = !top;
    return state;
};
export const unconditionalFlowControlOperations = (flags) => ({
    [OpcodesCommon.OP_IF]: opIf(),
    [OpcodesCommon.OP_NOTIF]: opNotIf(flags),
    [OpcodesCommon.OP_VERIF]: reservedOperation(),
    [OpcodesCommon.OP_VERNOTIF]: reservedOperation(),
    [OpcodesCommon.OP_ELSE]: opElse(),
    [OpcodesCommon.OP_ENDIF]: opEndIf(),
});
//# sourceMappingURL=flow-control.js.map