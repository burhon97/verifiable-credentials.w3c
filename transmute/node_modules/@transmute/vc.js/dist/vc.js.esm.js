import { purposes, sign, verify as verify$2 } from '@transmute/linked-data-proof';
import jsonld from 'jsonld';
import { check } from '@transmute/jsonld-schema';
import moment from 'moment';
import { JsonWebKey } from '@transmute/json-web-signature';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

// Killer regex to parse RFC3339 dates

var RFC_3339 = /*#__PURE__*/new RegExp("^([0-9]{4})-([0-9]{2})-([0-9]{2})" + "([Tt]([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?)?" + "(([Zz]|([+-])([0-9]{2}):([0-9]{2})))?"); // Tweaked to allow for leap seconds

var ISO_8601_FULL = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-6]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
var TIME_ZONE_OFFSET_MATCH = /[+-]\d\d:\d\d$/; // https://www.w3.org/TR/NOTE-datetime-970915
// against RFC 3339 / ISO 8601 and moment.
// see also: https://github.com/w3c/vc-data-model/issues/782

var checkDate = function checkDate(datetime, isJWT) {
  if (isJWT === void 0) {
    isJWT = false;
  }

  var res = {
    valid: false,
    warnings: []
  };

  if (!ISO_8601_FULL.test(datetime)) {
    res.warnings.push(datetime + " is not a legal ISO 8601 Date Time.");
  }

  if (!RFC_3339.test(datetime)) {
    res.warnings.push(datetime + " is not a legal RFC 3339 Date Time.");
  }

  moment.suppressDeprecationWarnings = true; // If leap second (60 seconds) make it a valid date

  var newDatetime = datetime;
  var isLeapSecond = false;

  try {
    if (newDatetime.split(":")[2].substring(0, 2) === "60") {
      newDatetime = newDatetime.replace("60", "59");
      var newDate = new Date(newDatetime);
      newDate.setSeconds(new Date(newDatetime).getSeconds() + 1);
      newDatetime = newDate.toISOString();
      isLeapSecond = true;
    }
  } catch (err) {}

  if (moment(newDatetime).toISOString() === null) {
    res.warnings.push(datetime + " could not be parsed and serialized as ISO 8601 Date Time.");
  }

  if (isJWT) {
    if (isLeapSecond) {
      res.warnings.push(datetime + " lost leap second information.");
    }

    if (TIME_ZONE_OFFSET_MATCH.test(datetime)) {
      res.warnings.push(datetime + " lost timezone offset information.");
    }

    if (new Date(newDatetime).getMilliseconds()) {
      res.warnings.push(datetime + " lost millisecond information.");
    }
  }

  moment.suppressDeprecationWarnings = false;
  res.valid = res.warnings.length === 0;
  return res;
};

function _getId(obj) {
  if (typeof obj === "string") {
    return obj;
  }

  if (!("id" in obj)) {
    return;
  }

  return obj.id;
}

var checkCredential = function checkCredential(credential, options) {
  try {
    var documentLoader = options.documentLoader;
    var strict = options.strict || "warn";

    if (options.strict === "ignore") {
      return Promise.resolve(undefined);
    }

    var isJWT = false;

    if (typeof credential === "string") {
      var _credential$split = credential.split("."),
          encodedHeader = _credential$split[0],
          encodedPayload = _credential$split[1];

      var header = JSON.parse(Buffer.from(encodedHeader, "base64").toString());

      if (!header.alg) {
        throw new Error("alg is required in JWT header");
      }

      var payload = JSON.parse(Buffer.from(encodedPayload, "base64").toString());
      credential = payload.vc;
      isJWT = true;
    }

    if (!credential["@context"]) {
      throw new Error("Verifiable Credentials MUST include a @context property.");
    }

    if (!documentLoader) {
      throw new TypeError('"documentLoader" parameter is required for checking presentations.');
    }

    return Promise.resolve(check({
      input: credential,
      documentLoader: documentLoader
    })).then(function (isValidJsonLd) {
      if (!isValidJsonLd.ok) {
        throw new Error("credential is not valid JSON-LD: " + JSON.stringify(isValidJsonLd.error, null, 2));
      } // check type presence and cardinality


      if (!credential["type"]) {
        throw new Error('"type" property is required.');
      }

      if (!jsonld.getValues(credential, "type").includes("VerifiableCredential")) {
        throw new Error('"type" must include `VerifiableCredential`.');
      }

      if (!credential["credentialSubject"]) {
        throw new Error('"credentialSubject" property is required.');
      }

      if (!credential["issuer"]) {
        throw new Error('"issuer" property is required.');
      } // check issuanceDate cardinality


      if (jsonld.getValues(credential, "issuanceDate").length > 1) {
        throw new Error('"issuanceDate" property can only have one value.');
      } // check issued is a date


      if (!credential["issuanceDate"]) {
        throw new Error('"issuanceDate" property is required.');
      }

      if ("issuanceDate" in credential) {
        var res = checkDate(credential.issuanceDate, isJWT);

        if (!res.valid) {
          var message = ["issuanceDate is not valid: " + JSON.stringify(res.warnings, null, 2), "issuanceDate must be XML Datestring as defined in spec: https://w3c.github.io/vc-data-model/#issuance-date"].join("\n");

          if (strict == "warn") {
            console.warn(message);
          }

          if (strict == "throw") {
            throw new Error(message);
          }
        }
      } // check expires is a date


      if ("expirationDate" in credential) {
        var _res = checkDate(credential.expirationDate, isJWT);

        if (!_res.valid) {
          var _message = ["expirationDate is not valid: " + JSON.stringify(_res.warnings, null, 2), "expirationDate must be XML Datestring as defined in spec: https://w3c.github.io/vc-data-model/#expiration"].join("\n");

          if (strict == "warn") {
            console.warn(_message);
          }

          if (strict == "throw") {
            throw new Error(_message);
          }
        }
      } // check issuer cardinality


      if (jsonld.getValues(credential, "issuer").length > 1) {
        throw new Error('"issuer" property can only have one value.');
      } // check issuer is a URL
      // FIXME


      if ("issuer" in credential) {
        var issuer = _getId(credential.issuer);

        if (!issuer) {
          throw new Error("\"issuer\" id is required.");
        }

        if (!issuer.includes(":")) {
          throw new Error("\"issuer\" id must be a URL: " + issuer);
        }
      }

      if ("credentialStatus" in credential) {
        if (!credential.credentialStatus.id) {
          throw new Error('"credentialStatus" must include an id.');
        }

        if (!credential.credentialStatus.type) {
          throw new Error('"credentialStatus" must include a type.');
        }
      } // check evidences are URLs
      // FIXME


      jsonld.getValues(credential, "evidence").forEach(function (evidence) {
        var evidenceId = _getId(evidence);

        if (evidenceId && !evidenceId.includes(":")) {
          throw new Error("\"evidence\" id must be a URL: " + evidence);
        }
      });
      return undefined;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var AssertionProofPurpose = purposes.AssertionProofPurpose;
var CredentialIssuancePurpose = /*#__PURE__*/function (_AssertionProofPurpos) {
  _inheritsLoose(CredentialIssuancePurpose, _AssertionProofPurpos);

  function CredentialIssuancePurpose(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        controller = _ref.controller,
        date = _ref.date,
        maxTimestampDelta = _ref.maxTimestampDelta;

    return _AssertionProofPurpos.call(this, {
      controller: controller,
      date: date,
      maxTimestampDelta: maxTimestampDelta
    }) || this;
  }

  var _proto = CredentialIssuancePurpose.prototype;

  _proto.validate = function validate(proof, _ref2) {
    var document = _ref2.document,
        suite = _ref2.suite,
        verificationMethod = _ref2.verificationMethod,
        documentLoader = _ref2.documentLoader,
        expansionMap = _ref2.expansionMap;

    try {
      var _this2 = this;

      return Promise.resolve(_catch(function () {
        return Promise.resolve(_AssertionProofPurpos.prototype.validate.call(_this2, proof, {
          document: document,
          suite: suite,
          verificationMethod: verificationMethod,
          documentLoader: documentLoader,
          expansionMap: expansionMap
        })).then(function (result) {
          if (!result.valid) {
            throw result.error;
          }

          var issuer = typeof document.issuer === "string" ? document.issuer : document.issuer.id;

          if (!issuer) {
            throw new Error("Credential issuer is required.");
          }

          if (result.controller.id !== issuer) {
            throw new Error("Credential issuer must match the verification method controller.");
          }

          return {
            valid: true
          };
        });
      }, function (error) {
        return {
          valid: false,
          error: error
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return CredentialIssuancePurpose;
}(AssertionProofPurpose);

var createVerifiableCredential = function createVerifiableCredential(options) {
  try {
    var credential = options.credential,
        suite = options.suite,
        documentLoader = options.documentLoader;
    var strict = options.strict || "warn"; // run common credential checks

    if (!credential) {
      throw new TypeError('"credential" parameter is required for issuing.');
    }

    return Promise.resolve(checkCredential(credential, {
      documentLoader: documentLoader,
      strict: strict
    })).then(function () {
      if (!documentLoader) {
        throw new TypeError('"documentLoader" parameter is required for issuing.');
      }

      if (!suite) {
        throw new TypeError('"suite" parameter is required for issuing.');
      } // check to make sure the `suite` has required params
      // Note: verificationMethod defaults to publicKey.id, in suite constructor...
      // ...in some implementations...


      if (!suite.verificationMethod) {
        throw new TypeError('"suite.verificationMethod" property is required.');
      }

      var purpose = new CredentialIssuancePurpose();
      return sign(credential, _extends({
        purpose: purpose
      }, options));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyVerifiableCredential = function verifyVerifiableCredential(options) {
  try {
    var credential = options.credential,
        checkStatus = options.checkStatus,
        documentLoader = options.documentLoader;
    var compactProof = false;

    if (options.expansionMap !== undefined) {
      var message = "The default options are not being used.";
      throw new Error(message);
    }

    return Promise.resolve(_catch(function () {
      if (!credential) {
        throw new TypeError('A "credential" property is required for verifying.');
      } // run common credential checks


      return Promise.resolve(checkCredential(credential, {
        documentLoader: documentLoader
      })).then(function () {
        // if credential status is provided, a `checkStatus` function must be given
        if (credential.credentialStatus && typeof options.checkStatus !== "function") {
          throw new TypeError('A "checkStatus" function must be given to verify credentials with ' + '"credentialStatus".');
        }

        var purpose = new CredentialIssuancePurpose();
        return Promise.resolve(verify$2(credential, _extends({}, options, {
          purpose: purpose,
          compactProof: compactProof
        }))).then(function (result) {
          // if verification has already failed, skip status check
          if (!result.verified) {
            return result;
          }

          var _temp = function () {
            if (credential.credentialStatus) {
              return Promise.resolve(checkStatus(options)).then(function (_checkStatus) {
                result.statusResult = _checkStatus;

                if (!result.statusResult.verified) {
                  result.verified = false;
                }
              });
            }
          }();

          return _temp && _temp.then ? _temp.then(function () {
            return result;
          }) : result;
        });
      });
    }, function (error) {
      return {
        verified: false,
        results: [{
          credential: credential,
          verified: false,
          error: error
        }],
        error: error
      };
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var checkPresentation = function checkPresentation(presentation, options) {
  try {
    var documentLoader = options.documentLoader,
        domain = options.domain,
        challenge = options.challenge;
    var strict = options.strict || "warn";

    if (typeof presentation === "string") {
      var _presentation$split = presentation.split("."),
          encodedHeader = _presentation$split[0],
          encodedPayload = _presentation$split[1];

      var header = JSON.parse(Buffer.from(encodedHeader, "base64").toString());

      if (!header.alg) {
        throw new Error("alg is required in JWT header");
      }

      var payload = JSON.parse(Buffer.from(encodedPayload, "base64").toString());
      presentation = payload.vp;

      if (payload.aud) {
        if (payload.aud !== domain) {
          throw new Error('"aud" and "domain" does not match this verifiable presentation');
        }
      }

      if (payload.nonce) {
        if (payload.nonce !== challenge) {
          throw new Error('"nonce" and "challenge" does not match this verifiable presentation');
        }
      }
    }

    if (!presentation["@context"]) {
      throw new Error("Verifiable Presentations MUST include a @context property.");
    }

    if (!documentLoader) {
      throw new TypeError('"documentLoader" parameter is required for checking presentations.');
    }

    return Promise.resolve(check({
      input: presentation,
      documentLoader: documentLoader
    })).then(function (isValidJsonLd) {
      if (!isValidJsonLd.ok) {
        throw new Error("presentation is not valid JSON-LD: " + JSON.stringify(isValidJsonLd.error, null, 2));
      }

      var types = jsonld.getValues(presentation, "type"); // check type presence

      if (!types.includes("VerifiablePresentation")) {
        throw new Error('"type" must include "VerifiablePresentation".');
      }

      var _temp = function () {
        if (presentation.verifiableCredential) {
          var credentials = Array.isArray(presentation.verifiableCredential) ? presentation.verifiableCredential : [presentation.verifiableCredential];
          return Promise.resolve(Promise.all(credentials.map(function (vc) {
            try {
              return Promise.resolve(checkCredential(vc, {
                documentLoader: documentLoader,
                strict: strict
              })).then(function () {});
            } catch (e) {
              return Promise.reject(e);
            }
          }))).then(function () {});
        }
      }();

      if (_temp && _temp.then) return _temp.then(function () {});
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createVerifiablePresentation = function createVerifiablePresentation(options) {
  try {
    var presentation = options.presentation,
        domain = options.domain,
        challenge = options.challenge,
        documentLoader = options.documentLoader;
    var strict = options.strict || "warn";
    return Promise.resolve(checkPresentation(presentation, {
      documentLoader: documentLoader,
      strict: strict
    })).then(function () {
      var purpose = new purposes.AuthenticationProofPurpose({
        domain: domain,
        challenge: challenge
      });
      return sign(presentation, _extends({}, options, {
        purpose: purpose
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var getVerifierForJwt = function getVerifierForJwt(jwt, options) {
  try {
    var _jwt$split$splice$map = jwt.split(".").splice(0, 1).map(function (item) {
      return JSON.parse(Buffer.from(item, "base64").toString());
    }),
        header = _jwt$split$splice$map[0];

    if (!header.kid) {
      throw new Error('Transmute requires "kid" in vc-jwt headers. Otherwise key dereferencing is not always possible.');
    }

    var suite = Array.isArray(options.suite) ? options.suite[0] : options.suite;
    return Promise.resolve(suite.getVerificationMethod({
      proof: {
        verificationMethod: header.kid
      },
      documentLoader: options.documentLoader,
      instance: true // need this to get the class instance

    })).then(function (verificationMethod) {
      if (!verificationMethod || !verificationMethod.useJwa) {
        throw new Error('Transmute requires "suite.getVerificationMethod" to return a key instance with member useJwa.');
      }

      var _from = JsonWebKey.from;
      return Promise.resolve(verificationMethod["export"]({
        type: "JsonWebKey2020"
      })).then(function (_verificationMethod$e) {
        return Promise.resolve(_from.call(JsonWebKey, _verificationMethod$e, {
          detached: false
        })).then(function (k2) {
          var verifier = k2.verifier();
          return verifier;
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var decodeJwt = function decodeJwt(jwt) {
  var _jwt$split = jwt.split("."),
      encodedHeader = _jwt$split[0],
      encodedPayload = _jwt$split[1],
      encodedSignature = _jwt$split[2];

  var _map = [encodedHeader, encodedPayload].map(function (item) {
    return JSON.parse(Buffer.from(item, "base64").toString());
  }),
      header = _map[0],
      payload = _map[1];

  return {
    header: header,
    payload: payload,
    signature: encodedSignature
  };
};

var verifyVerifiableCredential$1 = function verifyVerifiableCredential(jwt, options) {
  try {
    var verifier = options.verifier,
        documentLoader = options.documentLoader;
    var strict = options.strict || "warn";
    return Promise.resolve(checkCredential(jwt, {
      documentLoader: documentLoader,
      strict: strict
    })).then(function () {
      return Promise.resolve(verifier.verify({
        signature: jwt
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyCredentialsInPresentation = function verifyCredentialsInPresentation(presentation, options) {
  try {
    var result = {
      verified: false
    };
    return Promise.resolve(Promise.all(presentation.verifiableCredential.map(function (credential) {
      try {
        var _temp3 = function _temp3(_result) {
          if (_exit2) return _result;

          if (credential.credentialStatus && !options.checkStatus) {
            throw new Error("options.checkStatus is required to verify presentation of revocable credentials.");
          }

          return Promise.resolve(verifyVerifiableCredential(_extends({
            credential: credential
          }, options))).then(function (res) {
            return _extends({
              credentialId: credential.id
            }, res);
          });
        };

        var _exit2 = false;

        var _temp4 = function () {
          if (!credential["@context"]) {
            return Promise.resolve(getVerifierForJwt(credential, options)).then(function (verifier) {
              return Promise.resolve(verifyVerifiableCredential$1(credential, _extends({}, options, {
                verifier: verifier
              }))).then(function (res) {
                var decoded = decodeJwt(credential);
                var _credentialId$verifie = {
                  credentialId: decoded.payload.vc.id || undefined,
                  verified: res
                };
                _exit2 = true;
                return _credentialId$verifie;
              });
            });
          }
        }();

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    }))).then(function (results) {
      result.verified = results.every(function (r) {
        return r.verified;
      });
      result.results = results;
      return result;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyVerifiablePresentation = function verifyVerifiablePresentation(options) {
  try {
    var _temp11 = function _temp11(_result2) {
      if (_exit4) return _result2;

      function _temp8() {
        function _temp6() {
          if (result.presentation && !result.credentials) {
            result.verified = result.presentation.verified;
          }

          if (result.presentation && result.credentials) {
            result.verified = result.presentation.verified && result.credentials.verified;
          }

          return result;
        }

        var _temp5 = function () {
          if (presentation.proof) {
            var purpose = new purposes.AuthenticationProofPurpose({
              domain: domain,
              challenge: challenge
            });
            return Promise.resolve(verify$2(presentation, _extends({}, options, {
              purpose: purpose
            }))).then(function (verification) {
              result.presentation = verification;
            });
          } else {
            result.presentation = result.credentials;
          }
        }();

        return _temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5);
      }

      if (!presentation.proof && !presentation.verifiableCredential || presentation.verifiableCredential && presentation.verifiableCredential.length === 0) {
        var message = 'presentation MUST contain "proof" or "verifiableCredential"';
        throw new Error(message);
      }

      if (!presentation.proof) {
        var _message = 'presentation MUST contain "proof" when strict';

        if (strict == "warn") {
          console.warn(_message);
        }

        if (strict == "throw") {
          throw new Error(_message);
        }
      }

      var result = {
        verified: false
      };

      var _temp7 = function () {
        if (presentation.verifiableCredential && presentation.verifiableCredential.length) {
          return Promise.resolve(verifyCredentialsInPresentation(presentation, options)).then(function (credentials) {
            result.credentials = credentials;

            if (!credentials.verified) {
              result.verified = false;
            }
          });
        }
      }();

      return _temp7 && _temp7.then ? _temp7.then(_temp8) : _temp8(_temp7);
    };

    var _exit4 = false;
    var documentLoader = options.documentLoader,
        domain = options.domain,
        challenge = options.challenge;
    var strict = options.strict || "warn";
    var presentation = options.presentation;

    if (!documentLoader) {
      throw new TypeError('"documentLoader" parameter is required for verifying.');
    }

    if (!presentation) {
      throw new TypeError('A "presentation" property is required for verifying.');
    }

    var _temp12 = _catch(function () {
      return Promise.resolve(checkPresentation(presentation, {
        documentLoader: documentLoader,
        strict: strict
      })).then(function () {});
    }, function (e) {
      var _verified$presentatio = {
        verified: false,
        presentation: e
      };
      _exit4 = true;
      return _verified$presentatio;
    });

    return Promise.resolve(_temp12 && _temp12.then ? _temp12.then(_temp11) : _temp11(_temp12));
  } catch (e) {
    return Promise.reject(e);
  }
};



var index = {
  __proto__: null,
  createVerifiableCredential: createVerifiableCredential,
  verifyVerifiableCredential: verifyVerifiableCredential,
  createVerifiablePresentation: createVerifiablePresentation,
  verifyVerifiablePresentation: verifyVerifiablePresentation
};

var createVcPayload = function createVcPayload(credential, options) {
  try {
    var documentLoader = options.documentLoader;
    var strict = options.strict || "warn";

    if (!credential.issuer) {
      throw new Error("Issuer is a required field.");
    }

    return Promise.resolve(checkCredential(credential, {
      documentLoader: documentLoader,
      strict: strict
    })).then(function () {
      var issuer = credential.issuer.id ? credential.issuer.id : credential.issuer;
      var subject = credential.credentialSubject.id ? credential.credentialSubject.id : credential.credentialSubject;
      var payload = {
        iss: issuer,
        sub: subject,
        vc: credential,
        jti: credential.id,
        nbf: moment(credential.issuanceDate).unix()
      };

      if (credential.expirationDate) {
        payload.exp = moment(credential.expirationDate).unix();
      }

      return payload;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createVerifiableCredential$1 = function createVerifiableCredential(credential, options) {
  try {
    var signer = options.signer;
    return Promise.resolve(createVcPayload(credential, options)).then(function (payload) {
      return Promise.resolve(signer.sign({
        data: payload
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createVpPayload = function createVpPayload(presentation, options) {
  try {
    var documentLoader = options.documentLoader,
        domain = options.domain,
        challenge = options.challenge;
    var strict = options.strict || "warn";

    if (!challenge) {
      throw new Error('"challenge" is required to create verifiable presentations (it will be used for the "nonce" value)');
    }

    return Promise.resolve(checkPresentation(presentation, {
      documentLoader: documentLoader,
      strict: strict,
      domain: domain,
      challenge: challenge
    })).then(function () {
      var payload = {};

      if (presentation.holder) {
        var holder = presentation.holder.id ? presentation.holder.id : presentation.holder;
        payload.iss = holder;
        payload.sub = holder;
      }

      payload.vp = presentation;

      if (domain) {
        payload.aud = domain;
      }

      if (challenge) {
        payload.nonce = challenge;
      }

      return payload;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var createVerifiablePresentation$1 = function createVerifiablePresentation(presentation, options) {
  try {
    var signer = options.signer;
    return Promise.resolve(createVpPayload(presentation, options)).then(function (payload) {
      return Promise.resolve(signer.sign({
        data: payload
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verifyVerifiablePresentation$1 = function verifyVerifiablePresentation(jwt, options) {
  try {
    var verifier = options.verifier,
        documentLoader = options.documentLoader,
        domain = options.domain,
        challenge = options.challenge;
    var strict = options.strict || "warn";
    return Promise.resolve(checkPresentation(jwt, {
      documentLoader: documentLoader,
      strict: strict,
      domain: domain,
      challenge: challenge
    })).then(function () {
      return Promise.resolve(verifier.verify({
        signature: jwt
      }));
    });
  } catch (e) {
    return Promise.reject(e);
  }
};



var index$1 = {
  __proto__: null,
  createVcPayload: createVcPayload,
  createVerifiableCredential: createVerifiableCredential$1,
  verifyVerifiableCredential: verifyVerifiableCredential$1,
  createVpPayload: createVpPayload,
  createVerifiablePresentation: createVerifiablePresentation$1,
  verifyVerifiablePresentation: verifyVerifiablePresentation$1
};

var create = function create(options) {
  try {
    var _temp4 = function _temp4() {
      var _exit = false;

      var _temp = function () {
        if (options.format.includes("vc-jwt")) {
          var suite = Array.isArray(options.suite) ? options.suite[0] : options.suite;
          var key = suite.key;

          if (!key || !key.useJwa) {
            throw new Error("Cannot create credential when suite does not contain a key that supports useJwa.");
          }

          var _from2 = JsonWebKey.from;
          return Promise.resolve(key["export"]({
            type: "JsonWebKey2020",
            privateKey: true
          })).then(function (_key$export) {
            return Promise.resolve(_from2.call(JsonWebKey, _key$export, {
              detached: false,
              header: {
                kid: key.id
              }
            })).then(function (k2) {
              var signer = k2.signer();
              return Promise.resolve(createVcPayload(options.credential, options)).then(function (payload) {
                var _result$items2 = result.items,
                    _push2 = _result$items2.push;
                return Promise.resolve(signer.sign({
                  data: payload
                })).then(function (_signer$sign) {
                  _push2.call(_result$items2, _signer$sign);
                });
              });
            });
          });
        }
      }();

      return _temp && _temp.then ? _temp.then(function (_result) {
        return _exit ? _result : result;
      }) : _exit ? _temp : result;
    };

    var result = {
      items: []
    };

    if (!options.format) {
      options.format = ["vc"];
    }

    var _temp5 = function () {
      if (options.format.includes("vc")) {
        var _result$items3 = result.items,
            _push3 = _result$items3.push;
        return Promise.resolve(createVerifiableCredential({
          credential: options.credential,
          suite: options.suite,
          documentLoader: options.documentLoader
        })).then(function (_ld$createVerifiableC) {
          _push3.call(_result$items3, _ld$createVerifiableC);
        });
      }
    }();

    return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
  } catch (e) {
    return Promise.reject(e);
  }
};

var _excluded = ["proof"];
var derive = function derive(options) {
  try {
    var result = {
      items: []
    };

    if (!options.format) {
      options.format = ["vc"];
    }

    var credential = options.credential,
        frame = options.frame,
        suite = options.suite,
        documentLoader = options.documentLoader;

    var proof = credential.proof,
        document = _objectWithoutPropertiesLoose(credential, _excluded);

    if (!suite.deriveProof) {
      throw new Error("Suite requires deriveProof");
    }

    return Promise.resolve(suite.deriveProof({
      document: document,
      proof: _extends({}, proof, {
        "@context": document["@context"]
      }),
      revealDocument: frame,
      documentLoader: documentLoader
    })).then(function (derivationResult) {
      var derivedCredential = _extends({}, derivationResult.document, {
        proof: derivationResult.proof
      });

      delete derivedCredential.proof["@context"];
      result.items.push(derivedCredential);
      return result;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var verify = function verify(options) {
  try {
    var _temp4 = function _temp4() {
      var _temp = function () {
        if (options.format.includes("vc-jwt") && !options.credential["@context"]) {
          return Promise.resolve(getVerifierForJwt(options.credential, options)).then(function (verifier) {
            return Promise.resolve(verifier.verify({
              signature: options.credential
            })).then(function (verified) {
              result.verified = verified;
            });
          });
        }
      }();

      // vc-jwt's are strings with an encoded vc member that conforms to the data model
      return _temp && _temp.then ? _temp.then(function () {
        return result;
      }) : result;
    };

    var result = {
      verified: false
    };

    if (!options.format) {
      options.format = ["vc"];
    }

    var _temp5 = function () {
      if (options.format.includes("vc") && options.credential["@context"]) {
        return Promise.resolve(verifyVerifiableCredential({
          credential: options.credential,
          suite: options.suite,
          documentLoader: options.documentLoader,
          checkStatus: options.checkStatus,
          expansionMap: options.expansionMap
        })).then(function (res) {
          result.verified = res.verified;

          if (!result.verified) {
            result.error = [];

            if (res && res.statusResult && !res.statusResult.verified) {
              result.error.push({
                statusResult: res.statusResult
              });
            }

            if (res && res.results[0] && !res.results[0].verified) {
              result.error.push({
                proofResult: res.results[0].verified
              });
            }

            if (res.error) {
              result.error.push(res.error);
            }
          }
        });
      }
    }();

    return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
  } catch (e) {
    return Promise.reject(e);
  }
};

var credential = {
  create: create,
  derive: derive,
  verify: verify
};

var create$1 = function create(options) {
  try {
    var _temp4 = function _temp4() {
      var _exit = false;

      var _temp = function () {
        if (options.format.includes("vp-jwt")) {
          var suite = Array.isArray(options.suite) ? options.suite[0] : options.suite;
          var key = suite.key;

          if (!key || !key.useJwa) {
            throw new Error("Cannot create credential when suite does not contain a key that supports useJwa.");
          }

          var _from2 = JsonWebKey.from;
          return Promise.resolve(key["export"]({
            type: "JsonWebKey2020",
            privateKey: true
          })).then(function (_key$export) {
            return Promise.resolve(_from2.call(JsonWebKey, _key$export, {
              detached: false,
              header: {
                kid: key.id
              }
            })).then(function (k2) {
              var signer = k2.signer();
              return Promise.resolve(createVpPayload(options.presentation, options)).then(function (payload) {
                var _result$items2 = result.items,
                    _push2 = _result$items2.push;
                return Promise.resolve(signer.sign({
                  data: payload
                })).then(function (_signer$sign) {
                  _push2.call(_result$items2, _signer$sign);
                });
              });
            });
          });
        }
      }();

      return _temp && _temp.then ? _temp.then(function (_result) {
        return _exit ? _result : result;
      }) : _exit ? _temp : result;
    };

    var result = {
      items: []
    };

    if (!options.format) {
      options.format = ["vp"];
    }

    var _temp5 = function () {
      if (options.format.includes("vp")) {
        var _result$items3 = result.items,
            _push3 = _result$items3.push;
        return Promise.resolve(createVerifiablePresentation({
          presentation: options.presentation,
          suite: options.suite,
          domain: options.domain,
          challenge: options.challenge,
          documentLoader: options.documentLoader
        })).then(function (_ld$createVerifiableP) {
          _push3.call(_result$items3, _ld$createVerifiableP);
        });
      }
    }();

    return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
  } catch (e) {
    return Promise.reject(e);
  }
};

var verify$1 = function verify(options) {
  try {
    var result = {
      verified: false
    };

    if (!options.format) {
      options.format = ["vp"];
    }

    if (options.format.includes("vp") && options.presentation["@context"]) {
      return Promise.resolve(verifyVerifiablePresentation({
        presentation: options.presentation,
        suite: options.suite,
        domain: options.domain,
        challenge: options.challenge,
        checkStatus: options.checkStatus,
        documentLoader: options.documentLoader
      }));
    } // vp-jwt's are strings with an encoded vp member that conforms to the data model


    var _temp2 = function () {
      if (options.format.includes("vp-jwt") && !options.presentation["@context"]) {
        return Promise.resolve(getVerifierForJwt(options.presentation, options)).then(function (verifier) {
          return Promise.resolve(verifier.verify({
            signature: options.presentation
          })).then(function (verified) {
            result.verified = verified;
          });
        });
      }
    }();

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {
      return result;
    }) : result);
  } catch (e) {
    return Promise.reject(e);
  }
};

var presentation = {
  create: create$1,
  verify: verify$1
};

var jwt = {
  decode: decodeJwt
};
var verifiable = {
  credential: credential,
  presentation: presentation,
  jwt: jwt
};

export { index$1 as jwt, index as ld, verifiable };
//# sourceMappingURL=vc.js.esm.js.map
