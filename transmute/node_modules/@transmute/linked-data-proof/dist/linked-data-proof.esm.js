import jsonld from 'jsonld';
import { serializeError } from 'serialize-error';

var ProofPurpose = /*#__PURE__*/function () {
  function ProofPurpose(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        term = _ref.term,
        date = _ref.date,
        _ref$maxTimestampDelt = _ref.maxTimestampDelta,
        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;

    if (term === undefined) {
      throw new Error('"term" is required.');
    }

    if (maxTimestampDelta !== undefined && typeof maxTimestampDelta !== "number") {
      throw new TypeError('"maxTimestampDelta" must be a number.');
    }

    this.term = term;

    if (date !== undefined) {
      this.date = new Date(date);

      if (isNaN(this.date)) {
        throw TypeError("\"date\" \"" + date + "\" is not a valid date.");
      }
    }

    this.maxTimestampDelta = maxTimestampDelta;
  }

  var _proto = ProofPurpose.prototype;

  _proto.validate = function validate(proof, _options) {
    try {
      var _this2 = this;

      try {
        // check expiration
        if (_this2.maxTimestampDelta !== Infinity) {
          var expected = (_this2.date || new Date()).getTime();
          var delta = _this2.maxTimestampDelta * 1000;
          var created = new Date(proof.created).getTime(); // comparing this way handles NaN case where `created` is invalid

          if (!(created >= expected - delta && created <= expected + delta)) {
            throw new Error("The proof's created timestamp is out of range.");
          }
        }

        return Promise.resolve({
          valid: true
        });
      } catch (error) {
        return Promise.resolve({
          valid: false,
          error: error
        });
      }
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Called to update a proof when it is being created, adding any properties
   * specific to this purpose. This method is called prior to the proof
   * value being generated such that any properties added may be, for example,
   * included in a digital signature value.
   *
   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`
   *   to update.
   *
   * @return {Promise<object>} resolves to the proof instance (in the
   *   `constants.SECURITY_CONTEXT_URL`.
   */
  ;

  _proto.update = function update(proof, _options) {
    try {
      var _this4 = this;

      proof.proofPurpose = _this4.term;
      return Promise.resolve(proof);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Determines if the given proof has a purpose that matches this instance,
   * i.e. this ProofPurpose instance should be used to validate the given
   * proof.
   *
   * @param proof {object} the proof to check.
   *
   * @return {Promise<boolean>} `true` if there's a match, `false` if not.
   */
  ;

  _proto.match = function match(proof // { document, documentLoader, expansionMap }
  ) {
    try {
      var _this6 = this;

      return Promise.resolve(proof.proofPurpose === _this6.term);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return ProofPurpose;
}();

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var ControllerProofPurpose = /*#__PURE__*/function (_ProofPurpose) {
  _inheritsLoose(ControllerProofPurpose, _ProofPurpose);

  function ControllerProofPurpose(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        term = _ref.term,
        date = _ref.date,
        _ref$maxTimestampDelt = _ref.maxTimestampDelta,
        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;

    return _ProofPurpose.call(this, {
      term: term,
      date: date,
      maxTimestampDelta: maxTimestampDelta
    }) || this;
  }

  var _proto = ControllerProofPurpose.prototype;

  _proto.validate = function validate(proof, _options) {
    try {
      var _this2 = this;

      return Promise.resolve(_catch(function () {
        return Promise.resolve(_ProofPurpose.prototype.validate.call(_this2, proof, _options)).then(function (result) {
          if (!result.valid) {
            throw result.error;
          }

          var verificationMethod = _options.verificationMethod,
              documentLoader = _options.documentLoader;
          var verificationId = verificationMethod.id;
          var controller = verificationMethod.controller;
          var controllerId = controller.id;
          return Promise.resolve(documentLoader(controllerId)).then(function (_ref2) {
            var document = _ref2.document;
            result.controller = document;
            var verificationMethods = jsonld.getValues(result.controller, _this2.term);
            result.valid = verificationMethods.some(function (vm) {
              return vm === verificationId || vm === "#" + verificationId.split("#").pop() || typeof vm === "object" && vm.id === verificationId;
            });

            if (!result.valid) {
              throw new Error("Verification method \"" + verificationMethod.id + "\" not authorized " + ("by controller for proof purpose \"" + _this2.term + "\"."));
            }

            return result;
          });
        });
      }, function (error) {
        return {
          valid: false,
          error: error
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return ControllerProofPurpose;
}(ProofPurpose);

var AssertionProofPurpose = /*#__PURE__*/function (_ControllerProofPurpo) {
  _inheritsLoose(AssertionProofPurpose, _ControllerProofPurpo);

  function AssertionProofPurpose(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$term = _ref.term,
        term = _ref$term === void 0 ? "assertionMethod" : _ref$term,
        controller = _ref.controller,
        date = _ref.date,
        _ref$maxTimestampDelt = _ref.maxTimestampDelta,
        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;

    return _ControllerProofPurpo.call(this, {
      term: term,
      controller: controller,
      date: date,
      maxTimestampDelta: maxTimestampDelta
    }) || this;
  }

  return AssertionProofPurpose;
}(ControllerProofPurpose);

var AuthenticationProofPurpose = /*#__PURE__*/function (_ControllerProofPurpo) {
  _inheritsLoose(AuthenticationProofPurpose, _ControllerProofPurpo);

  function AuthenticationProofPurpose(_temp) {
    var _this;

    var _ref = _temp === void 0 ? {} : _temp,
        _ref$term = _ref.term,
        term = _ref$term === void 0 ? "authentication" : _ref$term,
        controller = _ref.controller,
        challenge = _ref.challenge,
        date = _ref.date,
        domain = _ref.domain,
        _ref$maxTimestampDelt = _ref.maxTimestampDelta,
        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;

    _this = _ControllerProofPurpo.call(this, {
      term: term,
      controller: controller,
      date: date,
      maxTimestampDelta: maxTimestampDelta
    }) || this;

    if (typeof challenge !== "string") {
      throw new TypeError('"challenge" must be a string.');
    }

    if (domain !== undefined && typeof domain !== "string") {
      throw new TypeError('"domain" must be a string.');
    }

    _this.challenge = challenge;
    _this.domain = domain;
    return _this;
  }

  var _proto = AuthenticationProofPurpose.prototype;

  _proto.validate = function validate(proof, _ref2) {
    var verificationMethod = _ref2.verificationMethod,
        documentLoader = _ref2.documentLoader,
        expansionMap = _ref2.expansionMap;

    try {
      var _this3 = this;

      try {
        // check challenge
        if (proof.challenge !== _this3.challenge) {
          throw new Error("The challenge is not as expected; " + ("challenge=\"" + proof.challenge + "\", expected=\"" + _this3.challenge + "\""));
        } // check domain


        if (_this3.domain !== undefined && proof.domain !== _this3.domain) {
          throw new Error("The domain is not as expected; " + ("domain=\"" + proof.domain + "\", expected=\"" + _this3.domain + "\""));
        }

        return Promise.resolve(_ControllerProofPurpo.prototype.validate.call(_this3, proof, {
          verificationMethod: verificationMethod,
          documentLoader: documentLoader,
          expansionMap: expansionMap
        }));
      } catch (error) {
        return Promise.resolve({
          valid: false,
          error: error
        });
      }
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.update = function update(proof, _options) {
    try {
      var _this5 = this;

      return Promise.resolve(_ControllerProofPurpo.prototype.update.call(_this5, proof, _options)).then(function (_ControllerProofPurpo2) {
        proof = _ControllerProofPurpo2;
        proof.challenge = _this5.challenge;

        if (_this5.domain !== undefined) {
          proof.domain = _this5.domain;
        }

        return proof;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return AuthenticationProofPurpose;
}(ControllerProofPurpose);

var purposes = {
  ProofPurpose: ProofPurpose,
  ControllerProofPurpose: ControllerProofPurpose,
  AssertionProofPurpose: AssertionProofPurpose,
  AuthenticationProofPurpose: AuthenticationProofPurpose
};

// strict expansion map disallows dropping properties when expanding by default
var strictExpansionMap = (function (info) {
  if (info.unmappedProperty) {
    throw new Error("The property \"" + info.unmappedProperty + "\" in the input was not defined in the context.");
  }
});

var ProofSet = /*#__PURE__*/function () {
  function ProofSet() {
    var _this = this,
        _this2 = this;

    this._getProofs = function (_ref) {
      var document = _ref.document,
          documentLoader = _ref.documentLoader,
          expansionMap = _ref.expansionMap,
          compactProof = _ref.compactProof;

      try {
        var _temp3 = function _temp3() {
          proofSet = jsonld.getValues(document, proofProperty);
          delete document[proofProperty];

          if (proofSet.length === 0) {
            // no possible matches
            throw new Error("No matching proofs found in the given document.");
          }

          var secV2Locked = ["BbsBlsSignatureProof2020"]; // TODO: consider in-place editing to optimize

          var context = document["@context"];
          proofSet = proofSet.map(function (proof) {
            return _extends({
              // this is required because of...
              // https://github.com/mattrglobal/jsonld-signatures-bbs/blob/master/src/BbsBlsSignatureProof2020.ts#L32
              // A seperate implementation is probably advisable.
              "@context": secV2Locked.includes(proof.type) ? ["https://w3id.org/security/v2"] : context
            }, proof);
          });
          return {
            proofSet: proofSet,
            document: document
          };
        };

        // handle document preprocessing to find proofs
        var proofProperty = "proof";
        var proofSet;

        var _temp4 = function () {
          if (compactProof) {
            // if we must compact the proof(s) then we must first compact the input
            // document to find the proof(s)
            var context = document["@context"]; // console.log(document);

            return Promise.resolve(jsonld.compact(document, context, {
              documentLoader: documentLoader,
              expansionMap: expansionMap,
              compactToRelative: false
            })).then(function (_jsonld$compact) {
              document = _jsonld$compact;
            });
          }
        }();

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    };

    this._verify = function (_ref2) {
      var document = _ref2.document,
          suites = _ref2.suites,
          proofSet = _ref2.proofSet,
          purpose = _ref2.purpose,
          documentLoader = _ref2.documentLoader,
          expansionMap = _ref2.expansionMap,
          compactProof = _ref2.compactProof;

      try {
        // filter out matching proofs
        return Promise.resolve(Promise.all(proofSet.map(function (proof) {
          return purpose.match(proof, {
            document: document,
            documentLoader: documentLoader,
            expansionMap: expansionMap
          });
        }))).then(function (result) {
          var matches = proofSet.filter(function (_value, index) {
            return result[index];
          });
          return matches.length === 0 ? [] : Promise.resolve(Promise.all(matches.map(function (proof) {
            try {
              for (var _iterator = _createForOfIteratorHelperLoose(suites), _step; !(_step = _iterator()).done;) {
                var s = _step.value;
                // Previously we used s.matchProof
                // since issues were reported here:
                // https://github.com/digitalbazaar/jsonld-signatures/issues/143
                // https://github.com/mattrglobal/jsonld-signatures-bbs/issues/139
                // we think matchProof should be a simply string comparison here...
                // and no support for the "expanded" proofs should be provided...
                var matchFound = s.type.replace("sec:", "") === proof.type;

                if (matchFound) {
                  return Promise.resolve(s.verifyProof({
                    proof: proof,
                    document: document,
                    purpose: purpose,
                    documentLoader: documentLoader,
                    expansionMap: expansionMap,
                    compactProof: compactProof
                  })["catch"](function (error) {
                    return {
                      verified: false,
                      error: error
                    };
                  }));
                }
              }

              return Promise.resolve();
            } catch (e) {
              return Promise.reject(e);
            }
          }))).then(function (_Promise$all) {
            return _Promise$all.map(function (r, i) {
              if (!r) {
                return null;
              }

              if (r.error) {
                _this._addToJSON(r.error);
              }

              return _extends({
                proof: matches[i]
              }, r);
            }).filter(function (r) {
              return r;
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };

    this._addToJSON = function (error) {
      Object.defineProperty(error, "toJSON", {
        value: function value() {
          return serializeError(this);
        },
        configurable: true,
        writable: true
      });
    };

    this.verify = function (document, _temp7) {
      var _ref3 = _temp7 === void 0 ? {} : _temp7,
          suite = _ref3.suite,
          purpose = _ref3.purpose,
          documentLoader = _ref3.documentLoader,
          expansionMap = _ref3.expansionMap,
          _ref3$compactProof = _ref3.compactProof,
          compactProof = _ref3$compactProof === void 0 ? false : _ref3$compactProof;

      try {
        if (!suite) {
          throw new TypeError('"options.suite" is required.');
        }

        if (!purpose) {
          throw new TypeError('"options.purpose" is required.');
        }

        var suites = Array.isArray(suite) ? suite : [suite];

        if (suites.length === 0) {
          throw new TypeError("At least one suite is required.");
        }

        var legacy = suites.some(function (s) {
          return s.legacy;
        });

        if (legacy) {
          throw new TypeError("Legacy suites are no longer supported.");
        }

        if (!documentLoader) {
          throw new TypeError('"options.documentLoader" is required.');
        }

        if (expansionMap !== false) {
          expansionMap = strictExpansionMap;
        }

        return Promise.resolve(_catch(function () {
          function _temp6() {
            // get proofs from document
            return Promise.resolve(_this2._getProofs({
              document: document,
              documentLoader: documentLoader,
              expansionMap: expansionMap,
              compactProof: compactProof
            })).then(function (_ref4) {
              var proofSet = _ref4.proofSet,
                  doc = _ref4.document;
              document = doc; // verify proofs

              return Promise.resolve(_this2._verify({
                document: document,
                suites: suites,
                proofSet: proofSet,
                purpose: purpose,
                documentLoader: documentLoader,
                expansionMap: expansionMap,
                compactProof: compactProof
              })).then(function (results) {
                if (results.length === 0) {
                  throw new Error("Could not verify any proofs; no proofs matched the required " + "suite and purpose.");
                } // combine results


                var verified = results.some(function (r) {
                  return r.verified;
                });

                if (!verified) {
                  var _ref5;

                  var errors = (_ref5 = []).concat.apply(_ref5, results.filter(function (r) {
                    return r.error;
                  }).map(function (r) {
                    return r.error;
                  }));

                  var result = {
                    verified: verified,
                    results: results
                  };

                  if (errors.length > 0) {
                    result.error = errors;
                  }

                  return result;
                }

                return {
                  verified: verified,
                  results: results
                };
              });
            });
          }

          var _temp5 = function () {
            if (typeof document === "string") {
              // fetch document
              return Promise.resolve(documentLoader(document)).then(function (_documentLoader) {
                document = _documentLoader;
              });
            } else {
              // never mutate function arguments.
              document = JSON.parse(JSON.stringify(document));
            }
          }();

          return _temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5);
        }, function (error) {
          _this2._addToJSON(error);

          return {
            verified: false,
            error: error
          };
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  }

  var _proto = ProofSet.prototype;

  _proto.add = function add(document, _temp10) {
    var _ref6 = _temp10 === void 0 ? {
      compactProof: true
    } : _temp10,
        suite = _ref6.suite,
        purpose = _ref6.purpose,
        documentLoader = _ref6.documentLoader,
        expansionMap = _ref6.expansionMap,
        _ref6$compactProof = _ref6.compactProof,
        compactProof = _ref6$compactProof === void 0 ? true : _ref6$compactProof;

    try {
      var _temp11 = function _temp11() {
        // preprocess document to prepare to remove existing proofs
        var input = _extends({}, document); // save but exclude any existing proof(s)


        var proofProperty = "proof"; //const existingProofs = input[proofProperty];

        delete input[proofProperty];
        return Promise.resolve(suite.createProof({
          document: input,
          purpose: purpose,
          documentLoader: documentLoader,
          expansionMap: expansionMap,
          compactProof: compactProof
        })).then(function (proof) {
          delete proof["@context"]; // this is required here, for cases where the suite
          // still requires / uses sec-v2... like bbs+

          proof.type = proof.type.replace("sec:", "");
          jsonld.addValue(document, proofProperty, proof);
          return document;
        });
      };

      if (!suite) {
        throw new TypeError('"options.suite" is required.');
      }

      if (!documentLoader) {
        throw new TypeError('"options.documentLoader" is required.');
      }

      if (!purpose) {
        throw new TypeError('"options.purpose" is required.');
      }

      if (suite.legacy) {
        throw new TypeError("Legacy suites are no longer supported.");
      }

      if (expansionMap !== false) {
        expansionMap = strictExpansionMap;
      }

      var _temp12 = function () {
        if (typeof document === "string") {
          // fetch document
          return Promise.resolve(documentLoader(document)).then(function (_documentLoader2) {
            document = _documentLoader2;
          });
        }
      }();

      return Promise.resolve(_temp12 && _temp12.then ? _temp12.then(_temp11) : _temp11(_temp12));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return ProofSet;
}();

var sign = function sign(document, _temp) {
  var _ref = _temp === void 0 ? {
    compactProof: true
  } : _temp,
      suite = _ref.suite,
      purpose = _ref.purpose,
      documentLoader = _ref.documentLoader,
      expansionMap = _ref.expansionMap,
      compactProof = _ref.compactProof;

  try {
    return Promise.resolve(_catch(function () {
      return Promise.resolve(new ProofSet().add(document, {
        suite: suite,
        purpose: purpose,
        documentLoader: documentLoader,
        expansionMap: expansionMap,
        compactProof: compactProof
      }));
    }, function (e) {
      if (!documentLoader && e.name === "jsonld.InvalidUrl") {
        var url = e.details.url;
        var err = new Error("A URL \"" + url + "\" could not be fetched;" + "you need to pass \"documentLoader\" or resolve the URL before calling \"sign\".");
        err.cause = e;
        throw err;
      }

      throw e;
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var VerificationError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(VerificationError, _Error);

  function VerificationError(errors) {
    var _this;

    _this = _Error.call(this, "Verification error(s).") || this;
    _this.name = "VerificationError";
    _this.errors = [].concat(errors);
    return _this;
  }

  return VerificationError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var verify = function verify(document, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      suite = _ref.suite,
      purpose = _ref.purpose,
      documentLoader = _ref.documentLoader,
      expansionMap = _ref.expansionMap,
      compactProof = _ref.compactProof;

  try {
    return Promise.resolve(new ProofSet().verify(document, {
      suite: suite,
      purpose: purpose,
      documentLoader: documentLoader,
      expansionMap: expansionMap,
      compactProof: compactProof
    })).then(function (result) {
      var error = result.error;

      if (error) {
        if (!documentLoader && error.name === "jsonld.InvalidUrl") {
          var url = error.details.url;
          var urlError = new Error("A URL \"" + url + "\" could not be fetched; you need to pass " + '"documentLoader" or resolve the URL before calling "verify".');
          result.error = new VerificationError(urlError);
        } else {
          result.error = new VerificationError(error);
        }
      }

      return result;
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

export { purposes, sign, verify };
//# sourceMappingURL=linked-data-proof.esm.js.map
