"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSubset = exports.areSchemasEqual = void 0;
const schema_builder_1 = require("./schema-builder");
function areSchemasEqual(schema1, schema2, options) {
    if (schema1 === undefined && schema2 === undefined)
        return true;
    if (schema1 === undefined || schema2 === undefined)
        return false;
    const anyOf1 = schema_builder_1.unwrapSchema(schema1);
    const anyOf2 = schema_builder_1.unwrapSchema(schema2);
    if (anyOf1.length != anyOf2.length)
        return false;
    if (anyOf1.length === 0)
        return true;
    const typeComparator = (s1, s2) => s1.type.toLocaleString().localeCompare(s2.type.toLocaleString());
    const sorted1 = [...anyOf1].sort(typeComparator);
    const sorted2 = [...anyOf2].sort(typeComparator);
    for (let i = 0; i < anyOf1.length; i++) {
        const s1 = sorted1[i];
        const s2 = sorted2[i];
        if (s1.type !== s2.type)
            return false;
        if (!(options === null || options === void 0 ? void 0 : options.ignoreRequired) && !areArraysEqual(s1.required, s2.required))
            return false;
        if (!arePropsEqual(s1.properties, s2.properties, options))
            return false;
        if (!areSchemasEqual(s1.items, s2.items, options))
            return false;
    }
    return true;
}
exports.areSchemasEqual = areSchemasEqual;
function areArraysEqual(arr1, arr2) {
    if (arr1 === undefined && arr2 === undefined)
        return true;
    if (arr1 === undefined || arr2 === undefined)
        return false;
    const set1 = new Set(arr1);
    const set2 = new Set(arr2);
    const combined = new Set([...arr1, ...arr2]);
    const areEqual = combined.size === set1.size && combined.size === set2.size;
    return areEqual;
}
function arePropsEqual(props1, props2, options) {
    if (props1 === undefined && props2 === undefined)
        return true;
    if (props1 === undefined || props2 === undefined)
        return false;
    const keys1 = Object.keys(props1);
    const keys2 = Object.keys(props2);
    if (!areArraysEqual(keys1, keys2))
        return false;
    for (const key of keys1) {
        if (!areSchemasEqual(props1[key], props2[key], options))
            return false;
    }
    return true;
}
function isSubset(mainSchema, subSchema, options) {
    const mergedSchema = schema_builder_1.mergeSchemas([mainSchema, subSchema]);
    // console.log(JSON.stringify(mergedSchema, null, 4));
    const isModified = areSchemasEqual(mergedSchema, mainSchema, options);
    return isModified;
}
exports.isSubset = isSubset;
//# sourceMappingURL=schema-comparator.js.map