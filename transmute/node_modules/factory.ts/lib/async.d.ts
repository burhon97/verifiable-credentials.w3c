import { RecPartial, Omit } from "./shared";
import * as Sync from "./sync";
import { Async } from ".";
export interface AsyncFactoryConfig {
    readonly startingSequenceNumber?: number;
}
export declare type FactoryFunc<T, K extends keyof T, U = T> = keyof T extends K ? (item?: RecPartial<T>) => Promise<U> : (item: RecPartial<T> & Omit<T, K>) => Promise<U>;
export declare type ListFactoryFunc<T, K extends keyof T, U = T> = keyof T extends K ? (count: number, item?: RecPartial<T>) => Promise<U[]> : (count: number, item: RecPartial<T> & Omit<T, K>) => Promise<U[]>;
export declare function lift<T>(t: T | Promise<T>): Promise<T>;
export declare class Generator<T> {
    readonly func: (seq: number) => T | Promise<T>;
    constructor(func: (seq: number) => T | Promise<T>);
    build(seq: number): Promise<T>;
}
export declare class Derived<TOwner, TProperty> {
    readonly func: (owner: TOwner, seq: number) => TProperty | Promise<TProperty>;
    constructor(func: (owner: TOwner, seq: number) => TProperty | Promise<TProperty>);
    build(owner: TOwner, seq: number): Promise<TProperty>;
}
export interface IFactory<T, K extends keyof T, U> {
    build: FactoryFunc<T, K, U>;
    buildList: ListFactoryFunc<T, K, U>;
}
export declare class Factory<T, K extends keyof T = keyof T> implements IFactory<T, K, T> {
    readonly builder: Builder<T, K>;
    private readonly config;
    private seqNum;
    private getStartingSequenceNumber;
    constructor(builder: Builder<T, K>, config: AsyncFactoryConfig | undefined);
    resetSequenceNumber(): void;
    build: Async.FactoryFunc<T, K, T>;
    buildList: Async.ListFactoryFunc<T, K, T>;
    extend(def: RecPartial<Builder<T, K>>): Factory<T, K>;
    combine<U, K2 extends keyof U>(other: Factory<U, K2>): Factory<T & U, K | K2>;
    transform<U>(fn: (t: T) => U | Promise<U>): TransformFactory<T, K, U>;
    withDerivation<KOut extends keyof T>(kOut: KOut, f: (v1: T, seq: number) => T[KOut] | Promise<T[KOut]>): Factory<T, K>;
    withDerivation1<K1 extends keyof T, KOut extends keyof T>(kInput: [K1], kOut: KOut, f: (v1: T[K1], seq: number) => T[KOut] | Promise<T[KOut]>): Factory<T, K>;
    withDerivation2<K1 extends keyof T, K2 extends keyof T, KOut extends keyof T>(kInput: [K1, K2], kOut: KOut, f: (v1: T[K1], v2: T[K2], seq: number) => T[KOut] | Promise<T[KOut]>): Factory<T, K>;
    withDerivation3<K1 extends keyof T, K2 extends keyof T, K3 extends keyof T, KOut extends keyof T>(kInput: [K1, K2, K3], kOut: KOut, f: (v1: T[K1], v2: T[K2], v3: T[K3], seq: number) => T[KOut] | Promise<T[KOut]>): Factory<T, K>;
    withDerivation4<K1 extends keyof T, K2 extends keyof T, K3 extends keyof T, K4 extends keyof T, KOut extends keyof T>(kInput: [K1, K2, K3, K4], kOut: KOut, f: (v1: T[K1], v2: T[K2], v3: T[K3], v4: T[K4], seq: number) => T[KOut] | Promise<T[KOut]>): Factory<T, K>;
    withDerivation5<K1 extends keyof T, K2 extends keyof T, K3 extends keyof T, K4 extends keyof T, K5 extends keyof T, KOut extends keyof T>(kInput: [K1, K2, K3, K4, K5], kOut: KOut, f: (v1: T[K1], v2: T[K2], v3: T[K3], v4: T[K4], v5: T[K5], seq: number) => T[KOut] | Promise<T[KOut]>): Factory<T, K>;
}
export declare class TransformFactory<T, K extends keyof T, U> implements IFactory<T, K, U> {
    private readonly inner;
    private readonly transform;
    constructor(inner: Factory<T, K>, transform: (t: T) => U | Promise<U>);
    build: Async.FactoryFunc<T, K, U>;
    buildList: Async.ListFactoryFunc<T, K, U>;
}
export declare type Builder<T, K extends keyof T = keyof T> = {
    [P in K]: T[P] | Promise<T[P]> | Generator<T[P]> | Derived<T, T[P]>;
};
export declare function val<T>(val: T): Generator<T>;
export declare function each<T>(f: (seqNum: number) => T | Promise<T>): Generator<T>;
export declare function makeFactory<T>(builder: Builder<T, keyof T>, config?: AsyncFactoryConfig): Factory<T, keyof T>;
export declare function makeFactoryWithRequired<T, K extends keyof T>(builder: Builder<T, Exclude<keyof T, K>>, config?: AsyncFactoryConfig): Factory<T, Exclude<keyof T, K>>;
export declare function makeFactoryFromSync<T, K extends keyof T = keyof T>(builder: Sync.Builder<T, K>, config?: AsyncFactoryConfig): Factory<T, K>;
