import * as Async from "./async";
import { RecPartial, Omit } from "./shared";
declare type MaybePromise<T> = T | Promise<T>;
declare type PromiseFunc<P, T> = (p: P) => MaybePromise<T>;
declare type MaybePromiseFunc<P, T> = T | PromiseFunc<P, T>;
declare type PipePartial<P, T> = MaybePromiseFunc<P, RecPartial<T>>;
declare type PipePartialRec<P, T, K extends keyof T> = MaybePromiseFunc<P, RecPartial<Pick<T, K>> & Omit<T, K>>;
export declare class Pipeline<P extends Object = {}> implements PromiseLike<P> {
    private current;
    constructor(current: Promise<P>);
    static start(): Pipeline<{}>;
    addValues<P2 extends Object>(val: MaybePromiseFunc<P, P2>): Pipeline<P & P2>;
    addFactoryFunc<T, U, K extends string, KT extends keyof T>(factory: Async.FactoryFunc<T, KT, U>, key: K, partial: keyof T extends KT ? PipePartial<P, T> : PipePartialRec<P, T, KT>): Pipeline<P & {
        [k in K]: U;
    }>;
    addFactory<T, K extends string, KT extends keyof T>(factory: Async.Factory<T, KT>, key: K, partial: keyof T extends KT ? PipePartial<P, T> : PipePartialRec<P, T, KT>): Pipeline<P & {
        [k in K]: T;
    }>;
    addTxFactory<T, U, K extends string, KT extends keyof T = keyof T>(factory: Async.TransformFactory<T, KT, U>, key: K, partial: keyof T extends KT ? PipePartial<P, T> : PipePartialRec<P, T, KT>): Pipeline<P & {
        [k in K]: U;
    }>;
    then<TResult1 = P, TResult2 = never>(onfulfilled?: (value: P) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2>;
}
export {};
